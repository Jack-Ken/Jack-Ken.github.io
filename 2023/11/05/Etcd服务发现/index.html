

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Angry Potato">
  <meta name="keywords" content="">
  
    <meta name="description" content="Etcd服务发现与注册、自定义负载均衡1、什么是服务发现与注册服务注册和发现的基本原理如下： 服务注册 指服务实例启动的时候将自身的信息注册到服务注册与发现中心，并在运行的时候通过心跳的方式向服务注册发现中心汇报自身服务状态 服务发现 指服务实例向服务注册与发现中心获取的其他服务实例信息，用于进行后续的远程调用。 2、服务注册和发现的作用1、管理实例信息 管理当前注册到服务注册与发现中心的微服务实">
<meta property="og:type" content="article">
<meta property="og:title" content="Etcd服务发现与注册、自定义负载均衡">
<meta property="og:url" content="http://example.com/2023/11/05/Etcd%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/index.html">
<meta property="og:site_name" content="Angry Potato">
<meta property="og:description" content="Etcd服务发现与注册、自定义负载均衡1、什么是服务发现与注册服务注册和发现的基本原理如下： 服务注册 指服务实例启动的时候将自身的信息注册到服务注册与发现中心，并在运行的时候通过心跳的方式向服务注册发现中心汇报自身服务状态 服务发现 指服务实例向服务注册与发现中心获取的其他服务实例信息，用于进行后续的远程调用。 2、服务注册和发现的作用1、管理实例信息 管理当前注册到服务注册与发现中心的微服务实">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://pic4.zhimg.com/80/v2-ef494d4338d0bee2719095ed997cc79f_1440w.webp">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy81V1hFdUdZWklpYkNkTGdoczF5NzVUaWFsTm9odjFUOFQ1aWEwQ1NuaWJBaWF6S2huMXJlT2RhUWljNUdFQXN5VmtrcEFta05wUnZZQ3NWSHU3TFkxS3RTMjhXdy82NDA?x-oss-process=image/format,png">
<meta property="og:image" content="http://example.com/pic/16.png">
<meta property="og:image" content="http://example.com/pic/17.png">
<meta property="og:image" content="http://example.com/pic/18.png">
<meta property="og:image" content="http://example.com/pic/19.png">
<meta property="og:image" content="http://example.com/pic/12.png">
<meta property="og:image" content="http://example.com/pic/13.png">
<meta property="og:image" content="http://example.com/pic/14.png">
<meta property="og:image" content="http://example.com/pic/15.png">
<meta property="article:published_time" content="2023-11-05T09:22:26.661Z">
<meta property="article:modified_time" content="2023-08-01T16:25:13.073Z">
<meta property="article:author" content="Angry Potato">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://pic4.zhimg.com/80/v2-ef494d4338d0bee2719095ed997cc79f_1440w.webp">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>Etcd服务发现与注册、自定义负载均衡 - Angry Potato</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.5","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.0.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Angry Potato&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>作者</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Etcd服务发现与注册、自定义负载均衡"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-11-05 17:22" pubdate>
          2023年11月5日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          19k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          158 分钟
        
      </span>
    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Etcd服务发现与注册、自定义负载均衡</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="Etcd服务发现与注册、自定义负载均衡"><a href="#Etcd服务发现与注册、自定义负载均衡" class="headerlink" title="Etcd服务发现与注册、自定义负载均衡"></a>Etcd服务发现与注册、自定义负载均衡</h1><h2 id="1、什么是服务发现与注册"><a href="#1、什么是服务发现与注册" class="headerlink" title="1、什么是服务发现与注册"></a>1、什么是服务发现与注册</h2><p>服务注册和发现的基本原理如下：<img src="https://pic4.zhimg.com/80/v2-ef494d4338d0bee2719095ed997cc79f_1440w.webp" srcset="/img/loading.gif" lazyload alt="服务注册和发现"></p>
<p><strong>服务注册</strong></p>
<p>指服务实例启动的时候将自身的信息注册到服务注册与发现中心，并在运行的时候通过心跳的方式向服务注册发现中心汇报自身服务状态</p>
<p><strong>服务发现</strong></p>
<p>指服务实例向服务注册与发现中心获取的其他服务实例信息，用于进行后续的远程调用。</p>
<h2 id="2、服务注册和发现的作用"><a href="#2、服务注册和发现的作用" class="headerlink" title="2、服务注册和发现的作用"></a>2、服务注册和发现的作用</h2><p>1、管理实例信息</p>
<p>管理当前注册到服务注册与发现中心的微服务实例元数据信息，这些信息包括服务实例的服务名，IP地址，端口号，服务状态和服务描述等等信息</p>
<p>2、健康检查</p>
<p>服务注册与发现中心会与已经注册 ok 的微服务实例维持心跳，定期检查注册表中的服务是否正常在线，并且会在过程中剔除掉无效的服务实例信息</p>
<p>3、提供服务发现的作用</p>
<p>服务发现是指在分布式系统中自动发现和识别服务实例的过程。在一个典型的分布式应用中，服务通常被拆分成多个小的、可伸缩的服务实例，这些实例可能被部署在不同的物理机器或容器中。服务发现可以帮助应用程序识别它所依赖的服务实例的位置和状态，并在需要的时候自动连接到这些服务。</p>
<p>服务发现通常包括两个主要组件：服务注册和服务发现。服务注册是指服务实例向服务注册中心注册自己的信息，包括服务名称、IP地址、端口号、协议类型等。服务注册中心将这些信息存储下来，供其他服务或客户端查询。服务发现是指服务实例或客户端查询服务注册中心，以获取服务实例的信息。查询可以按服务名称、标签等方式进行，服务发现返回匹配的服务实例列表，客户端根据这些信息与服务实例建立连接。</p>
<p>如一个服务需要调用服务注册与发现中心中的微服务实例，可以通过<strong>服务注册与发现中心</strong>获取到其具体的服务实例信息</p>
<h2 id="3、ETCD"><a href="#3、ETCD" class="headerlink" title="3、ETCD"></a>3、ETCD</h2><p>ETCD 一个开源的、高可用的分布式key-value存储系统，可以用于配置共享和服务的注册和发现，它专注于：</p>
<ul>
<li>简单：定义清晰、面向用户的API（gRPC）</li>
<li>安全：可选的客户端TLS证书自动认证</li>
<li>快速：支持每秒10,000次写入</li>
<li>可靠：基于Raft算法确保强一致性</li>
</ul>
<h5 id="etcd与redis差异"><a href="#etcd与redis差异" class="headerlink" title="etcd与redis差异"></a>etcd与redis差异</h5><p>etcd和redis都支持键值存储，也支持分布式特性，redis支持的数据格式更加丰富，但是他们两个定位和应用场景不一样，关键差异如下：</p>
<ul>
<li>redis在分布式环境下不是强一致性的，可能会丢失数据，或者读取不到最新数据</li>
<li>redis的数据变化监听机制没有etcd完善</li>
<li>etcd强一致性保证数据可靠性，导致性能上要低于redis</li>
<li>etcd和ZooKeeper是定位类似的项目，跟redis定位不一样</li>
</ul>
<h5 id="为什么用-etcd-而不用ZooKeeper？"><a href="#为什么用-etcd-而不用ZooKeeper？" class="headerlink" title="为什么用 etcd 而不用ZooKeeper？"></a>为什么用 etcd 而不用ZooKeeper？</h5><p>相较之下，ZooKeeper有如下缺点：</p>
<ul>
<li><code>复杂</code>：ZooKeeper的部署维护复杂，管理员需要掌握一系列的知识和技能；而 Paxos 强一致性算法也是素来以复杂难懂而闻名于世；另外，ZooKeeper的使用也比较复杂，需要安装客户端，官方只提供了 Java 和 C 两种语言的接口。</li>
<li><code>难以维护</code>：Java 编写。这里不是对 Java 有偏见，而是 Java 本身就偏向于重型应用，它会引入大量的依赖。而运维人员则普遍希望保持强一致、高可用的机器集群尽可能简单，维护起来也不易出错。</li>
<li><code>发展缓慢</code>：Apache 基金会项目特有的“Apache Way”在开源界饱受争议，其中一大原因就是由于基金会庞大的结构以及松散的管理导致项目发展缓慢。</li>
</ul>
<p><strong>使用etcd进行服务注册与健康检查</strong></p>
<p>根据etcd的<code>v3 API</code>，当启动一个服务时候，我们把服务的地址写进etcd，注册服务。同时绑定租约（lease），并以续租约（keep leases alive）的方式检测服务是否正常运行，从而实现健康检查。</p>
<p>我们先定义服务包，用于描述服务信息、定义工具函数-根据服务信息生成前缀等。</p>
<div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> etcd

<span class="hljs-keyword">import</span> (
	<span class="hljs-string">&quot;encoding/json&quot;</span>
	<span class="hljs-string">&quot;errors&quot;</span>
	<span class="hljs-string">&quot;fmt&quot;</span>
	<span class="hljs-string">&quot;strings&quot;</span>

	<span class="hljs-string">&quot;google.golang.org/grpc/resolver&quot;</span>
)

<span class="hljs-keyword">type</span> Server <span class="hljs-keyword">struct</span> &#123;
	Name    <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;name&quot;`</span>
	Addr    <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;addr&quot;`</span>    <span class="hljs-comment">//服务地址</span>
	Version <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;version&quot;`</span> <span class="hljs-comment">//服务版本</span>
	Weight  <span class="hljs-type">int64</span>  <span class="hljs-string">`json:&quot;weight&quot;`</span>  <span class="hljs-comment">//服务权重</span>
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BuildPrefix</span><span class="hljs-params">(info *Server)</span></span> <span class="hljs-type">string</span> &#123;
	<span class="hljs-keyword">if</span> info.Version == <span class="hljs-string">&quot;&quot;</span> &#123;
		<span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;/%s/&quot;</span>, info.Name)
	&#125;
	<span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;/%s/%s/&quot;</span>, info.Name, info.Addr)
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BuildRegPath</span><span class="hljs-params">(info *Server)</span></span> <span class="hljs-type">string</span> &#123;
	<span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;%s%s&quot;</span>, BuildPrefix(info), info.Addr)
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ParseValue</span><span class="hljs-params">(value []<span class="hljs-type">byte</span>)</span></span> (*Server, <span class="hljs-type">error</span>) &#123;
	info := &amp;Server&#123;&#125;
	<span class="hljs-keyword">if</span> err := json.Unmarshal(value, &amp;info); err != <span class="hljs-literal">nil</span> &#123;
		<span class="hljs-keyword">return</span> info, err
	&#125;
	<span class="hljs-keyword">return</span> info, <span class="hljs-literal">nil</span>
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SplitPath</span><span class="hljs-params">(path <span class="hljs-type">string</span>)</span></span> (*Server, <span class="hljs-type">error</span>) &#123;
	info := &amp;Server&#123;&#125;
	strs := strings.Split(path, <span class="hljs-string">&quot;/&quot;</span>)
	<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(strs) == <span class="hljs-number">0</span> &#123;
		<span class="hljs-keyword">return</span> info, errors.New(<span class="hljs-string">&quot;invalid path&quot;</span>)
	&#125;
	info.Addr = strs[<span class="hljs-built_in">len</span>(strs)<span class="hljs-number">-1</span>]
	<span class="hljs-keyword">return</span> info, <span class="hljs-literal">nil</span>
&#125;

<span class="hljs-comment">// Exist helper function</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Exist</span><span class="hljs-params">(l []resolver.Address, addr resolver.Address)</span></span> <span class="hljs-type">bool</span> &#123;
	<span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> l &#123;
		<span class="hljs-keyword">if</span> l[i].Addr == addr.Addr &#123;
			<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
		&#125;
	&#125;
	<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
&#125;

<span class="hljs-comment">// Remove helper function</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Remove</span><span class="hljs-params">(s []resolver.Address, addr resolver.Address)</span></span> ([]resolver.Address, <span class="hljs-type">bool</span>) &#123;
	<span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> s &#123;
		<span class="hljs-keyword">if</span> s[i].Addr == addr.Addr &#123;
			s[i] = s[<span class="hljs-built_in">len</span>(s)<span class="hljs-number">-1</span>]
			<span class="hljs-keyword">return</span> s[:<span class="hljs-built_in">len</span>(s)<span class="hljs-number">-1</span>], <span class="hljs-literal">true</span>
		&#125;
	&#125;
	<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">false</span>
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BuildResolverUrl</span><span class="hljs-params">(app <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;
	<span class="hljs-keyword">return</span> schema + <span class="hljs-string">&quot;:///&quot;</span> + app
&#125;
</code></pre></div>



<p>服务端的主要步骤如下：</p>
<ul>
<li>创建gprc服务端</li>
<li>将grpc服务端的ip和port等信息作为value，服务名（自己取，如：&#x2F;ns&#x2F;cloud-service-1）作为key，put到etcd中</li>
</ul>
<p>由于服务端无法保证自身是一直可用的，可能会宕机，所以etcd的租约是有时间限制的，租约一旦过期，服务端存储在etcd上的服务信息就会消失。</p>
<p>另一方面，如果服务端是正常运行的，etcd中的地址信息又必须存在，因此发送心跳检测，一旦发现etcd上没有自己的服务地址时，请求重新添加（续租）。</p>
<div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> etcd

<span class="hljs-keyword">import</span> (
	<span class="hljs-string">&quot;context&quot;</span>
	<span class="hljs-string">&quot;encoding/json&quot;</span>
	<span class="hljs-string">&quot;errors&quot;</span>
	<span class="hljs-string">&quot;net/http&quot;</span>
	<span class="hljs-string">&quot;strconv&quot;</span>
	<span class="hljs-string">&quot;strings&quot;</span>
	<span class="hljs-string">&quot;time&quot;</span>

	clientv3 <span class="hljs-string">&quot;go.etcd.io/etcd/client/v3&quot;</span>
	<span class="hljs-string">&quot;go.uber.org/zap&quot;</span>
)

<span class="hljs-comment">// Register for grpc server</span>
<span class="hljs-keyword">type</span> Register <span class="hljs-keyword">struct</span> &#123;
	EtcdAddrs   []<span class="hljs-type">string</span>
	DialTimeout <span class="hljs-type">int</span>

	ctx    context.Context
	cancel context.CancelFunc

	leasesID    clientv3.LeaseID
	keepAliveCh &lt;-<span class="hljs-keyword">chan</span> *clientv3.LeaseKeepAliveResponse

	srvInfo *Server
	srvTTL  <span class="hljs-type">int64</span>
	cli     *clientv3.Client
	logger  *zap.Logger
&#125;

<span class="hljs-comment">// NewRegister create a register base on etcd</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewRegister</span><span class="hljs-params">(etcdAddrs []<span class="hljs-type">string</span>, looger *zap.Logger)</span></span> *Register &#123;
	<span class="hljs-keyword">return</span> &amp;Register&#123;
		EtcdAddrs:   etcdAddrs,
		DialTimeout: <span class="hljs-number">3</span>,
		logger:      looger,
	&#125;
&#125;

<span class="hljs-comment">// Register a service</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *Register)</span></span> Register(srvInfo *Server, ttl <span class="hljs-type">int64</span>) (context.CancelFunc, <span class="hljs-type">error</span>) &#123;
	<span class="hljs-keyword">var</span> err <span class="hljs-type">error</span>

	<span class="hljs-keyword">if</span> strings.Split(srvInfo.Addr, <span class="hljs-string">&quot;:&quot;</span>)[<span class="hljs-number">0</span>] == <span class="hljs-string">&quot;&quot;</span> &#123;
		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, errors.New(<span class="hljs-string">&quot;invalid ip&quot;</span>)
	&#125;

	<span class="hljs-keyword">if</span> r.cli, err = clientv3.New(clientv3.Config&#123;
		Endpoints:   r.EtcdAddrs,
		DialTimeout: time.Duration(r.DialTimeout) * time.Second,
	&#125;); err != <span class="hljs-literal">nil</span> &#123;
		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err
	&#125;

	r.srvInfo = srvInfo
	r.srvTTL = ttl

	<span class="hljs-keyword">if</span> err = r.register(); err != <span class="hljs-literal">nil</span> &#123;
		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err
	&#125;

	<span class="hljs-keyword">go</span> r.KeepAlive()

	<span class="hljs-keyword">return</span> r.cancel, <span class="hljs-literal">nil</span>

&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *Register)</span></span> register() <span class="hljs-type">error</span> &#123;
	leaseCtx, cancel := context.WithCancel(context.Background())
	<span class="hljs-comment">//leaseCtx, cancel := context.WithTimeout(context.Background(), time.Duration(r.DialTimeout)*time.Second)</span>
	r.ctx = leaseCtx
	r.cancel = cancel

	leaseResp, err := r.cli.Grant(leaseCtx, r.srvTTL)
	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;
		<span class="hljs-keyword">return</span> err
	&#125;

	r.leasesID = leaseResp.ID
	<span class="hljs-keyword">if</span> r.keepAliveCh, err = r.cli.KeepAlive(r.ctx, leaseResp.ID); err != <span class="hljs-literal">nil</span> &#123;
		<span class="hljs-keyword">return</span> err
	&#125;

	data, err := json.Marshal(r.srvInfo)
	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;
		<span class="hljs-keyword">return</span> err
	&#125;
	_, err = r.cli.Put(r.ctx, BuildRegPath(r.srvInfo), <span class="hljs-type">string</span>(data), clientv3.WithLease(r.leasesID))
	<span class="hljs-keyword">return</span> err
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *Register)</span></span> unregister() <span class="hljs-type">error</span> &#123;
	_, err := r.cli.Delete(r.ctx, BuildRegPath(r.srvInfo))
	<span class="hljs-keyword">return</span> err
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *Register)</span></span> KeepAlive() &#123;
	ticker := time.NewTicker(time.Duration(r.srvTTL) * time.Second)

	<span class="hljs-keyword">for</span> &#123;
		<span class="hljs-keyword">select</span> &#123;
		<span class="hljs-keyword">case</span> &lt;-r.ctx.Done():
			<span class="hljs-keyword">if</span> err := r.unregister(); err != <span class="hljs-literal">nil</span> &#123;
				r.logger.Error(<span class="hljs-string">&quot;unregister failed&quot;</span>, zap.Error(err))
			&#125;
			<span class="hljs-keyword">if</span> _, err := r.cli.Revoke(r.ctx, r.leasesID); err != <span class="hljs-literal">nil</span> &#123;
				r.logger.Error(<span class="hljs-string">&quot;revoke failed&quot;</span>, zap.Error(err))
			&#125;
			<span class="hljs-keyword">return</span>
		<span class="hljs-keyword">case</span> res := &lt;-r.keepAliveCh:
			<span class="hljs-comment">// 发现etcd上没有自己的服务地址,请求重新添加（续租）</span>
			<span class="hljs-keyword">if</span> res == <span class="hljs-literal">nil</span> &#123;
				<span class="hljs-keyword">if</span> err := r.register(); err != <span class="hljs-literal">nil</span> &#123;
					r.logger.Error(<span class="hljs-string">&quot;register failed&quot;</span>, zap.Error(err))
				&#125;
			&#125;
		<span class="hljs-keyword">case</span> &lt;-ticker.C:
			<span class="hljs-keyword">if</span> r.keepAliveCh == <span class="hljs-literal">nil</span> &#123;
				<span class="hljs-keyword">if</span> err := r.register(); err != <span class="hljs-literal">nil</span> &#123;
					r.logger.Error(<span class="hljs-string">&quot;register failed&quot;</span>, zap.Error(err))
				&#125;
			&#125;
		&#125;

	&#125;
&#125;

<span class="hljs-comment">// UpdateHandler return http handler</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *Register)</span></span> UpdateHandler() http.HandlerFunc &#123;
	<span class="hljs-keyword">return</span> http.HandlerFunc(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;
		wi := req.URL.Query().Get(<span class="hljs-string">&quot;weight&quot;</span>)
		weight, err := strconv.Atoi(wi)
		<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;
			w.WriteHeader(http.StatusBadRequest)
			w.Write([]<span class="hljs-type">byte</span>(err.Error()))
			<span class="hljs-keyword">return</span>
		&#125;

		<span class="hljs-keyword">var</span> update = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> &#123;
			r.srvInfo.Weight = <span class="hljs-type">int64</span>(weight)
			data, err := json.Marshal(r.srvInfo)
			<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;
				<span class="hljs-keyword">return</span> err
			&#125;
			_, err = r.cli.Put(r.ctx, BuildRegPath(r.srvInfo), <span class="hljs-type">string</span>(data), clientv3.WithLease(r.leasesID))
			<span class="hljs-keyword">return</span> err
		&#125;

		<span class="hljs-keyword">if</span> err := update(); err != <span class="hljs-literal">nil</span> &#123;
			w.WriteHeader(http.StatusInternalServerError)
			w.Write([]<span class="hljs-type">byte</span>(err.Error()))
			<span class="hljs-keyword">return</span>
		&#125;
		w.Write([]<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;update server weight success&quot;</span>))
	&#125;)
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *Register)</span></span> GetServerInfo() (*Server, <span class="hljs-type">error</span>) &#123;
	resp, err := r.cli.Get(r.ctx, BuildRegPath(r.srvInfo))
	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;
		<span class="hljs-keyword">return</span> r.srvInfo, err
	&#125;
	info := &amp;Server&#123;&#125;
	<span class="hljs-keyword">if</span> resp.Count &gt;= <span class="hljs-number">1</span> &#123;
		<span class="hljs-keyword">if</span> err := json.Unmarshal(resp.Kvs[<span class="hljs-number">0</span>].Value, &amp;info); err != <span class="hljs-literal">nil</span> &#123;
			<span class="hljs-keyword">return</span> info, err
		&#125;
	&#125;
	<span class="hljs-keyword">return</span> info, <span class="hljs-literal">nil</span>
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *Register)</span></span> Close() &#123;
	r.cancel()
&#125;</code></pre></div>

<p>我们封装好注册服务器之后，我们需要在启动grpc服务时调用，下面的代码就是将一个grpc服务注册到etcd中。</p>
<div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main

<span class="hljs-keyword">import</span> (
	<span class="hljs-string">&quot;mini_tiktok/etcd&quot;</span>
	<span class="hljs-string">&quot;mini_tiktok/internal/initialize&quot;</span>
	<span class="hljs-string">&quot;mini_tiktok/internal/rpc/client&quot;</span>
	authService <span class="hljs-string">&quot;mini_tiktok/internal/rpc/rpcGen/auth&quot;</span>
	<span class="hljs-string">&quot;net&quot;</span>

	<span class="hljs-string">&quot;google.golang.org/grpc&quot;</span>

	<span class="hljs-string">&quot;go.uber.org/zap&quot;</span>
)

<span class="hljs-keyword">const</span> Network = <span class="hljs-string">&quot;tcp&quot;</span>

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
	serverInfo := &amp;etcd.Server&#123;
		Name:    <span class="hljs-string">&quot;user-service-1&quot;</span>,
		Addr:    <span class="hljs-string">&quot;127.0.0.1:8889&quot;</span>,
		Version: <span class="hljs-string">&quot;v1&quot;</span>,
		Weight:  <span class="hljs-number">6</span>,
	&#125;

	listener, err := net.Listen(Network, serverInfo.Addr)

	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;
		initialize.Log.Fatal(<span class="hljs-string">&quot;net.Listen err: %v&quot;</span>, zap.Error(err))
	&#125;

	<span class="hljs-comment">// 创建注册器</span>
	etcdRegister := etcd.NewRegister(initialize.Conf.EtcdConfig.Addrs, initialize.Log)
	<span class="hljs-keyword">defer</span> etcdRegister.Close()

    <span class="hljs-comment">// 注册服务</span>
	_, err = etcdRegister.Register(serverInfo, <span class="hljs-number">3</span>)
	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;
		initialize.Log.Fatal(<span class="hljs-string">&quot;register Server to etcd failed: %v&quot;</span>, zap.Error(err))
	&#125;

	<span class="hljs-comment">// 新建gRPC服务器实例</span>
	grpcServer := grpc.NewServer()
	<span class="hljs-comment">// 在gRPC服务器注册我们的服务</span>
	authService.RegisterAuthServiceServer(grpcServer, &amp;client.AuthService&#123;&#125;)

	<span class="hljs-comment">//用服务器 Serve() 方法以及我们的端口信息区实现阻塞等待，直到进程被杀死或者 Stop() 被调用</span>
	err = grpcServer.Serve(listener)
	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;
		initialize.Log.Fatal(<span class="hljs-string">&quot;grpcServer.Serve err: %v&quot;</span>, zap.Error(err))
	&#125;
&#125;
</code></pre></div>



<p><strong>使用etcd实现服务发现</strong></p>
<p>首先我们先来了解一下Name Resolution流程</p>
<p>gRPC resolver 包定义了两个接口  Resolver和 Bulider。我们需要自定义代码实现两个接口。其中Resolver的实现是整个功能最核心的代码，需要将服务名解析为对应的实例。而后者的实现者需要创建并注册一个Bulider实例。这样，当客户端在调用Dial方法对指定的服务拨号时，grpc resolver查找注册的Builder实例调用其build()方法构建自定义的Resolver实例。其中Build()方法的作用就是创建一个Resolver实例。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy81V1hFdUdZWklpYkNkTGdoczF5NzVUaWFsTm9odjFUOFQ1aWEwQ1NuaWJBaWF6S2huMXJlT2RhUWljNUdFQXN5VmtrcEFta05wUnZZQ3NWSHU3TFkxS3RTMjhXdy82NDA?x-oss-process=image/format,png" srcset="/img/loading.gif" lazyload alt="Resolver流程"></p>
<p>下面是gprc Resolver的整个详细流程</p>
<ul>
<li><p>客户端启动时，引入自定义的 resolver 包（比如本例中我们自定义的 ns 包）</p>
<ul>
<li>引入 ns 包，在 init() 阶段，构造自定义的 resolveBuilder，并将其注册到 grpc 内部的 resolveBuilder 表中（其实是一个全局 map，key 为协议名，比如 ns；value 为构造的 resolveBuilder，比如 nsResolverBuilder）。</li>
</ul>
</li>
<li><p>客户端启动时通过自定义 Dail() 方法构造 grpc.ClientConn 单例</p>
<ul>
<li>grpc.DialContext() 方法内部解析 URI，分析协议类型，并从 resolveBuilder 表中查找协议对应的 resolverBuilder。比如本例中我们定义的 URI 协议类型为 ns，对应的 resolverBuilder 为 nsResolverBuilder</li>
<li>找到指定的 resolveBuilder 后，调用 resolveBuilder 的 Build() 方法，构建自定义 resolver，同时开启协程，通过此 resolver 更新被调服务实例列表。</li>
<li>Dial() 方法接收主调服务名和被调服务名，并根据自定义的协议名，基于这两个参数构造服务的 URI</li>
<li>Dial() 方法内部使用构造的 URI，调用 grpc.DialContext() 方法对指定服务进行拨号</li>
</ul>
</li>
<li><p>grpc 底层 LB 库对每个实例均创建一个 subConnection，最终根据相应的 LB 策略，选择合适的 subConnection 处理某次 RPC 请求。</p>
</li>
</ul>
<p>grpc客户端为我们提供了实现服务发现和负载均衡的钩子，下面是实现服务发现的源码。</p>
<div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> etcd

<span class="hljs-keyword">import</span> (
	<span class="hljs-string">&quot;context&quot;</span>
	<span class="hljs-string">&quot;time&quot;</span>

	<span class="hljs-string">&quot;go.etcd.io/etcd/api/v3/mvccpb&quot;</span>
	clientv3 <span class="hljs-string">&quot;go.etcd.io/etcd/client/v3&quot;</span>
	<span class="hljs-string">&quot;go.uber.org/zap&quot;</span>
	<span class="hljs-string">&quot;google.golang.org/grpc/resolver&quot;</span>
)

<span class="hljs-keyword">const</span> (
	schema = <span class="hljs-string">&quot;etcd&quot;</span>
)

<span class="hljs-comment">// Resolver for grpc client</span>
<span class="hljs-keyword">type</span> Resolver <span class="hljs-keyword">struct</span> &#123;
	schema      <span class="hljs-type">string</span>
	EtcdAddrs   []<span class="hljs-type">string</span>
	DialTimeout <span class="hljs-type">int</span>

	ctx    context.Context
	cancel context.CancelFunc

	watchCh      clientv3.WatchChan
	cli          *clientv3.Client
	keyPrifix    <span class="hljs-type">string</span>
	srvAddrsList []resolver.Address

	cc     resolver.ClientConn
	logger *zap.Logger
&#125;

<span class="hljs-comment">// NewResolver create a new resolver.Builder base on etcd</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewResolver</span><span class="hljs-params">(etcdAddrs []<span class="hljs-type">string</span>, logger *zap.Logger)</span></span> *Resolver &#123;
	<span class="hljs-keyword">return</span> &amp;Resolver&#123;
		schema:      schema,
		EtcdAddrs:   etcdAddrs,
		DialTimeout: <span class="hljs-number">3</span>,
		logger:      logger,
	&#125;
&#125;

<span class="hljs-comment">// Scheme returns the scheme supported by this resolver.</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *Resolver)</span></span> Scheme() <span class="hljs-type">string</span> &#123;
	<span class="hljs-keyword">return</span> r.schema
&#125;

<span class="hljs-comment">// Build creates a new resolver.Resolver for the given target</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *Resolver)</span></span> Build(target resolver.Target, cc resolver.ClientConn, opts resolver.BuildOptions) (resolver.Resolver, <span class="hljs-type">error</span>) &#123;
	r.cc = cc

	r.keyPrifix = BuildPrefix(&amp;Server&#123;Name: target.Endpoint, Version: target.Authority&#125;)
	<span class="hljs-keyword">if</span> _, err := r.start(); err != <span class="hljs-literal">nil</span> &#123;
		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err
	&#125;
	<span class="hljs-keyword">return</span> r, <span class="hljs-literal">nil</span>
&#125;

<span class="hljs-comment">// ResolveNow resolver.Resolver interface</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *Resolver)</span></span> ResolveNow(o resolver.ResolveNowOptions) &#123;&#125;

<span class="hljs-comment">// Close resolver.Resolver interface</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *Resolver)</span></span> Close() &#123;
	r.cancel()
&#125;

<span class="hljs-comment">// start</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *Resolver)</span></span> start() (context.CancelFunc, <span class="hljs-type">error</span>) &#123;
	<span class="hljs-keyword">var</span> err <span class="hljs-type">error</span>
	r.cli, err = clientv3.New(clientv3.Config&#123;
		Endpoints:   r.EtcdAddrs,
		DialTimeout: time.Duration(r.DialTimeout) * time.Second,
	&#125;)
	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;
		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err
	&#125;
	resolver.Register(r)

	r.ctx, r.cancel = context.WithCancel(context.Background())

	<span class="hljs-keyword">if</span> err = r.sync(); err != <span class="hljs-literal">nil</span> &#123;
		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err
	&#125;

	<span class="hljs-keyword">go</span> r.watch()

	<span class="hljs-keyword">return</span> r.cancel, <span class="hljs-literal">nil</span>
&#125;

<span class="hljs-comment">// watch update events</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *Resolver)</span></span> watch() &#123;
	ticker := time.NewTicker(time.Minute)
	r.watchCh = r.cli.Watch(r.ctx, r.keyPrifix, clientv3.WithPrefix())

	<span class="hljs-keyword">for</span> &#123;
		<span class="hljs-keyword">select</span> &#123;
		<span class="hljs-keyword">case</span> &lt;-r.ctx.Done():
			<span class="hljs-keyword">return</span>
		<span class="hljs-keyword">case</span> res, ok := &lt;-r.watchCh:
			<span class="hljs-keyword">if</span> ok &#123;
				r.update(res.Events)
			&#125;
		<span class="hljs-keyword">case</span> &lt;-ticker.C:
			<span class="hljs-keyword">if</span> err := r.sync(); err != <span class="hljs-literal">nil</span> &#123;
				r.logger.Error(<span class="hljs-string">&quot;sync failed&quot;</span>, zap.Error(err))
			&#125;
		&#125;
	&#125;
&#125;

<span class="hljs-comment">// update</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *Resolver)</span></span> update(events []*clientv3.Event) &#123;
	<span class="hljs-keyword">for</span> _, ev := <span class="hljs-keyword">range</span> events &#123;
		<span class="hljs-keyword">var</span> info *Server
		<span class="hljs-keyword">var</span> err <span class="hljs-type">error</span>

		<span class="hljs-keyword">switch</span> ev.Type &#123;
		<span class="hljs-keyword">case</span> mvccpb.PUT:
			info, err = ParseValue(ev.Kv.Value)
			<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;
				<span class="hljs-keyword">continue</span>
			&#125;
			addr := resolver.Address&#123;Addr: info.Addr, Metadata: info.Weight&#125;
			<span class="hljs-keyword">if</span> !Exist(r.srvAddrsList, addr) &#123;
				r.srvAddrsList = <span class="hljs-built_in">append</span>(r.srvAddrsList, addr)
				r.cc.UpdateState(resolver.State&#123;Addresses: r.srvAddrsList&#125;)
			&#125;
		<span class="hljs-keyword">case</span> mvccpb.DELETE:
			info, err = SplitPath(<span class="hljs-type">string</span>(ev.Kv.Key))
			<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;
				<span class="hljs-keyword">continue</span>
			&#125;
			addr := resolver.Address&#123;Addr: info.Addr&#125;
			<span class="hljs-keyword">if</span> s, ok := Remove(r.srvAddrsList, addr); ok &#123;
				r.srvAddrsList = s
				r.cc.UpdateState(resolver.State&#123;Addresses: r.srvAddrsList&#125;)
			&#125;
		&#125;
	&#125;
&#125;

<span class="hljs-comment">// sync 同步获取所有地址信息</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *Resolver)</span></span> sync() <span class="hljs-type">error</span> &#123;
	ctx, cancel := context.WithTimeout(r.ctx, <span class="hljs-number">3</span>*time.Second)
	<span class="hljs-keyword">defer</span> cancel()
	res, err := r.cli.Get(ctx, r.keyPrifix, clientv3.WithPrefix())
	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;
		<span class="hljs-keyword">return</span> err
	&#125;
	r.srvAddrsList = []resolver.Address&#123;&#125;

	<span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> res.Kvs &#123;
		info, err := ParseValue(v.Value)
		<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;
			<span class="hljs-keyword">continue</span>
		&#125;
		addr := resolver.Address&#123;Addr: info.Addr, Metadata: info.Weight&#125;
		r.srvAddrsList = <span class="hljs-built_in">append</span>(r.srvAddrsList, addr)
	&#125;
	r.cc.UpdateState(resolver.State&#123;Addresses: r.srvAddrsList&#125;)
	<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>
&#125;</code></pre></div>

<p>客户端使用服务注册的代码如下</p>
<div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> FeedClient feedService.FeedServiceClient

<span class="hljs-comment">//const feed_address = &quot;127.0.0.1:8890&quot;</span>

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;
	<span class="hljs-comment">// 注册自定义的ETCD解析器</span>
	etcdResolverBuilder := etcd.NewResolver([]<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;127.0.0.1:2379&quot;</span>&#125;, initialize.Log)
	resolver.Register(etcdResolverBuilder)

	<span class="hljs-comment">// 连接服务器</span>
	conn, err := grpc.Dial(etcdResolverBuilder.Scheme()+<span class="hljs-string">&quot;:///feed-service-1&quot;</span>, grpc.WithTransportCredentials(insecure.NewCredentials()))
	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;
		log.Fatalf(<span class="hljs-string">&quot;net.Connect err: %v&quot;</span>, err)
	&#125;
	<span class="hljs-keyword">defer</span> conn.Close()

	<span class="hljs-comment">// 建立gRPC连接</span>
	FeedClient = feedService.NewFeedServiceClient(conn)
    
    <span class="hljs-comment">// client调用服务</span>
    <span class="hljs-comment">// ......</span>
&#125;</code></pre></div>

<h2 id="4、负载均衡"><a href="#4、负载均衡" class="headerlink" title="4、负载均衡"></a>4、负载均衡</h2><p>为了提高系统的负载能力和稳定性，我们的服务端往往具有多台服务器，负载均衡的目的就是希望请求能分散到不同的服务器，从服务器列表中选择一台服务器的算法就是负载均衡的策略，常见的轮循、加权轮询等</p>
<p>负载均衡器要在多台服务器之间选择，所以通常情况下负载均衡器是具备服务发现的能力的</p>
<h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><p>根据负载均衡实现所在的位置不同，通常可分为以下三种解决方案：</p>
<p><strong>1、集中式负载均衡（Proxy Model）</strong></p>
<p>在客户端和服务端之间有一个独立的LB，通常是专门的硬件设备如 F5，或者基于软件如 LVS，HAproxy，Nginx等实现。LB使用负载均衡策略将请求转发到目标服务</p>
<p>这种做法的缺点也很明显，所有的服务调用流量都会经过LB，当服务数量和调用量大的时候，LB就会成为瓶颈。一旦LB故障就会影响整个系统。而且在服务端和客户端之间增加一级，有一定的性能开销。</p>
<p><img src="/pic/16.png" srcset="/img/loading.gif" lazyload alt="集中式负载均衡"></p>
<p><strong>2、客户端负载均衡（Balancing-aware Client）</strong></p>
<p>将LB的功能集中到客户端进程中，然后使用负载均衡策略选择一个目标服务地址，向目标发起请求。LB能力被分散到每一个服务消费者的进程内部，同时服务消费方和服务提供方之间是直接调用，没有额外的开销，性泵较好。</p>
<p>缺点，但是如果有多种不同的语言栈，就要配合开发不同的客户端，有一定的研发和维护成本；后续如果要对客户库进行升级，势必要求服务调用方修改代码并重新发布，实际比较麻烦。</p>
<p><img src="/pic/17.png" srcset="/img/loading.gif" lazyload alt="客户端负载均衡"></p>
<p><strong>3、独立负载均衡进程（External Load Balancing Service）</strong></p>
<p>将LB从进程内移出来，变成主机上的一个独立进程。主机上的一个或者多个服务要访问目标服务时，他们都通过同一主机上的独立LB进程做负载均衡</p>
<p>此方案有两种模式</p>
<p>第一种是直接由LB进行转发请求，被称为sidecar方案</p>
<p>第二种是从LB获取到IP后依旧由客户端发起请求，gRPC曾经支持过此方案叫lookaside方案，目前已废弃</p>
<p>该方案也是一种分布式方案没有单点问题，一个LB进程挂了只影响该主机上的客户端；客户端和LB之间是本地调用调用性能好；同时该方案还简化了客户端，不需要为不同语言开发客户库，LB的升级不需要服务调用方改代码。该方案主要问题：部署较复杂，环节多，出错调试排查问题不方便</p>
<p><img src="/pic/18.png" srcset="/img/loading.gif" lazyload alt="独立负载均衡进程"></p>
<h3 id="gRPC的负载均衡"><a href="#gRPC的负载均衡" class="headerlink" title="gRPC的负载均衡"></a>gRPC的负载均衡</h3><p>gRPC中的负载平衡是以每次调用为基础，而不是以每个连接为基础。换句话说，即使所有的请求都来自一个客户端，它仍能在所有的服务器上实现负载平衡</p>
<p><strong>gRPC目前内置四种策略</strong></p>
<p>pick_first：默认策略，选择第一个</p>
<p>round_robin：轮询</p>
<p>使用默认的负载均衡器很简单，只需要在建立连接的时候指定负载均衡策略即可。</p>
<p><strong>但是要注意</strong>：旧版本gRPC使用 <code>grpc.WithBalancerName(&quot;round_robin&quot;)</code>,已经被废弃，需要使用<code>grpc.WithDefaultServiceConfig</code>。<code>grpc.WithDefaultServiceConfig</code>可以被上文服务发现中提到的cc.UpdateState(State) error覆盖配置</p>
<div class="code-wrapper"><pre><code class="hljs go">conn, err := grpc.Dial(<span class="hljs-string">&quot;example:cluster@callee&quot;</span>,
  grpc.WithInsecure(),
  grpc.WithDefaultServiceConfig(
   <span class="hljs-string">`&#123;&quot;loadBalancingPolicy&quot;:&quot;round_robin&quot;&#125;`</span>,
  ),
 )</code></pre></div>



<p>grpclb：已废弃不做介绍</p>
<p>xDS</p>
<p>xDS 在服务端实现服务发现，配置负载均衡策略等。支持xDS的客户端连接到xDS 服务端并通过xDS api来获取各种需要的数据和配置。</p>
<p><img src="/pic/19.png" srcset="/img/loading.gif" lazyload alt="servicemesh的负载均衡"></p>
<h3 id="自定义负载均衡器"><a href="#自定义负载均衡器" class="headerlink" title="自定义负载均衡器"></a>自定义负载均衡器</h3><p>自定义负载均衡器需要使用google.golang.org&#x2F;grpc&#x2F;balancer.Register提前注册，此函数和服务发现一样接受工厂函数</p>
<div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// Builder creates a balancer.</span>
<span class="hljs-keyword">type</span> Builder <span class="hljs-keyword">interface</span> &#123;
 <span class="hljs-comment">// Build creates a new balancer with the ClientConn.</span>
 Build(cc ClientConn, opts BuildOptions) Balancer
 <span class="hljs-comment">// Name returns the name of balancers built by this builder.</span>
 <span class="hljs-comment">// It will be used to pick balancers (for example in service config).</span>
 Name() <span class="hljs-type">string</span>
&#125;</code></pre></div>

<p><code>Name()</code>是负载均衡策略的名字</p>
<p><code>Build(...)</code>需要返回负载均衡器</p>
<p> <code>cc ClientConn</code>代表客户端与服务端的连接，其拥有一系列函数可以让我们更新链接的状态</p>
<div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Balancer <span class="hljs-keyword">interface</span> &#123;
 <span class="hljs-comment">// UpdateClientConnState is called by gRPC when the state of the ClientConn</span>
 <span class="hljs-comment">// changes.  If the error returned is ErrBadResolverState, the ClientConn</span>
 <span class="hljs-comment">// will begin calling ResolveNow on the active name resolver with</span>
 <span class="hljs-comment">// exponential backoff until a subsequent call to UpdateClientConnState</span>
 <span class="hljs-comment">// returns a nil error.  Any other errors are currently ignored.</span>
 UpdateClientConnState(ClientConnState) <span class="hljs-type">error</span>
 <span class="hljs-comment">// ResolverError is called by gRPC when the name resolver reports an error.</span>
 ResolverError(<span class="hljs-type">error</span>)
 <span class="hljs-comment">// UpdateSubConnState is called by gRPC when the state of a SubConn</span>
 <span class="hljs-comment">// changes.</span>
 UpdateSubConnState(SubConn, SubConnState)
 <span class="hljs-comment">// Close closes the balancer. The balancer is not required to call</span>
 <span class="hljs-comment">// ClientConn.RemoveSubConn for its existing SubConns.</span>
 Close()
&#125;</code></pre></div>



<p><strong>类RR算法负载均衡器</strong></p>
<p>我们查看round_robin负载均衡的源码的具体实现，</p>
<p><img src="/pic/12.png" srcset="/img/loading.gif" lazyload alt="image-20230801223826630"></p>
<p>roundrobin.go主要实现逻辑总结：</p>
<ul>
<li><strong>1. 定义一个负载均衡名称</strong></li>
</ul>
<blockquote>
<p>const Name &#x3D; “round_robin”</p>
</blockquote>
<ul>
<li><strong>2. 定义一个rrPickerBuilder，它只有一个方法：</strong></li>
</ul>
<blockquote>
<p>func (*rrPickerBuilder) Build(info base.PickerBuildInfo) balancer.Picker{…}</p>
</blockquote>
<p>rrPickerBuilder实际上是<strong>PikcerBuilder接口的实现：</strong></p>
<p><strong>下面代码是PickerBuilder 接口</strong></p>
<div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// PickerBuilder creates balancer.Picker.</span>
<span class="hljs-keyword">type</span> PickerBuilder <span class="hljs-keyword">interface</span> &#123;
	<span class="hljs-comment">// Build returns a picker that will be used by gRPC to pick a SubConn.</span>
	Build(info PickerBuildInfo) balancer.Picker
&#125;</code></pre></div>

<ul>
<li><strong>3. 定义一个rrPicker，它也只有一个方法：</strong></li>
</ul>
<blockquote>
<p>func (p *rrPicker) Pick(balancer.PickInfo) (balancer.PickResult, error){…}</p>
</blockquote>
<p>rrPicker实际上是<strong>Picker接口的实现：</strong></p>
<div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Picker <span class="hljs-keyword">interface</span> &#123;
	Pick(info PickInfo) (PickResult, <span class="hljs-type">error</span>)
&#125;</code></pre></div>

<ul>
<li><strong>4. 定义一个newBuild方法用来创建这个策略，定义init方法用来注册创建的策略</strong></li>
</ul>
<p><strong>主要方法作用简单说明：</strong></p>
<ol>
<li><strong>Build方法：对连接进行使用前的处理，如果本地连接有变化，如调用</strong>UpdateState(State) <strong>会执行一次此方法，如：在Build中我们可以将某个连接复制多份，或者干脆不处理，直接返回</strong></li>
<li><strong>Pick方法：每次客户端请求服务前会调用Pick方法拿到一个连接，用这个连接去请求</strong></li>
</ol>
<p><strong>实现基于权重的的负载均衡策略</strong></p>
<p>上面我们对roundrobin.go有了一个了解后，就可以开始自定义负载均衡策略：基于权重的负载均衡策略（weight_*load_*balance.go），代码结构预览如下：</p>
<p><img src="/pic/13.png" srcset="/img/loading.gif" lazyload alt="image-20230801224602187"></p>
<p>详细代码如下</p>
<div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> lb

<span class="hljs-keyword">import</span> (
	<span class="hljs-string">&quot;log&quot;</span>
	<span class="hljs-string">&quot;math/rand&quot;</span>
	<span class="hljs-string">&quot;sync&quot;</span>

	<span class="hljs-string">&quot;google.golang.org/grpc/balancer&quot;</span>
	<span class="hljs-string">&quot;google.golang.org/grpc/balancer/base&quot;</span>
)

<span class="hljs-keyword">const</span> WEIGHT_LOAD_BALANCE = <span class="hljs-string">&quot;weight_lb_picker&quot;</span>
<span class="hljs-keyword">const</span> MAX_WEIGHT = <span class="hljs-number">10</span> <span class="hljs-comment">// 可设置的最大权重</span>
<span class="hljs-keyword">const</span> MIN_WEIGHT = <span class="hljs-number">1</span>  <span class="hljs-comment">// 可设置的最小权重</span>

<span class="hljs-comment">// 注册自定义权重负载均衡器</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newBuilder</span><span class="hljs-params">()</span></span> balancer.Builder &#123;
	<span class="hljs-keyword">return</span> base.NewBalancerBuilder(WEIGHT_LOAD_BALANCE, &amp;weightPikerBuilder&#123;&#125;, base.Config&#123;HealthCheck: <span class="hljs-literal">true</span>&#125;)
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;
	balancer.Register(newBuilder())
&#125;

<span class="hljs-keyword">type</span> weightPikerBuilder <span class="hljs-keyword">struct</span> &#123;
&#125;

<span class="hljs-comment">// 根据负载均衡策略 生成重复的连接</span>

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *weightPikerBuilder)</span></span> Build(info base.PickerBuildInfo) balancer.Picker &#123;

	log.Println(<span class="hljs-string">&quot;weightPikerBuilder build called...&quot;</span>)

	<span class="hljs-comment">// 没有可用的连接</span>
	<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(info.ReadySCs) == <span class="hljs-number">0</span> &#123;
		<span class="hljs-keyword">return</span> base.NewErrPicker(balancer.ErrNoSubConnAvailable)
	&#125;

	<span class="hljs-comment">// 此处有坑，为什么长度给0,而不是1???</span>

	scs := <span class="hljs-built_in">make</span>([]balancer.SubConn, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(info.ReadySCs))

	<span class="hljs-keyword">for</span> subConn, subConnInfo := <span class="hljs-keyword">range</span> info.ReadySCs &#123;
		<span class="hljs-comment">//v := subConnInfo.Address.BalancerAttributes.Value(WeightAttributeKey&#123;&#125;)</span>
		w := subConnInfo.Address.Attributes.Value(<span class="hljs-string">&quot;weight&quot;</span>).(<span class="hljs-type">int</span>)

		<span class="hljs-comment">// 限制可以设置的最大最小权重，防止设置过大创建连接数太多</span>
		<span class="hljs-keyword">if</span> w &lt; MIN_WEIGHT &#123;
			w = MIN_WEIGHT
		&#125;

		<span class="hljs-keyword">if</span> w &gt; MAX_WEIGHT &#123;
			w = MAX_WEIGHT
		&#125;

		<span class="hljs-comment">// 根据权重 创建多个重复的连接 权重越高个数越多</span>
		<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; w; i++ &#123;
			scs = <span class="hljs-built_in">append</span>(scs, subConn)
		&#125;

	&#125;

	<span class="hljs-keyword">return</span> &amp;weightPiker&#123;
		scs: scs,
	&#125;
&#125;

<span class="hljs-keyword">type</span> weightPiker <span class="hljs-keyword">struct</span> &#123;
	scs []balancer.SubConn
	mu  sync.Mutex
&#125;

<span class="hljs-comment">// 从build方法生成的连接数中选择一个连接返回</span>

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *weightPiker)</span></span> Pick(info balancer.PickInfo) (balancer.PickResult, <span class="hljs-type">error</span>) &#123;

	<span class="hljs-comment">// 随机选择一个返回，权重越大，生成的连接个数越多，因此，被选中的概率也越大</span>
	log.Println(<span class="hljs-string">&quot;weightPiker Pick called...&quot;</span>)
	p.mu.Lock()
	index := rand.Intn(<span class="hljs-built_in">len</span>(p.scs))
	sc := p.scs[index]
	p.mu.Unlock()
	<span class="hljs-keyword">return</span> balancer.PickResult&#123;SubConn: sc&#125;, <span class="hljs-literal">nil</span>
&#125;</code></pre></div>



<p>既然是基于权重的负载均衡策略，因此，我们在解析IP时需要获取权重值，在获取IP时我们又需要将对应的权重设置到我们的Addr中，通过上一篇将grpc服务注册到etcd中我们知道可以调用discovery包中的updata方法设置地址，因此我们可以在设置地址时增加一些属性，如：权重，下图中的129行代码。</p>
<p><img src="/pic/14.png" srcset="/img/loading.gif" lazyload alt="image-20230801231343262"></p>
<p>使用，在调用Dial函数创建<code>ClientConn</code>连接的时候传入，</p>
<div class="code-wrapper"><pre><code class="hljs go">grpc.WithDefaultServiceConfig(<span class="hljs-string">`&#123;&quot;loadBalancingPolicy&quot;:&quot;weight_lb_picker&quot;&#125;`</span></code></pre></div>

<div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// 连接服务器</span>
conn, err := grpc.Dial(etcdResolverBuilder.Scheme()+<span class="hljs-string">&quot;:///user-service-1/v1&quot;</span>, grpc.WithTransportCredentials(insecure.NewCredentials()), grpc.WithDefaultServiceConfig(
   <span class="hljs-string">`&#123;&quot;loadBalancingPolicy&quot;:&quot;weight_lb_picker&quot;&#125;`</span>,
))</code></pre></div>

<p>这样就会使用我们自定义的负载均衡策略来选择服务节点。</p>
<p>创建多个服务节点的服务端，客户端选择的结果如下图所示，其中80端口的服务权重是8， 81端口的服务权重是2，可以看到80端口更容易被选中。</p>
<p><img src="/pic/15.png" srcset="/img/loading.gif" lazyload alt="image-20230801235431462"></p>
<p>源码获取：[AngryPotato&#x2F;grpc-etcd](<a target="_blank" rel="noopener" href="https://github.com/Jack-Ken/grpc-etcd">Jack-Ken&#x2F;grpc-etcd (github.com)</a>)</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Go%E5%AD%A6%E4%B9%A0/" class="category-chain-item">Go学习</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Etcd服务发现与注册、自定义负载均衡</div>
      <div>http://example.com/2023/11/05/Etcd服务发现/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Angry Potato</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年11月5日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/11/05/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87-%E9%80%9A%E9%81%93/" title="面试准备-通道">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">面试准备-通道</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/11/05/go%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/" title="单元测试">
                        <span class="hidden-mobile">单元测试</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.5.1/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"pXevgf5JuXkM3CgDIf9HeouE-gzGzoHsz","appKey":"Zd47bUm8Ks18HvRti1Ra4wz4","path":"window.location.pathname","placeholder":"欢迎交流","avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"https://pxevgf5j.lc-cn-n1-shared.com","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
