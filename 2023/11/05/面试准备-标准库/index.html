<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>面试准备-标准库 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="面试准备-标准库1、context1.1 context有什么作用Go常被用来写后台服务，在Go的sever里，通常每来一个请求就会启动若干个goroutine来同时工作：有些去数据库拿数据，有些去下游接口获取相关数据  但是这些goroutine会共享一些请求的基本数据，例如登录token，处理请求的最大超时时间等等。当请被取消的时候，所有为这个请求工作的那些协程都要快速退出，因为他们的结果已经">
<meta property="og:type" content="article">
<meta property="og:title" content="面试准备-标准库">
<meta property="og:url" content="http://example.com/2023/11/05/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87-%E6%A0%87%E5%87%86%E5%BA%93/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="面试准备-标准库1、context1.1 context有什么作用Go常被用来写后台服务，在Go的sever里，通常每来一个请求就会启动若干个goroutine来同时工作：有些去数据库拿数据，有些去下游接口获取相关数据  但是这些goroutine会共享一些请求的基本数据，例如登录token，处理请求的最大超时时间等等。当请被取消的时候，所有为这个请求工作的那些协程都要快速退出，因为他们的结果已经">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/pic/5.png">
<meta property="og:image" content="http://example.com/pic/7.png">
<meta property="og:image" content="http://example.com/pic/8.png">
<meta property="og:image" content="http://example.com/pic/9.png">
<meta property="og:image" content="http://example.com/pic/10.png">
<meta property="og:image" content="http://example.com/pic/11.png">
<meta property="article:published_time" content="2023-11-05T04:15:30.935Z">
<meta property="article:modified_time" content="2023-07-19T07:35:42.663Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/pic/5.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.0.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-面试准备-标准库" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/11/05/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87-%E6%A0%87%E5%87%86%E5%BA%93/" class="article-date">
  <time class="dt-published" datetime="2023-11-05T04:15:30.935Z" itemprop="datePublished">2023-11-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Go%E9%9D%A2%E8%AF%95/">Go面试</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      面试准备-标准库
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="面试准备-标准库"><a href="#面试准备-标准库" class="headerlink" title="面试准备-标准库"></a>面试准备-标准库</h1><h2 id="1、context"><a href="#1、context" class="headerlink" title="1、context"></a>1、context</h2><h3 id="1-1-context有什么作用"><a href="#1-1-context有什么作用" class="headerlink" title="1.1 context有什么作用"></a>1.1 context有什么作用</h3><p>Go常被用来写后台服务，在Go的sever里，通常每来一个请求就会启动若干个goroutine来同时工作：有些去数据库拿数据，有些去下游接口获取相关数据</p>
<p><img src="/pic/5.png" alt="request"></p>
<p>但是这些goroutine会共享一些请求的基本数据，例如登录token，处理请求的最大超时时间等等。当请被取消的时候，所有为这个请求工作的那些协程都要快速退出，因为他们的结果已经不需要了。而请求超时也会防止因等待请求返回导致的协程堆积，造成系统资源的浪费，甚至服务宕机的发生。</p>
<p>总结来说:<strong>context用来解决在goroutine之间<code>退出通知</code>、<code>元数据传递</code>的功能。</strong></p>
<p>[引申1] 举例说明 context 在实际项目中如何使用。</p>
<p>context使用起来十分方便，源码里面提供了一个创建<strong>根节点context</strong>的函数：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Background</span><span class="params">()</span></span> Context</span><br></pre></td></tr></table></figure>

<p>这会返回一个空的context，不能被取消，没有值，也没有超时时间。有了根节点context，又提供了四个函数创建子节点context：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCancel</span><span class="params">(parent Context)</span></span> (ctx Context, cancel CancelFunc)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithDeadline</span><span class="params">(parent Context, deadline time.Time)</span></span> (Context, CancelFunc)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithTimeout</span><span class="params">(parent Context, timeout time.Duration)</span></span> (Context, CancelFunc)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithValue</span><span class="params">(parent Context, key, val <span class="keyword">interface</span>&#123;&#125;)</span></span> Context</span><br></pre></td></tr></table></figure>

<p>context会在函数传递间传递只需要在适当的时间调用cancel函数向goroutine发出取消信号或者调用Value函数取出context中的值。</p>
<p>在官方的博客中对context的使用提出了下面几点建议：</p>
<ol>
<li><strong>不要将 Context 塞到结构体里。直接将 Context 类型作为函数的第一参数，而且一般都命名为 ctx。</strong></li>
<li><strong>不要向函数传入一个 nil 的 context，如果你实在不知道传什么，标准库给你准备好了一个 context：todo。</strong></li>
<li><strong>不要把本应该作为函数参数的类型塞到 context 中，context 存储的应该是一些共同的数据。例如：登陆的 session、cookie 等。</strong></li>
<li><strong>同一个 context 可能会被传递到多个 goroutine，别担心，context 是并发安全的。</strong></li>
</ol>
<p><strong>传递共享的数据</strong></p>
<p>对于 Web 服务端开发，往往希望将一个请求处理的整个过程串起来，这就非常依赖于 Thread Local（对于 Go 可理解为单个协程所独有） 的变量，而在 Go 语言中并没有这个概念，因此需要在函数调用的时候传递 context。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ctx := context.Background()</span><br><span class="line">	process(ctx)</span><br><span class="line"></span><br><span class="line">	ctx = context.WithValue(ctx, <span class="string">&quot;traceId&quot;</span>, <span class="string">&quot;qcrao-2019&quot;</span>)</span><br><span class="line">	process(ctx)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">process</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">	traceId, ok := ctx.Value(<span class="string">&quot;traceId&quot;</span>).(<span class="type">string</span>)</span><br><span class="line">	<span class="keyword">if</span> ok &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;process over. trace_id=%s\n&quot;</span>, traceId)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;process over. no trace_id\n&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">process over. no trace_id</span><br><span class="line">process over. trace_id=qcrao-2019</span><br></pre></td></tr></table></figure>

<p>第一次调用 process 函数时，ctx 是一个空的 context，自然取不出来 traceId。第二次，通过 <code>WithValue</code> 函数创建了一个 context，并赋上了 <code>traceId</code> 这个 key，自然就能取出来传入的 value 值。</p>
<p>当然，现实场景中可能是从一个 HTTP 请求中获取到的 Request-ID。所以，下面这个样例可能更适合：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> requestIDKey <span class="type">int</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithRequestID</span><span class="params">(next http.Handler)</span></span> http.Handler &#123;</span><br><span class="line">	<span class="keyword">return</span> http.HandlerFunc(</span><br><span class="line">		<span class="function"><span class="keyword">func</span><span class="params">(rw http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">			<span class="comment">// 从 header 中提取 request-id</span></span><br><span class="line">			reqID := req.Header.Get(<span class="string">&quot;X-Request-ID&quot;</span>)</span><br><span class="line">			<span class="comment">// 创建 valueCtx。使用自定义的类型，不容易冲突</span></span><br><span class="line">			ctx := context.WithValue(</span><br><span class="line">				req.Context(), requestIDKey, reqID)</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// 创建新的请求</span></span><br><span class="line">			req = req.WithContext(ctx)</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// 调用 HTTP 处理函数</span></span><br><span class="line">			next.ServeHTTP(rw, req)</span><br><span class="line">		&#125;</span><br><span class="line">	)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 request-id</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetRequestID</span><span class="params">(ctx context.Context)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	ctx.Value(requestIDKey).(<span class="type">string</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Handle</span><span class="params">(rw http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 拿到 reqId，后面可以记录日志等等</span></span><br><span class="line">	reqID := GetRequestID(req.Context())</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	handler := WithRequestID(http.HandlerFunc(Handle))</span><br><span class="line">	http.ListenAndServe(<span class="string">&quot;/&quot;</span>, handler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>取消goroutine</strong></p>
<p>我们先来设想一个场景：打开外卖的订单页，地图上显示外卖小哥的位置，而且是每秒更新 1 次。app 端向后台发起 websocket 连接（现实中可能是轮询）请求后，后台启动一个协程，每隔 1 秒计算 1 次小哥的位置，并发送给端。如果用户退出此页面，则后台需要“取消”此过程，退出 goroutine，系统回收资源。</p>
<p>后端实现可能如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Perform</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        calculatePos()</span><br><span class="line">        sendResult()</span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要实现取消功能，不使用context的情况下，肯能会这样做：给函数增加一个指针型的 bool 变量，在 for 语句的开始处判断 bool 变量是发由 true 变为 false，如果改变，则退出循环。</p>
<p>这么做虽然能够实现功能，但是并不优雅，并且一旦协程数量多了之后，并且各种嵌套，就会很麻烦。所以就要使用context。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Perform</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        calculatePos()</span><br><span class="line">        sendResult()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">            <span class="comment">// 被取消，直接返回</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">case</span> &lt;-time.After(time.Second):</span><br><span class="line">            <span class="comment">// block 1 秒钟 </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要流程可能是这样：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ctx, cancel := context.WithTimeout(context.Background(), time.Hour)</span><br><span class="line"><span class="keyword">go</span> Perform(ctx)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ……</span></span><br><span class="line"><span class="comment">// app 端返回页面，调用cancel 函数</span></span><br><span class="line">cancel()</span><br></pre></td></tr></table></figure>

<p>注意一个细节，<strong>WithTimeOut 函数返回的 context 和 cancelFun 是分开的。context 本身并没有取消函数</strong>，这样做的原因是取消函数只能由外层函数调用，防止子节点 context 调用取消函数，从而严格控制信息的流向：<strong>由父节点 context 流向子节点 context。</strong></p>
<p><strong>防止goroutine泄露</strong></p>
<p>看一下下面这个例子：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个协程可以生成无限个数的整数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gen</span><span class="params">()</span></span> &lt;-<span class="keyword">chan</span> <span class="type">int</span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">var</span> n <span class="type">int</span></span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			ch &lt;- n</span><br><span class="line">			n++</span><br><span class="line">			time.Sleep(time.Second)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> n := <span class="keyword">range</span> gen() &#123;</span><br><span class="line">		fmt.Println(n)</span><br><span class="line">        <span class="comment">// 生成5个整数之后，就break，但是gen函数的协程会无线循环的执行，永远不会停下。发生协程泄露</span></span><br><span class="line">		<span class="keyword">if</span> n == <span class="number">5</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// ……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用context改进这个例子：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gen</span><span class="params">(ctx context.Context)</span></span> &lt;-<span class="keyword">chan</span> <span class="type">int</span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">var</span> n <span class="type">int</span></span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			<span class="keyword">case</span> ch &lt;- n:</span><br><span class="line">				n++</span><br><span class="line">				time.Sleep(time.Second)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line">	<span class="keyword">defer</span> cancel() <span class="comment">// 避免其他地方忘记 cancel，且重复调用不影响</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> n := <span class="keyword">range</span> gen(ctx) &#123;</span><br><span class="line">		fmt.Println(n)</span><br><span class="line">		<span class="keyword">if</span> n == <span class="number">5</span> &#123;</span><br><span class="line">			cancel()</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// ……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>增加一个 context，在 break 前调用 cancel 函数，取消 goroutine。gen 函数在接收到取消信号后，直接退出，系统回收资源。</p>
<h3 id="1-2-context-Value的查找过程是怎样的"><a href="#1-2-context-Value的查找过程是怎样的" class="headerlink" title="1.2 context.Value的查找过程是怎样的"></a>1.2 context.Value的查找过程是怎样的</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> valueCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">	Context</span><br><span class="line">	key, val <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它实现了两个方法：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *valueCtx)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%v.WithValue(%#v, %#v)&quot;</span>, c.Context, c.key, c.val)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *valueCtx)</span></span> Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">	<span class="keyword">if</span> c.key == key &#123;</span><br><span class="line">		<span class="keyword">return</span> c.val</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> c.Context.Value(key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于它直接将 Context 作为匿名字段，因此仅管它只实现了 2 个方法，其他方法继承自父 context。但它仍然是一个 Context，这是 Go 语言的一个特点。</p>
<p>创建 valueCtx 的函数：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithValue</span><span class="params">(parent Context, key, val <span class="keyword">interface</span>&#123;&#125;)</span></span> Context &#123;</span><br><span class="line">	<span class="keyword">if</span> key == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;nil key&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> !reflect.TypeOf(key).Comparable() &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;key is not comparable&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> &amp;valueCtx&#123;parent, key, val&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>key必须是可比较的，因为之后需要通过key去除context中的值，可比较的是必须的。</p>
<p>通过层层传递 context，最终形成这样一棵树：</p>
<p>![&#x2F;pic&#x2F;6.png)</p>
<p>和链表比较相像，但是所有的context都指向它的父节点，通过 WithValue 函数，可以创建层层的 valueCtx，存储 goroutine 间可以共享的变量。</p>
<p>而取值的过程，实际上就是一个递归查找的过程：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *valueCtx)</span></span> Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">	<span class="keyword">if</span> c.key == key &#123;</span><br><span class="line">		<span class="keyword">return</span> c.val</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> c.Context.Value(key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它会顺着链路一直往上查找，比较当前的key和要查找的key是否一样，是的话据返回value。否则就一直顺着context往前，直到最终找到根节点，直接返回一个nil，所以用Value方法的时候要判断结果是否为nil。</p>
<p>因为查找方向是往上走得，所以父节点是无法查找子节点存储的值，</p>
<p><code>WithValue</code> 创建 context 节点的过程实际上就是创建链表节点的过程。两个节点的 key 值是可以相等的，但它们是两个不同的 context 节点。查找的时候，会向上查找到最后一个挂载的 context 节点，也就是离得比较近的一个父节点 context。所以，整体上而言，用 <code>WithValue</code> 构造的其实是一个低效率的链表。</p>
<p>如果你接手过项目，肯定经历过这样的窘境：在一个处理过程中，有若干子函数、子协程。各种不同的地方会向 context 里塞入各种不同的 k-v 对，最后在某个地方使用。</p>
<p>你根本就不知道什么时候什么地方传了什么值？这些值会不会被“覆盖”（底层是两个不同的 context 节点，查找的时候，只会返回一个结果）？你肯定会崩溃的。</p>
<p>而这也是 <code>context.Value</code> 最受争议的地方。很多人建议尽量不要通过 context 传值。</p>
<h2 id="2、reflect"><a href="#2、reflect" class="headerlink" title="2、reflect"></a>2、reflect</h2><h3 id="2-1-什么是反射"><a href="#2-1-什么是反射" class="headerlink" title="2.1 什么是反射"></a>2.1 什么是反射</h3><p>反射是计算机程序在运行时可以访问、检测、修改它本身状态或者行为的一种能力。用比喻来说，反射就是程序在运行的时候能够观察并修改自己的行为。</p>
<p>实际上使用汇编语言就可以不使用反射直接在运行时和底层打交道获取任何信息。但是当编程迁移到高级语言上来之后只能通过<code>反射</code>来达到此项技能。</p>
<p>对于反射，《Go语言圣经》对反射的定义是：<strong>Go 语言提供了一种机制在运行时更新变量和检查它们的值、调用它们的方法，但是在编译时并不知道这些变量的具体类型，这称为反射机制。</strong></p>
<h3 id="2-2-什么情况下需要反射"><a href="#2-2-什么情况下需要反射" class="headerlink" title="2.2 什么情况下需要反射"></a>2.2 什么情况下需要反射</h3><p>使用反射的常见场景有以下两种：</p>
<ol>
<li><strong>不能明确接口调用哪个函数，需要根据传入的参数在运行时决定。</strong></li>
<li><strong>不能明确传入函数的参数类型，需要在运行时处理任意对象。</strong></li>
</ol>
<p>但是我们通常不建议使用反射，理由如下：</p>
<ol>
<li>与反射相关的代码，经常是难以阅读的。在软件工程中，代码可读性也是一个非常重要的指标。</li>
<li>Go 语言作为一门静态语言，编码过程中，编译器能提前发现一些类型错误，但是对于反射代码是无能为力的。所以包含反射相关的代码，很可能会运行很久，才会出错，这时候经常是直接 panic，可能会造成严重的后果。</li>
<li>反射对性能影响还是比较大的，比正常代码运行速度慢一到两个数量级。所以，对于一个项目中处于运行效率关键位置的代码，尽量避免使用反射特性。</li>
</ol>
<h3 id="2-3-Go语言如何实现反射"><a href="#2-3-Go语言如何实现反射" class="headerlink" title="2.3 Go语言如何实现反射"></a>2.3 Go语言如何实现反射</h3><p><strong>types 和 interface</strong></p>
<p>我们先来回顾一下interface底层的数据结构</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> iface <span class="keyword">struct</span> &#123;</span><br><span class="line">	tab  *itab</span><br><span class="line">	data unsafe.Pointer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> itab <span class="keyword">struct</span> &#123;</span><br><span class="line">	inter  *interfacetype</span><br><span class="line">	_type  *_type</span><br><span class="line">	link   *itab</span><br><span class="line">	hash   <span class="type">uint32</span></span><br><span class="line">	bad    <span class="type">bool</span></span><br><span class="line">	inhash <span class="type">bool</span></span><br><span class="line">	unused [<span class="number">2</span>]<span class="type">byte</span></span><br><span class="line">	fun    [<span class="number">1</span>]<span class="type">uintptr</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> eface <span class="keyword">struct</span> &#123;</span><br><span class="line">    _type *_type</span><br><span class="line">    data  unsafe.Pointer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>iface数据结构的图示如下图所示“</p>
<p><img src="/pic/7.png" alt="iface 结构体全景"></p>
<p>我们看一下接口之间的各种转换和赋值</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// io.Reeader是一个接口</span></span><br><span class="line"><span class="keyword">var</span> r io.Reader</span><br><span class="line">tty, err := os.OpenFile(<span class="string">&quot;/Users/qcrao/Desktop/test&quot;</span>, os.O_RDWR, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">r = tty</span><br></pre></td></tr></table></figure>

<p>首先声明 <code>r</code> 的类型是 <code>io.Reader</code>，注意，这是 <code>r</code> 的静态类型，此时它的动态类型为 <code>nil</code>，并且它的动态值也是 <code>nil</code>。之后，<code>r = tty</code> 这一语句，将 <code>r</code> 的动态类型变成 <code>*os.File</code>，动态值则变成非空，表示打开的文件对象。这时，r 可以用<code>&lt;value, type&gt;</code>对来表示为： <code>&lt;tty, *os.File&gt;</code>。</p>
<p><img src="/pic/8.png" alt="r=tty"></p>
<p>注意看上图，此时虽然 <code>fun</code> 所指向的函数只有一个 <code>Read</code> 函数，其实 <code>*os.File</code> 还包含 <code>Write</code> 函数，也就是说 <code>*os.File</code> 其实还实现了 <code>io.Writer</code> 接口。因此下面的断言语句可以执行：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> w io.Writer</span><br><span class="line">w = r.(io.Writer)</span><br></pre></td></tr></table></figure>

<p>之所以用断言，而不能直接赋值，是因为 <code>r</code> 的静态类型是 <code>io.Reader</code>，并没有实现 <code>io.Writer</code> 接口。断言能否成功，看 <code>r</code> 的动态类型是否符合要求。</p>
<p>这样，w 也可以表示成 <code>&lt;tty, *os.File&gt;</code>，仅管它和 <code>r</code> 一样，但是 w 可调用的函数取决于它的静态类型 <code>io.Writer</code>，也就是说它只能有这样的调用形式： <code>w.Write()</code> 。<code>w</code> 的内存形式如下图：<img src="/pic/9.png" alt="w = r.(io.Writer)"></p>
<p>和 <code>r</code> 相比，仅仅是 <code>fun</code> 对应的函数变了：<code>Read -&gt; Write</code>。</p>
<p>最后，再来一个赋值：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> empty <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">empty = w</span><br></pre></td></tr></table></figure>

<p>由于 <code>empty</code> 是一个空接口，因此所有的类型都实现了它，w 可以直接赋给它，不需要执行断言操作。</p>
<p><img src="/pic/10.png" alt="empty=w"></p>
<p>我们展示一个关于接口的技巧</p>
<p>先参考源码，分别定义一个<code>“伪装”</code>的 iface 和 eface 结构体。然后将接口变量占据的内存解释成上面定义的类型，在打印出来。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   <span class="string">&quot;io&quot;</span></span><br><span class="line">   <span class="string">&quot;os&quot;</span></span><br><span class="line">   <span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> itab <span class="keyword">struct</span> &#123;</span><br><span class="line">   inter <span class="type">uintptr</span></span><br><span class="line">   _type <span class="type">uintptr</span></span><br><span class="line">   link  <span class="type">uintptr</span></span><br><span class="line">   hash  <span class="type">uint32</span></span><br><span class="line">   _     [<span class="number">4</span>]<span class="type">byte</span></span><br><span class="line">   fun   [<span class="number">1</span>]<span class="type">uintptr</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> iface <span class="keyword">struct</span> &#123;</span><br><span class="line">   tab  *itab</span><br><span class="line">   data unsafe.Pointer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> eface <span class="keyword">struct</span> &#123;</span><br><span class="line">   _type <span class="type">uintptr</span></span><br><span class="line">   data  unsafe.Pointer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> r io.Reader</span><br><span class="line">   fmt.Printf(<span class="string">&quot;initial r: %T, %v\n&quot;</span>, r, r)</span><br><span class="line"></span><br><span class="line">   tty, _ := os.OpenFile(<span class="string">&quot;/Users/qcrao/Desktop/test&quot;</span>, os.O_RDWR, <span class="number">0</span>)</span><br><span class="line">   fmt.Printf(<span class="string">&quot;tty: %T, %v\n&quot;</span>, tty, tty)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 给 r 赋值</span></span><br><span class="line">   r = tty</span><br><span class="line">   fmt.Printf(<span class="string">&quot;r: %T, %v\n&quot;</span>, r, r)</span><br><span class="line"></span><br><span class="line">   rIface := (*iface)(unsafe.Pointer(&amp;r))</span><br><span class="line">   fmt.Printf(<span class="string">&quot;r: iface.tab._type = %#x, iface.data = %#x\n&quot;</span>, rIface.tab._type, rIface.data)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 给 w 赋值</span></span><br><span class="line">   <span class="keyword">var</span> w io.Writer</span><br><span class="line">   w = r.(io.Writer)</span><br><span class="line">   fmt.Printf(<span class="string">&quot;w: %T, %v\n&quot;</span>, w, w)</span><br><span class="line"></span><br><span class="line">   wIface := (*iface)(unsafe.Pointer(&amp;w))</span><br><span class="line">   fmt.Printf(<span class="string">&quot;w: iface.tab._type = %#x, iface.data = %#x\n&quot;</span>, wIface.tab._type, wIface.data)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 给 empty 赋值</span></span><br><span class="line">   <span class="keyword">var</span> empty <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">   empty = w</span><br><span class="line">   fmt.Printf(<span class="string">&quot;empty: %T, %v\n&quot;</span>, empty, empty)</span><br><span class="line"></span><br><span class="line">   emptyEface := (*eface)(unsafe.Pointer(&amp;empty))</span><br><span class="line">   fmt.Printf(<span class="string">&quot;empty: eface._type = %#x, eface.data = %#x\n&quot;</span>, emptyEface._type, emptyEface.data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">initial r: &lt;nil&gt;, &lt;nil&gt;</span><br><span class="line">tty: *os.File, &amp;&#123;0xc4200820f0&#125;</span><br><span class="line">r: *os.File, &amp;&#123;0xc4200820f0&#125;</span><br><span class="line">r: iface.tab._type = 0x10bfcc0, iface.data = 0xc420080020</span><br><span class="line">w: *os.File, &amp;&#123;0xc4200820f0&#125;</span><br><span class="line">w: iface.tab._type = 0x10bfcc0, iface.data = 0xc420080020</span><br><span class="line">empty: *os.File, &amp;&#123;0xc4200820f0&#125;</span><br><span class="line">empty: eface._type = 0x10bfcc0, eface.data = 0xc420080020</span><br></pre></td></tr></table></figure>

<p><code>r，w，empty</code> 的动态类型和动态值都一样</p>
<p><strong>反射的基础函数</strong></p>
<p>reflect 包里定义了一个接口和一个结构体，即 <code>reflect.Type</code> 和 <code>reflect.Value</code>，它们提供很多函数来获取存储在接口里的类型信息。</p>
<p><code>reflect.Type</code> 主要提供关于类型相关的信息，所以它和 <code>_type</code> 关联比较紧密；<code>reflect.Value</code> 则结合 <code>_type</code> 和 <code>data</code> 两者，因此程序员可以获取甚至改变类型的值。</p>
<p>reflect 包中提供了两个基础的关于反射的函数来获取上述的接口和结构体：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TypeOf</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> Type </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ValueOf</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> Value</span><br></pre></td></tr></table></figure>



<p><strong>TypeOf</strong></p>
<p><code>TypeOf</code> 函数用来提取一个接口中值的类型信息（<strong>返回的是动态类型</strong>）。由于它的输入参数是一个空的 <code>interface&#123;&#125;</code>，调用此函数时，实参会先被转化为 <code>interface&#123;&#125;</code>类型。这样，实参的类型信息、方法集、值信息都存储到 <code>interface&#123;&#125;</code> 变量里了。源码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TypeOf</span><span class="params">(i any)</span></span> Type &#123;</span><br><span class="line">   eface := *(*emptyInterface)(unsafe.Pointer(&amp;i))</span><br><span class="line">    <span class="comment">// eface.typ是动态类型</span></span><br><span class="line">   <span class="keyword">return</span> toType(eface.typ)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> emptyInterface <span class="keyword">struct</span> &#123;</span><br><span class="line">	typ  *rtype</span><br><span class="line">	word unsafe.Pointer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">toType</span><span class="params">(t *rtype)</span></span> Type &#123;</span><br><span class="line">	<span class="keyword">if</span> t == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Type</code> 实际上是一个接口，定义了很多方法，用来获取类型相关的各种信息，而 <code>*rtype</code> 实现了 <code>Type</code> 接口。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Type <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// 所有的类型都可以调用下面这些函数</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 此类型的变量对齐后所占用的字节数</span></span><br><span class="line">	Align() <span class="type">int</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 如果是 struct 的字段，对齐后占用的字节数</span></span><br><span class="line">	FieldAlign() <span class="type">int</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 返回类型方法集里的第 `i` (传入的参数)个方法</span></span><br><span class="line">	Method(<span class="type">int</span>) Method</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 通过名称获取方法</span></span><br><span class="line">	MethodByName(<span class="type">string</span>) (Method, <span class="type">bool</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取类型方法集里导出的方法个数</span></span><br><span class="line">	NumMethod() <span class="type">int</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 类型名称</span></span><br><span class="line">	Name() <span class="type">string</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 返回类型所在的路径，如：encoding/base64</span></span><br><span class="line">	PkgPath() <span class="type">string</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 返回类型的大小，和 unsafe.Sizeof 功能类似</span></span><br><span class="line">	Size() <span class="type">uintptr</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 返回类型的字符串表示形式</span></span><br><span class="line">	String() <span class="type">string</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 返回类型的类型值</span></span><br><span class="line">	Kind() Kind</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 类型是否实现了接口 u</span></span><br><span class="line">	Implements(u Type) <span class="type">bool</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 是否可以赋值给 u</span></span><br><span class="line">	AssignableTo(u Type) <span class="type">bool</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 是否可以类型转换成 u</span></span><br><span class="line">	ConvertibleTo(u Type) <span class="type">bool</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 类型是否可以比较</span></span><br><span class="line">	Comparable() <span class="type">bool</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 下面这些函数只有特定类型可以调用</span></span><br><span class="line">	<span class="comment">// 如：Key, Elem 两个方法就只能是 Map 类型才能调用</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 类型所占据的位数</span></span><br><span class="line">	Bits() <span class="type">int</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 返回通道的方向，只能是 chan 类型调用</span></span><br><span class="line">	ChanDir() ChanDir</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 返回类型是否是可变参数，只能是 func 类型调用</span></span><br><span class="line">	<span class="comment">// 比如 t 是类型 func(x int, y ... float64)</span></span><br><span class="line">	<span class="comment">// 那么 t.IsVariadic() == true</span></span><br><span class="line">	IsVariadic() <span class="type">bool</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 返回内部子元素类型，只能由类型 Array, Chan, Map, Ptr, or Slice 调用</span></span><br><span class="line">	Elem() Type</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 返回结构体类型的第 i 个字段，只能是结构体类型调用</span></span><br><span class="line">	<span class="comment">// 如果 i 超过了总字段数，就会 panic</span></span><br><span class="line">	Field(i <span class="type">int</span>) StructField</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 返回嵌套的结构体的字段</span></span><br><span class="line">	FieldByIndex(index []<span class="type">int</span>) StructField</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 通过字段名称获取字段</span></span><br><span class="line">	FieldByName(name <span class="type">string</span>) (StructField, <span class="type">bool</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// FieldByNameFunc returns the struct field with a name</span></span><br><span class="line">	<span class="comment">// 返回名称符合 func 函数的字段</span></span><br><span class="line">	FieldByNameFunc(match <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">string</span>)</span></span> <span class="type">bool</span>) (StructField, <span class="type">bool</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取函数类型的第 i 个参数的类型</span></span><br><span class="line">	In(i <span class="type">int</span>) Type</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 返回 map 的 key 类型，只能由类型 map 调用</span></span><br><span class="line">	Key() Type</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 返回 Array 的长度，只能由类型 Array 调用</span></span><br><span class="line">	Len() <span class="type">int</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 返回类型字段的数量，只能由类型 Struct 调用</span></span><br><span class="line">	NumField() <span class="type">int</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 返回函数类型的输入参数个数</span></span><br><span class="line">	NumIn() <span class="type">int</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 返回函数类型的返回值个数</span></span><br><span class="line">	NumOut() <span class="type">int</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 返回函数类型的第 i 个值的类型</span></span><br><span class="line">	Out(i <span class="type">int</span>) Type</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回类型结构体的相同部分</span></span><br><span class="line">	common() *rtype</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 返回类型结构体的不同部分</span></span><br><span class="line">	uncommon() *uncommonType</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中倒数第二个方法 <code>common</code> 返回的 <code>rtype</code>类型和<code>_type</code> 是一回事。都是用来描述类型的一些公共信息，所有的类型结构体里面都包含<code>rtype</code>，不同的类型会包含自己独特的部分。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> rtype <span class="keyword">struct</span> &#123;</span><br><span class="line">	size       <span class="type">uintptr</span></span><br><span class="line">	ptrdata    <span class="type">uintptr</span></span><br><span class="line">	hash       <span class="type">uint32</span></span><br><span class="line">	tflag      tflag</span><br><span class="line">	align      <span class="type">uint8</span></span><br><span class="line">	fieldAlign <span class="type">uint8</span></span><br><span class="line">	kind       <span class="type">uint8</span></span><br><span class="line">	alg        *typeAlg</span><br><span class="line">	gcdata     *<span class="type">byte</span></span><br><span class="line">	str        nameOff</span><br><span class="line">	ptrToThis  typeOff</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此外，可以看到Type类型实现了String()函数，所以调用<code>fmt.Println</code> 打印的时候，输出的是 <code>String()</code> 的结果。<code>fmt.Printf()</code> 函数，如果使用 <code>%T</code> 来作为格式参数，输出的是 <code>reflect.TypeOf</code> 的结果，也就是动态类型。例如：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(<span class="string">&quot;%T&quot;</span>, <span class="number">3</span>) <span class="comment">// int</span></span><br></pre></td></tr></table></figure>



<p><strong>ValueOf函数</strong></p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ValueOf</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> Value &#123;</span><br><span class="line">	<span class="keyword">if</span> i == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> Value&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">   <span class="comment">// ……</span></span><br><span class="line">	<span class="keyword">return</span> unpackEface(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分解 eface</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unpackEface</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> Value &#123;</span><br><span class="line">	e := (*emptyInterface)(unsafe.Pointer(&amp;i))</span><br><span class="line"></span><br><span class="line">	t := e.typ</span><br><span class="line">	<span class="keyword">if</span> t == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> Value&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	f := flag(t.Kind())</span><br><span class="line">	<span class="keyword">if</span> ifaceIndir(t) &#123;</span><br><span class="line">		f |= flagIndir</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Value&#123;t, e.word, f&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将先将 <code>i</code> 转换成 <code>*emptyInterface</code> 类型， 再将它的 <code>typ</code> 字段和 <code>word</code> 字段以及一个标志位字段组装成一个 <code>Value</code> 结构体，而这就是 <code>ValueOf</code> 函数的返回值，它包含类型结构体指针、真实数据的地址、标志位。</p>
<p>Value 结构体定义了很多方法，通过这些方法可以直接操作 Value 字段 ptr 所指向的实际数据：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置切片的 len 字段，如果类型不是切片，就会panic</span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span></span> SetLen(n <span class="type">int</span>)</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 设置切片的 cap 字段</span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span></span> SetCap(n <span class="type">int</span>)</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 设置字典的 kv</span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span></span> SetMapIndex(key, val Value)</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 返回切片、字符串、数组的索引 i 处的值</span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span></span> Index(i <span class="type">int</span>) Value</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 根据名称获取结构体的内部字段值</span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span></span> FieldByName(name <span class="type">string</span>) Value</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// ……</span></span><br></pre></td></tr></table></figure>

<p>另外，通过 <code>Type()</code> 方法和 <code>Interface()</code> 方法可以打通 <code>interface</code>、<code>Type</code>、<code>Value</code> 三者。Type() 方法也可以返回变量的类型信息，与 reflect.TypeOf() 函数等价。Interface() 方法可以将 Value 还原成原来的 interface。<img src="/pic/11.png" alt="三者关系"></p>
<h3 id="2-4-Go语言中反射的应用"><a href="#2-4-Go语言中反射的应用" class="headerlink" title="2.4 Go语言中反射的应用"></a>2.4 Go语言中反射的应用</h3><p>Go 语言中反射的应用非常广：IDE 中的代码自动补全功能、对象序列化（encoding&#x2F;json）、fmt 相关函数的实现、ORM（全称是：Object Relational Mapping，对象关系映射）……</p>
<h3 id="2-5-如何比较两个对象完全相同"><a href="#2-5-如何比较两个对象完全相同" class="headerlink" title="2.5 如何比较两个对象完全相同"></a>2.5 如何比较两个对象完全相同</h3><p>Go语言提供了一个函数可以完成此项功能：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DeepEqual</span><span class="params">(x, y <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">bool</span></span><br></pre></td></tr></table></figure>

<p>输入两个interface，输出true 或者 flase 表示输入的两个变量是否是“深度”相等。先明白一点，<strong>如果是不同的类型，即使是底层类型相同，相应的值也相同，那么两者也不是“深度”相等。</strong></p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyInt <span class="type">int</span></span><br><span class="line"><span class="keyword">type</span> YourInt <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	m := MyInt(<span class="number">1</span>)</span><br><span class="line">	y := YourInt(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">	fmt.Println(reflect.DeepEqual(m, y)) <span class="comment">// false</span></span><br><span class="line">    <span class="comment">// m, y 底层都是 int，而且值都是 1，但是两者静态类型不同，前者是 MyInt，后者是 YourInt，因此两者不是“深度”相等。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不同类型下，DeepEqual的比较情形：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>深度相等情形</th>
</tr>
</thead>
<tbody><tr>
<td>Array</td>
<td>相同索引处的元素“深度”相等</td>
</tr>
<tr>
<td>Struct</td>
<td>相应字段，包含导出和不导出，“深度”相等</td>
</tr>
<tr>
<td>Func</td>
<td>只有两者都是 nil 时</td>
</tr>
<tr>
<td>Interface</td>
<td>两者存储的具体值“深度”相等</td>
</tr>
<tr>
<td>Map</td>
<td>1、都为 nil；2、非空、长度相等，指向同一个 map 实体对象，或者相应的 key 指向的 value “深度”相等</td>
</tr>
<tr>
<td>Pointer</td>
<td>1、使用 &#x3D;&#x3D; 比较的结果相等；2、指向的实体“深度”相等</td>
</tr>
<tr>
<td>Slice</td>
<td>1、都为 nil；2、非空、长度相等，首元素指向同一个底层数组的相同元素，即 &amp;x[0] &#x3D;&#x3D; &amp;y[0] 或者 相同索引处的元素“深度”相等</td>
</tr>
<tr>
<td>numbers, bools, strings, and channels</td>
<td>使用 &#x3D;&#x3D; 比较的结果为真</td>
</tr>
</tbody></table>
<p>对于“有环”的类型，比如循环链表，比较两者是否“深度”相等的过程中，需要对已比较的内容作一个标记，一旦发现两个指针之前比较过，立即停止比较，并判定二者是深度相等的。这样做的原因是，及时停止比较，避免陷入无限循环。</p>
<p>来看源码：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DeepEqual</span><span class="params">(x, y <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> x == <span class="literal">nil</span> || y == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> x == y</span><br><span class="line">	&#125;</span><br><span class="line">	v1 := ValueOf(x)</span><br><span class="line">	v2 := ValueOf(y)</span><br><span class="line">	<span class="keyword">if</span> v1.Type() != v2.Type() &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> deepValueEqual(v1, v2, <span class="built_in">make</span>(<span class="keyword">map</span>[visit]<span class="type">bool</span>), <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先查看两者是否有一个是 nil 的情况，这种情况下，只有两者都是 nil，函数才会返回 true</p>
<p>接着，使用反射，获取x，y 的反射对象，并且立即比较两者的类型，根据前面的内容，这里实际上是动态类型，如果类型不同，直接返回 false。</p>
<p>最后，最核心的内容在子函数 <code>deepValueEqual</code> 中。</p>
<p>源码：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// deepValueEqual 函数</span></span><br><span class="line"><span class="comment">// ……</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> Map:</span><br><span class="line">	<span class="keyword">if</span> v1.IsNil() != v2.IsNil() &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> v1.Len() != v2.Len() &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> v1.Pointer() == v2.Pointer() &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> _, k := <span class="keyword">range</span> v1.MapKeys() &#123;</span><br><span class="line">		val1 := v1.MapIndex(k)</span><br><span class="line">		val2 := v2.MapIndex(k)</span><br><span class="line">		<span class="keyword">if</span> !val1.IsValid() || !val2.IsValid() || !deepValueEqual(v1.MapIndex(k), v2.MapIndex(k), visited, depth+<span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	</span><br><span class="line"><span class="comment">// ……</span></span><br></pre></td></tr></table></figure>

<p>代码的核心思路是一个 switch 语句，识别输入参数的不同类型，分别递归调用 deepValueEqual 函数，一直递归到最基本的数据类型，比较 int，string 等可以直接得出 true 或者 false，再一层层地返回，最终得到“深度”相等的比较结果。比较的思路和上面表格中的比较思路一致。<code>visited</code> 是一个 map，记录递归过程中，比较过的“对”：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> visit <span class="keyword">struct</span> &#123;</span><br><span class="line">	a1  unsafe.Pointer</span><br><span class="line">	a2  unsafe.Pointer</span><br><span class="line">	typ Type</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">map</span>[visit]<span class="type">bool</span></span><br></pre></td></tr></table></figure>

<p>比较过程中，一旦发现比较的“对”，已经在 map 里出现过的话（防止循环链表一直循环），直接判定“深度”比较结果的是 <code>true</code>。</p>
<h2 id="3、unsafe"><a href="#3、unsafe" class="headerlink" title="3、unsafe"></a>3、unsafe</h2><h3 id="3-1-Go指针和unsafe-Pointer有什么区别"><a href="#3-1-Go指针和unsafe-Pointer有什么区别" class="headerlink" title="3.1 Go指针和unsafe.Pointer有什么区别"></a>3.1 Go指针和unsafe.Pointer有什么区别</h3><p>Go语言中有指针，但是有许多的限制</p>
<p>1、Go的指针不能进行数学运算</p>
<p>2、不同类型的指针不能相互转换</p>
<p>3、不同类型的指针不能使用&#x3D;&#x3D;或!&#x3D;比较</p>
<p>4、不同类型的指针变量不能相互赋值</p>
<p>unsafe.Pointer在unsafe包：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ArbitraryType <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Pointer *ArbitraryType</span><br></pre></td></tr></table></figure>

<p>从命名来看，<code>Arbitrary</code> 是任意的意思，也就是说 Pointer 可以指向任意类型，实际上它类似于 C 语言里的 <code>void*</code>。</p>
<p>unsafe 包提供了 2 点重要的能力：</p>
<ol>
<li>任何类型的指针和 unsafe.Pointer 可以相互转换。</li>
<li>uintptr 类型和 unsafe.Pointer 可以相互转换。</li>
</ol>
<p>前面说过。go指针不支持数学运算。我们可以将它转换为unintptr，对unintptr类型进行数学运算，在转换为pointer类型。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// uintptr 是一个整数类型，它足够大，可以存储</span></span><br><span class="line"><span class="keyword">type</span> <span class="type">uintptr</span> <span class="type">uintptr</span></span><br></pre></td></tr></table></figure>

<p>有一点需要注意的是unintptr没有指针的语义，意思是 uintptr 所指向的对象会被 gc 无情地回收。而 unsafe.Pointer 有指针语义，可以保护它所指向的对象在“有用”的时候不会被垃圾回收。</p>
<h3 id="3-2-如何利用unsafe获取slice-map的长度"><a href="#3-2-如何利用unsafe获取slice-map的长度" class="headerlink" title="3.2 如何利用unsafe获取slice&amp;map的长度"></a>3.2 如何利用unsafe获取slice&amp;map的长度</h3><p><strong>获取slice长度</strong></p>
<p>slice结构体如下图所示</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtime/slice.go</span></span><br><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">    array unsafe.Pointer <span class="comment">// 元素指针</span></span><br><span class="line">    <span class="built_in">len</span>   <span class="type">int</span> <span class="comment">// 长度 </span></span><br><span class="line">    <span class="built_in">cap</span>   <span class="type">int</span> <span class="comment">// 容量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用 make 函数新建一个 slice，底层调用的是 makeslice 函数，返回的是 slice 结构体：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeslice</span><span class="params">(et *_type, <span class="built_in">len</span>, <span class="built_in">cap</span> <span class="type">int</span>)</span></span> slice</span><br></pre></td></tr></table></figure>

<p>因此我们可以通过 unsafe.Pointer 和 uintptr 进行转换，得到 slice 的字段值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">9</span>, <span class="number">20</span>)</span><br><span class="line">	<span class="keyword">var</span> Len = *(*<span class="type">int</span>)(unsafe.Pointer(<span class="type">uintptr</span>(unsafe.Pointer(&amp;s)) + <span class="type">uintptr</span>(<span class="number">8</span>)))</span><br><span class="line">	fmt.Println(Len, <span class="built_in">len</span>(s)) <span class="comment">// 9 9</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> Cap = *(*<span class="type">int</span>)(unsafe.Pointer(<span class="type">uintptr</span>(unsafe.Pointer(&amp;s)) + <span class="type">uintptr</span>(<span class="number">16</span>)))</span><br><span class="line">	fmt.Println(Cap, <span class="built_in">cap</span>(s)) <span class="comment">// 20 20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Len，cap 的转换流程如下：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Len: &amp;s =&gt; pointer =&gt; <span class="type">uintptr</span> =&gt; pointer =&gt; *<span class="type">int</span> =&gt; <span class="type">int</span></span><br><span class="line">Cap: &amp;s =&gt; pointer =&gt; <span class="type">uintptr</span> =&gt; pointer =&gt; *<span class="type">int</span> =&gt; <span class="type">int</span></span><br></pre></td></tr></table></figure>

<p><strong>获取map长度</strong></p>
<p>map底层数据结构</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hmap <span class="keyword">struct</span> &#123;</span><br><span class="line">	count     <span class="type">int</span></span><br><span class="line">	flags     <span class="type">uint8</span></span><br><span class="line">	B         <span class="type">uint8</span></span><br><span class="line">	noverflow <span class="type">uint16</span></span><br><span class="line">	hash0     <span class="type">uint32</span></span><br><span class="line"></span><br><span class="line">	buckets    unsafe.Pointer</span><br><span class="line">	oldbuckets unsafe.Pointer</span><br><span class="line">	nevacuate  <span class="type">uintptr</span></span><br><span class="line"></span><br><span class="line">	extra *mapextra</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和 slice 不同的是，makemap 函数返回的是 hmap 的指针，注意是指针：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makemap</span><span class="params">(t *maptype, hint <span class="type">int64</span>, h *hmap, bucket unsafe.Pointer)</span></span> *hmap</span><br></pre></td></tr></table></figure>

<p>我们依然能通过 unsafe.Pointer 和 uintptr 进行转换，得到 hamp 字段的值，只不过，现在 count 变成二级指针了：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	mp := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">	mp[<span class="string">&quot;qcrao&quot;</span>] = <span class="number">100</span></span><br><span class="line">	mp[<span class="string">&quot;stefno&quot;</span>] = <span class="number">18</span></span><br><span class="line"></span><br><span class="line">	count := **(**<span class="type">int</span>)(unsafe.Pointer(&amp;mp))</span><br><span class="line">	fmt.Println(count, <span class="built_in">len</span>(mp)) <span class="comment">// 2 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>count 的转换过程：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp;mp =&gt; pointer =&gt; **<span class="type">int</span> =&gt; <span class="type">int</span></span><br></pre></td></tr></table></figure>

<h3 id="3-3-如何利用unsafe包修改私有成员"><a href="#3-3-如何利用unsafe包修改私有成员" class="headerlink" title="3.3 如何利用unsafe包修改私有成员"></a>3.3 如何利用unsafe包修改私有成员</h3><p>对于一个结构体，通过 offset 函数可以获取结构体成员的偏移量，进而获取成员的地址，读写该地址的内存，就可以达到改变成员值的目的。</p>
<p>这里有一个内存分配相关的事实：结构体会被分配一块连续的内存，结构体的地址也代表了第一个成员的地址。</p>
<p>我们来看一个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Programmer <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="type">string</span></span><br><span class="line">	language <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	p := Programmer&#123;<span class="string">&quot;stefno&quot;</span>, <span class="string">&quot;go&quot;</span>&#125;</span><br><span class="line">	fmt.Println(p)</span><br><span class="line">	</span><br><span class="line">	name := (*<span class="type">string</span>)(unsafe.Pointer(&amp;p))</span><br><span class="line">	*name = <span class="string">&quot;qcrao&quot;</span></span><br><span class="line"></span><br><span class="line">	lang := (*<span class="type">string</span>)(unsafe.Pointer(<span class="type">uintptr</span>(unsafe.Pointer(&amp;p)) + unsafe.Offsetof(p.language)))</span><br><span class="line">	*lang = <span class="string">&quot;Golang&quot;</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码输出</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;stefno <span class="keyword">go</span>&#125;</span><br><span class="line">&#123;qcrao Golang&#125;</span><br></pre></td></tr></table></figure>

<p>我把 Programmer 结构体升级，多加一个字段：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Programmer <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="type">string</span></span><br><span class="line">	age <span class="type">int</span></span><br><span class="line">	language <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并且放在其他包，这样在 main 函数中，它的三个字段都是私有成员变量，不能直接修改。但我通过 unsafe.Sizeof() 函数可以获取成员大小，进而计算出成员的地址，直接修改内存</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	p := Programmer&#123;<span class="string">&quot;stefno&quot;</span>, <span class="number">18</span>, <span class="string">&quot;go&quot;</span>&#125;</span><br><span class="line">	fmt.Println(p)</span><br><span class="line"></span><br><span class="line">	lang := (*<span class="type">string</span>)(unsafe.Pointer(<span class="type">uintptr</span>(unsafe.Pointer(&amp;p)) + unsafe.Sizeof(<span class="type">int</span>(<span class="number">0</span>)) + unsafe.Sizeof(<span class="type">string</span>(<span class="string">&quot;&quot;</span>))))</span><br><span class="line">	*lang = <span class="string">&quot;Golang&quot;</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;stefno 18 go&#125;</span><br><span class="line">&#123;stefno 18 Golang&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-4-如何实现字符串和byte切片的零拷贝转换"><a href="#3-4-如何实现字符串和byte切片的零拷贝转换" class="headerlink" title="3.4 如何实现字符串和byte切片的零拷贝转换"></a>3.4 如何实现字符串和byte切片的零拷贝转换</h3><p>这是一个非常精典的例子。实现字符串和 bytes 切片之间的转换，要求是 <code>zero-copy</code>。想一下，一般的做法，都需要遍历字符串或 bytes 切片，再挨个赋值。</p>
<p>完成这个任务，我们需要了解 slice 和 string 的底层数据结构：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> StringHeader <span class="keyword">struct</span> &#123;</span><br><span class="line">	Data <span class="type">uintptr</span></span><br><span class="line">	Len  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> SliceHeader <span class="keyword">struct</span> &#123;</span><br><span class="line">	Data <span class="type">uintptr</span></span><br><span class="line">	Len  <span class="type">int</span></span><br><span class="line">	Cap  <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面是反射包下的结构体，路径：src&#x2F;reflect&#x2F;value.go。只需要共享底层 Data 和 Len 就可以实现 <code>zero-copy</code>。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">string2bytes</span><span class="params">(s <span class="type">string</span>)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> *(*[]<span class="type">byte</span>)(unsafe.Pointer(&amp;s))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bytes2string</span><span class="params">(b []<span class="type">byte</span>)</span></span> <span class="type">string</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> *(*<span class="type">string</span>)(unsafe.Pointer(&amp;b))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原理上是利用指针的强转，代码比较简单，不作详细解释。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/11/05/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87-%E6%A0%87%E5%87%86%E5%BA%93/" data-id="clokz5ncg000azotr99yvccx7" data-title="面试准备-标准库" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2023/11/05/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87-%E7%BC%96%E8%AF%91/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          面试准备-编译
        
      </div>
    </a>
  
  
    <a href="/2023/11/05/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87-%E9%80%9A%E9%81%93/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">面试准备-通道</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Go%E5%AD%A6%E4%B9%A0/">Go学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Go%E9%9D%A2%E8%AF%95/">Go面试</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B8%B8%E8%A7%81Go%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%9D%E8%80%83/">常见Go面试题思考</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/11/">November 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/11/05/go%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/">单元测试</a>
          </li>
        
          <li>
            <a href="/2023/11/05/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2023/11/05/Etcd%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/">Etcd服务发现与注册、自定义负载均衡</a>
          </li>
        
          <li>
            <a href="/2023/11/05/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87-Go%E6%8E%A5%E5%8F%A3/">面试准备-Go接口</a>
          </li>
        
          <li>
            <a href="/2023/11/05/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B0/">多线程实现交替打印</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>