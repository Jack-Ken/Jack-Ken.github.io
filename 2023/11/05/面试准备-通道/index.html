<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>面试准备-通道 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="面试准备-通道1、什么是CSP（Communicating Sequential Processes）CSP是一种发编程模型，它是一种用于描述并发系统中独立进程之间通信和同步的形式化模型。它描述了两个独立的并发实体通过共享的通讯 channel(管道)实现并发的并发模型。Go是第一个将CSP思想引入并融入到语言的核心里。相较于java，python等通过共享内存的同步访问等实现并发编程，Go 的并">
<meta property="og:type" content="article">
<meta property="og:title" content="面试准备-通道">
<meta property="og:url" content="http://example.com/2023/11/05/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87-%E9%80%9A%E9%81%93/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="面试准备-通道1、什么是CSP（Communicating Sequential Processes）CSP是一种发编程模型，它是一种用于描述并发系统中独立进程之间通信和同步的形式化模型。它描述了两个独立的并发实体通过共享的通讯 channel(管道)实现并发的并发模型。Go是第一个将CSP思想引入并融入到语言的核心里。相较于java，python等通过共享内存的同步访问等实现并发编程，Go 的并">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/pic/1.png">
<meta property="og:image" content="http://example.com/pic/2.png">
<meta property="og:image" content="http://example.com/pic/3.jpg">
<meta property="og:image" content="http://example.com/pic/4.png">
<meta property="article:published_time" content="2023-11-05T04:15:30.935Z">
<meta property="article:modified_time" content="2023-07-14T03:01:22.965Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/pic/1.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.0.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-面试准备-通道" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/11/05/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87-%E9%80%9A%E9%81%93/" class="article-date">
  <time class="dt-published" datetime="2023-11-05T04:15:30.935Z" itemprop="datePublished">2023-11-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Go%E9%9D%A2%E8%AF%95/">Go面试</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      面试准备-通道
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="面试准备-通道"><a href="#面试准备-通道" class="headerlink" title="面试准备-通道"></a>面试准备-通道</h1><h2 id="1、什么是CSP（Communicating-Sequential-Processes）"><a href="#1、什么是CSP（Communicating-Sequential-Processes）" class="headerlink" title="1、什么是CSP（Communicating Sequential Processes）"></a>1、什么是CSP（Communicating Sequential Processes）</h2><p><code>CSP</code>是一种发编程模型，它是一种用于描述并发系统中独立进程之间通信和同步的形式化模型。它描述了两个独立的并发实体<strong>通过共享的通讯 channel(管道)实现并发</strong>的并发模型。Go是第一个将CSP思想引入并融入到语言的核心里。相较于java，python等通过共享内存的同步访问等实现并发编程，Go 的并发编程的模型则用 goroutine 和 channel 来替代。</p>
<h2 id="2、channel的底层数据结构"><a href="#2、channel的底层数据结构" class="headerlink" title="2、channel的底层数据结构"></a>2、channel的底层数据结构</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// chan 里元素数量</span></span><br><span class="line">	qcount   <span class="type">uint</span></span><br><span class="line">	<span class="comment">// chan 底层循环数组的长度</span></span><br><span class="line">	dataqsiz <span class="type">uint</span></span><br><span class="line">	<span class="comment">// 指向底层循环数组的指针</span></span><br><span class="line">	<span class="comment">// 只针对有缓冲的 channel</span></span><br><span class="line">	buf      unsafe.Pointer</span><br><span class="line">	<span class="comment">// chan 中元素大小</span></span><br><span class="line">	elemsize <span class="type">uint16</span></span><br><span class="line">	<span class="comment">// chan 是否被关闭的标志</span></span><br><span class="line">	closed   <span class="type">uint32</span></span><br><span class="line">	<span class="comment">// chan 中元素类型</span></span><br><span class="line">	elemtype *_type <span class="comment">// element type</span></span><br><span class="line">	<span class="comment">// 已发送元素在循环数组中的索引</span></span><br><span class="line">	sendx    <span class="type">uint</span>   <span class="comment">// send index</span></span><br><span class="line">	<span class="comment">// 已接收元素在循环数组中的索引</span></span><br><span class="line">	recvx    <span class="type">uint</span>   <span class="comment">// receive index</span></span><br><span class="line">	<span class="comment">// 等待接收的 goroutine 队列</span></span><br><span class="line">	recvq    waitq  <span class="comment">// list of recv waiters</span></span><br><span class="line">	<span class="comment">// 等待发送的 goroutine 队列</span></span><br><span class="line">	sendq    waitq  <span class="comment">// list of send waiters</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 保护 hchan 中所有字段</span></span><br><span class="line">	lock mutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中有几个比较重要的字段：</p>
<p><code>buf</code>：指向底层循环数组，只有缓冲型的channel才有。<strong>一个通道相当于一个先进先出（FIFO）的队列。也就是说，通道中的各个元素值都是严格地按照发送的顺序排列的，先被发送通道的元素值一定会先被接收。</strong></p>
<p><code>sendx</code>,<code>recvx</code>：均指向底层循环数组，表示当前可以发送和接收的元素位置索引值（相对于底层数组）。</p>
<p><code>sendq</code>,<code>recvq</code>：分别表示被阻塞的 goroutine，这些 goroutine 由于尝试读取 channel 或向 channel 发送数据而被阻塞。</p>
<p><code>waitq</code> 是 <code>sudog</code> 的一个双向链表，而 <code>sudog</code> 实际上是对 goroutine 的一个封装：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> waitq <span class="keyword">struct</span> &#123;</span><br><span class="line">	first *sudog</span><br><span class="line">	last  *sudog</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>lock</code> 用来保证每个读 channel 或写 channel 的操作都是原子的。</p>
<p>例如，创建一个容量为 6 的，元素为 int 型的 channel 数据结构如下 ：</p>
<p><img src="/pic/1.png" alt="chan data structure"></p>
<p>创建</p>
<p>我们一般使用make创建一个收发通道</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无缓冲通道</span></span><br><span class="line">ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"><span class="comment">// 有缓冲通道</span></span><br><span class="line">ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<p>编译器在编译的时候，会调用<code>makechan</code>来创建一个通道</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makechan</span><span class="params">(t *chantype, size <span class="type">int64</span>)</span></span> *hchan</span><br></pre></td></tr></table></figure>

<p>从函数原型来看，创建的chan是一个指针，所以我们能在函数直接传递channel，而不是传递channel的指针。</p>
<p>具体来看一下代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> hchanSize = unsafe.Sizeof(hchan&#123;&#125;) + <span class="type">uintptr</span>(-<span class="type">int</span>(unsafe.Sizeof(hchan&#123;&#125;))&amp;(maxAlign<span class="number">-1</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makechan</span><span class="params">(t *chantype, size <span class="type">int64</span>)</span></span> *hchan &#123;</span><br><span class="line">	elem := t.elem</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 省略了检查 channel size，align 的代码</span></span><br><span class="line">	<span class="comment">// ……</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> c *hchan</span><br><span class="line">	<span class="comment">// 如果元素类型不含指针 或者 size 大小为 0（无缓冲类型）</span></span><br><span class="line">	<span class="comment">// 只进行一次内存分配</span></span><br><span class="line">	<span class="keyword">if</span> elem.kind&amp;kindNoPointers != <span class="number">0</span> || size == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// 如果 hchan 结构体中不含指针，GC 就不会扫描 chan 中的元素</span></span><br><span class="line">		<span class="comment">// 只分配 &quot;hchan 结构体大小 + 元素大小*个数&quot; 的内存</span></span><br><span class="line">		c = (*hchan)(mallocgc(hchanSize+<span class="type">uintptr</span>(size)*elem.size, <span class="literal">nil</span>, <span class="literal">true</span>))</span><br><span class="line">		<span class="comment">// 如果是缓冲型 channel 且元素大小不等于 0（大小等于 0的元素类型：struct&#123;&#125;）</span></span><br><span class="line">		<span class="keyword">if</span> size &gt; <span class="number">0</span> &amp;&amp; elem.size != <span class="number">0</span> &#123;</span><br><span class="line">			c.buf = add(unsafe.Pointer(c), hchanSize)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// race detector uses this location for synchronization</span></span><br><span class="line">			<span class="comment">// Also prevents us from pointing beyond the allocation (see issue 9401).</span></span><br><span class="line">			<span class="comment">// 1. 非缓冲型的，buf 没用，直接指向 chan 起始地址处</span></span><br><span class="line">			<span class="comment">// 2. 缓冲型的，能进入到这里，说明元素无指针且元素类型为 struct&#123;&#125;，也无影响</span></span><br><span class="line">			<span class="comment">// 因为只会用到接收和发送游标，不会真正拷贝东西到 c.buf 处（这会覆盖 chan的内容）</span></span><br><span class="line">			c.buf = unsafe.Pointer(c)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 进行两次内存分配操作</span></span><br><span class="line">		c = <span class="built_in">new</span>(hchan)</span><br><span class="line">		c.buf = newarray(elem, <span class="type">int</span>(size))</span><br><span class="line">	&#125;</span><br><span class="line">	c.elemsize = <span class="type">uint16</span>(elem.size)</span><br><span class="line">	c.elemtype = elem</span><br><span class="line">	<span class="comment">// 循环数组长度</span></span><br><span class="line">	c.dataqsiz = <span class="type">uint</span>(size)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 返回 hchan 指针</span></span><br><span class="line">	<span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>新建一个 chan 后，内存在堆上分配</strong>，大概长这样：</p>
<p><img src="/pic/2.png" alt="make chan"></p>
<h2 id="3、有缓冲和无缓冲通道"><a href="#3、有缓冲和无缓冲通道" class="headerlink" title="3、有缓冲和无缓冲通道"></a>3、有缓冲和无缓冲通道</h2><p>无缓冲通道（Unbuffered Channel）：</p>
<ul>
<li>无缓冲通道没有内部存储空间，每次发送操作都要等待对应的接收操作，每次接收操作都要等待对应的发送操作。</li>
<li>发送操作和接收操作是同步的，发送和接收两个goroutine会彼此阻塞，直到另一个goroutine准备好进行匹配的操作。</li>
<li>无缓冲通道用于强制进行同步，确保数据在发送和接收之间进行直接传递。</li>
<li>通过 <code>&lt;-</code> 操作符进行发送和接收操作时，会引发发送和接收操作的阻塞，直到另一个goroutine准备好进行匹配的操作。</li>
</ul>
<p>缓冲通道（Buffered Channel）：</p>
<ul>
<li>缓冲通道具有内部存储空间，可以在通道中存储一定数量的元素。</li>
<li>发送操作在通道未满时可以立即完成，而接收操作在通道非空时可以立即完成。</li>
<li>缓冲通道允许发送操作和接收操作以异步方式进行，发送和接收两个goroutine不会彼此直接阻塞等待。</li>
<li>通过使用带有缓冲区大小的 <code>make</code> 函数来创建缓冲通道，如 <code>ch := make(chan int, bufferSize)</code>。</li>
</ul>
<p>缓冲相关的五个属性：</p>
<ul>
<li><code>qcount</code> 当前缓冲中元素个数</li>
<li><code>dataqsize</code> 缓冲最大数量</li>
<li><code>buf</code> 指向缓冲区内存，这块内存空间可容纳<code>dataqsize</code>个元素</li>
<li><code>sendx</code> 缓冲区中下一个元素写入时的位置</li>
<li><code>recvx</code> 缓冲区中下一个被读取的元素的位置</li>
</ul>
<p><img src="/pic/3.jpg" alt="img"></p>
<p>其中通过sendx，recvx可以实现类似于<strong>环形队列</strong>的机制。这样就保证了保证缓冲区有序，并且不需要在每次取出元素时对缓冲区重新排序。</p>
<h2 id="4、通道的阻塞和非阻塞模式"><a href="#4、通道的阻塞和非阻塞模式" class="headerlink" title="4、通道的阻塞和非阻塞模式"></a>4、通道的阻塞和非阻塞模式</h2><p>在Go语言中，通道可以以阻塞或非阻塞的方式进行操作，这两种模式决定了在通道上发送和接收数据的行为。</p>
<p>1、阻塞模式</p>
<ul>
<li>发送数据：如果通道已满（缓冲区已满），发送操作将被阻塞，直到有空间可用为止。</li>
<li>接收数据：如果通道为空（缓冲区为空），接收操作将被阻塞，直到有数据可用为止。</li>
</ul>
<p>2、非阻塞模式</p>
<ul>
<li><p>发送数据：如果通道已满（缓冲区已满），发送操作将立即返回一个错误（通常是<code>false</code>）。</p>
</li>
<li><p>接收数据：如果通道为空（缓冲区为空），接收操作将立即返回一个错误（通常是<code>false</code>）。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">1</span>) <span class="comment">// 创建一个带有一个缓冲区的通道</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非阻塞发送</span></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> ch &lt;- <span class="number">42</span>: <span class="comment">// 发送数据到通道</span></span><br><span class="line">        fmt.Println(<span class="string">&quot;数据已发送&quot;</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;通道已满，发送失败&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非阻塞接收</span></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> value := &lt;-ch: <span class="comment">// 从通道接收数据</span></span><br><span class="line">        fmt.Println(<span class="string">&quot;接收到数据：&quot;</span>, value)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;通道为空，接收失败&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 延时一段时间以便观察输出</span></span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="5、向channel发送数据"><a href="#5、向channel发送数据" class="headerlink" title="5、向channel发送数据"></a>5、向channel发送数据</h2><p>要了解向<code>c *hchan</code>中发送数据时需要的一些字段</p>
<p>​	c.qcount	通道缓存中的元素个数，无缓冲通道一直为0 </p>
<p>​	c.datasiz	通道底层数组中可存储的元素个数</p>
<p>​	c.closed	通道状态标志，&#x3D;0表示为关闭，&#x3D;1表示关闭</p>
<p>​	c.sendx	下一个要发送进来的元素在循环数组中的下标位置</p>
<p>​	c.recvx	下一个要被接受者接收的元素在循环数组中的下标位置</p>
<p>​	c.recvq	等待接收消息的协程队列</p>
<p>​	c.sendq	等到发送消息的协程队列</p>
<p>一些状态</p>
<p>c.qcount&lt;c.datasiz: 只在缓冲型通道中出现，说明缓冲空间没可用。</p>
<p>c.recvq.first &#x3D;&#x3D; nil: 等待队列中有协程，缓存空间为空</p>
<p>c.sendq.first &#x3D;&#x3D; nil: 发送队列中有协程，缓存空间满</p>
<p><strong>不阻塞的发送</strong>：向chan中发送元素时，无需向chan中的buf中拷贝元素值，而是将消息直接拷贝到接收协程的工作栈中，这有两种情况</p>
<ul>
<li><p>a、cahnnel是非缓冲型的，这里会检测recvq中是否有等待接收的协程，如果有，直接将数据拷贝到等待协程中，没有的话就挂起发送协程</p>
</li>
<li><p>b、channel是缓冲型的：这里如果检测到缓冲空间已经存满元素就直接挂起发送协程，如果检测到recvq中有等待的接收协程，说明通道缓存中没有元素，这时候就可以直接将元素拷贝到等待携程中去。</p>
</li>
</ul>
<p>这种不向缓冲区中写元素，而是直接将元素发送到指定协程的栈空间中的做法的好处是可以减少一次加锁和内存拷贝的次数，性能更高。</p>
<p><strong>阻塞发送：</strong></p>
<ul>
<li><p>如果 <code>c.qcount &lt; c.dataqsiz</code>，说明缓冲区可用（肯定是缓冲型的 channel）。先通过函数取出待发送元素应该去到的位置：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">qp := chanbuf(c, c.sendx)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回循环队列里第 i 个元素的地址处</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanbuf</span><span class="params">(c *hchan, i <span class="type">uint</span>)</span></span> unsafe.Pointer &#123;</span><br><span class="line">	<span class="keyword">return</span> add(c.buf, <span class="type">uintptr</span>(i)*<span class="type">uintptr</span>(c.elemsize))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果没有命中以上条件的，说明 channel 已经满了。不管这个 channel 是缓冲型的还是非缓冲型的，都要将这个 sender “关起来”（goroutine 被阻塞）。如果 block 为 false，直接解锁，返回 false。</p>
</li>
</ul>
<p><strong>拓展</strong></p>
<p>当有多个goroutine等待一个通道的时候如果没有使用同步机制对协程的调用顺序进行控制的话，无法确哪个goroutine将首先接收到数据。这是由Go调度器决定的，它在运行时负责调度goroutine的执行。</p>
<h2 id="6、从channel接收数据"><a href="#6、从channel接收数据" class="headerlink" title="6、从channel接收数据"></a>6、从channel接收数据</h2><p>接收操作有两种写法，一种带“OK”，反应channel是够关闭，一种不带 “ok”</p>
<p>经过编译器的处理后，这两种写法最后对应源码里的这两个函数：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// entry points for &lt;- c from compiled code</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanrecv1</span><span class="params">(c *hchan, elem unsafe.Pointer)</span></span> &#123;</span><br><span class="line">	chanrecv(c, elem, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanrecv2</span><span class="params">(c *hchan, elem unsafe.Pointer)</span></span> (received <span class="type">bool</span>) &#123;</span><br><span class="line">	_, received = chanrecv(c, elem, <span class="literal">true</span>)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两个函数都指向chanrecv函数：</p>
<p>chanrecv接收三个参数：c：表示绑定的通道； ep：接收元素的写入地址； block：表示接收是以阻塞模式进行还是以非阻塞的方式进行。</p>
<ul>
<li><p>如果channel是一个空值（nil），在非阻塞模式下，会直接返回。在阻塞模式下，会调用gopark函数挂起，而且永远不会被唤醒。因为关闭一个nil的cahnnel会直接引发panic</p>
</li>
<li><p>和发送函数一样，接下来搞了一个在非阻塞模式下，不用获取锁，快速检测到失败并且返回的操作。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在非阻塞模式下，快速检测到失败，不用获取锁，快速返回 (false, false)</span></span><br><span class="line"><span class="keyword">if</span> !block &amp;&amp; (c.dataqsiz == <span class="number">0</span> &amp;&amp; c.sendq.first == <span class="literal">nil</span> ||</span><br><span class="line">	c.dataqsiz &gt; <span class="number">0</span> &amp;&amp; atomic.Loaduint(&amp;c.qcount) == <span class="number">0</span>) &amp;&amp;</span><br><span class="line">	atomic.Load(&amp;c.closed) == <span class="number">0</span> &#123;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们观察到 channel 没准备好接收：</p>
<ol>
<li>非缓冲型，等待发送列队里没有 goroutine 在等待</li>
<li>缓冲型，但 buf 里没有元素</li>
</ol>
<p>之后，又观察到 closed &#x3D;&#x3D; 0，即 channel 未关闭。此时并没由被选中，而且也没有取到数据，最后的返回值是 (false, false)。</p>
</li>
</ul>
<h2 id="7、关闭cahnnel"><a href="#7、关闭cahnnel" class="headerlink" title="7、关闭cahnnel"></a>7、关闭cahnnel</h2><p>close 逻辑比较简单，对于一个 channel，recvq 和 sendq 中分别保存了阻塞的发送者和接收者。<strong>关闭 channel 后，对于等待接收者而言，会收到一个相应类型的零值</strong>。对于等待发送者，会直接 panic。所以，在不了解 channel 还有没有接收者的情况下，不能贸然关闭 channel。</p>
<p>close 函数先上一把大锁，接着把所有挂在这个 channel 上的 sender 和 receiver 全都连成一个 sudog 链表，再解锁。最后，再将所有的 sudog 全都唤醒。</p>
<p>唤醒之后，该干嘛干嘛。sender 会继续执行 chansend 函数里 goparkunlock 函数之后的代码，很不幸，检测到 channel 已经关闭了，panic。receiver 则比较幸运，进行一些扫尾工作后，返回。这里，selected 返回 true，而返回值 received 则要根据 channel 是否关闭，返回不同的值。如果 channel 关闭，received 为 false，否则为 true。这我们分析的这种情况下，received 返回 false。</p>
<h2 id="8、从一个关闭的channel仍然能读取出数据吗？"><a href="#8、从一个关闭的channel仍然能读取出数据吗？" class="headerlink" title="8、从一个关闭的channel仍然能读取出数据吗？"></a>8、从一个关闭的channel仍然能读取出数据吗？</h2><p>从一个有缓冲的 channel 里读数据，当 channel 被关闭，依然能读出有效值。只有当返回的 ok 为 false 时，读出的数据才是无效的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">5</span>)</span><br><span class="line">	ch &lt;- <span class="number">18</span></span><br><span class="line">	<span class="built_in">close</span>(ch)</span><br><span class="line">	x, ok := &lt;-ch</span><br><span class="line">	<span class="keyword">if</span> ok &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;received: &quot;</span>, x)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	x, ok = &lt;-ch</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;channel closed, data invalid.&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">received:  18</span><br><span class="line">channel closed, data invalid.</span><br></pre></td></tr></table></figure>

<p>先创建了一个有缓冲的 channel，向其发送一个元素，然后关闭此 channel。之后两次尝试从 channel 中读取数据，第一次仍然能正常读出值。第二次返回的 ok 为 false，说明 channel 已关闭，且通道里没有数据。</p>
<h2 id="9、操作channel的情况总结"><a href="#9、操作channel的情况总结" class="headerlink" title="9、操作channel的情况总结"></a>9、操作channel的情况总结</h2><table>
<thead>
<tr>
<th>操作</th>
<th>nil channel</th>
<th>closed channel</th>
<th>not nil, not closed channel</th>
</tr>
</thead>
<tbody><tr>
<td>close</td>
<td>panic</td>
<td>panic</td>
<td>正常关闭</td>
</tr>
<tr>
<td>读 &lt;- ch</td>
<td>阻塞</td>
<td>读到对应类型的零值</td>
<td>阻塞或正常读取数据。缓冲型 channel 为空或非缓冲型 channel 没有等待发送者时会阻塞</td>
</tr>
<tr>
<td>写 ch &lt;-</td>
<td>阻塞</td>
<td>panic</td>
<td>阻塞或正常写入数据。非缓冲型 channel 没有等待接收者或缓冲型 channel buf 满时会被阻塞</td>
</tr>
</tbody></table>
<p>总结一下，发生 panic 的情况有三种：向一个关闭的 channel 进行写操作；关闭一个 nil 的 channel；重复关闭一个 channel。</p>
<p>读、写一个 nil channel 都会被阻塞</p>
<h2 id="10、优雅的关闭channel"><a href="#10、优雅的关闭channel" class="headerlink" title="10、优雅的关闭channel"></a>10、优雅的关闭channel</h2><p>关于 channel 的使用，有几点不方便的地方：</p>
<ol>
<li>在不改变 channel 自身状态的情况下，无法获知一个 channel 是否关闭。</li>
<li>关闭一个 closed channel 会导致 panic。所以，如果关闭 channel 的一方在不知道 channel 是否处于关闭状态时就去贸然关闭 channel 是很危险的事情。</li>
<li>向一个 closed channel 发送数据会导致 panic。所以，如果向 channel 发送数据的一方不知道 channel 是否处于关闭状态时就去贸然向 channel 发送数据是很危险的事情。</li>
</ol>
<p>一个比较粗糙的检查channel是否关闭的函数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsClosed</span><span class="params">(ch &lt;-<span class="keyword">chan</span> T)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> &lt;-ch:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> T)</span><br><span class="line">	fmt.Println(IsClosed(c)) <span class="comment">// false</span></span><br><span class="line">	<span class="built_in">close</span>(c)</span><br><span class="line">	fmt.Println(IsClosed(c)) <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数其实有很多的问题。首先是每调用一次IsClosed函数都会读出channel中的一个元素，改变了channel的状态。</p>
<p>其次IsClosed函数每次返回的结果仅表示调用的那个瞬间，并不能表示调用之后会不会有其他的goroutine对他进行了操作，改变了它的状态。</p>
<p>有一条流传比较广泛的channel原则：<strong>不要从一个receiver 侧关闭 channel，也不要在有多个 sender 时，关闭 channel。</strong></p>
<p>有两个不那么优雅的关闭channel的方法：</p>
<ol>
<li><p>使用 defer-recover 机制，放心大胆地关闭 channel 或者向 channel 发送数据。即使发生了 panic，有 defer-recover 在兜底。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SafeCloseChannel</span><span class="params">(ch <span class="keyword">chan</span> <span class="type">int</span>)</span></span> (justClosed <span class="type">bool</span>) &#123;</span><br><span class="line"> <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">recover</span>() != <span class="literal">nil</span> &#123;</span><br><span class="line">   justClosed = <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line"> &#125;()</span><br><span class="line"></span><br><span class="line"> <span class="built_in">close</span>(ch)</span><br><span class="line"> <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>使用 sync.Once 来保证只关闭一次。</p>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyChannel <span class="keyword">struct</span>&#123;</span><br><span class="line">   C <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">   once sync.Once</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewMyChannel</span><span class="params">()</span></span> *MyChannel&#123;</span><br><span class="line">   <span class="keyword">return</span> &amp;MyChannel&#123;C:<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mc *MyChannel)</span></span> SafeClose()&#123;</span><br><span class="line">   mc.once.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="built_in">close</span>(mc.C)</span><br><span class="line">   &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>那么如何来优雅的关闭通道呢？我们先总结一下sender 和 receiver 的个数有几种情况：</p>
<ol>
<li>一个 sender，一个 receiver</li>
<li>一个 sender， M 个 receiver</li>
<li>N 个 sender，一个 reciver</li>
<li>N 个 sender， M 个 receiver</li>
</ol>
<p>对于第1, 2中情况，不必多说，直接在sender中关闭就好了。</p>
<p>第3中情况下，我们的解决方案是增加一个传递关闭信号的channel，receiver通过信号channel下达关闭数据channel指令。senders监听到关闭信号后，停止发送数据。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	rand.Seed(time.Now().UnixNano())</span><br><span class="line">	<span class="keyword">const</span> Max = <span class="number">100000</span></span><br><span class="line">	<span class="keyword">const</span> NumSenders = <span class="number">1000</span></span><br><span class="line">	dataCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">100</span>)</span><br><span class="line">	stopCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; NumSenders; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">for</span> &#123;</span><br><span class="line">				<span class="keyword">select</span> &#123;</span><br><span class="line">				<span class="keyword">case</span> &lt;-stopCh:</span><br><span class="line">					<span class="keyword">return</span></span><br><span class="line">				<span class="keyword">case</span> dataCh &lt;- rand.Intn(Max):</span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> value := <span class="keyword">range</span> dataCh &#123;</span><br><span class="line">			<span class="keyword">if</span> value == Max<span class="number">-1</span> &#123;</span><br><span class="line">				fmt.Println(<span class="string">&quot;send stop signal to senders&quot;</span>)</span><br><span class="line">                <span class="comment">// 当我们关闭一个cahnnel的时候，所有的receiver会受到对应类型的零值。</span></span><br><span class="line">                <span class="comment">// 这时候select分支case &lt;-stopCh被选中，退出函数，不再发送数据。</span></span><br><span class="line">				<span class="built_in">close</span>(stopCh)</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">			fmt.Println(value)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> &lt;-time.After(time.Hour):</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第四种情况下，这里有 M 个 receiver，如果直接还是采取第 3 种解决方案，由 receiver 直接关闭 stopCh 的话，就会重复关闭一个 channel，导致 panic。因此需要增加一个中间人goroutine，M 个 receiver 都向它发送关闭 stopCh 的“请求”，中间人收到第一个请求后，就会直接下达关闭 stopCh 的指令（通过关闭 stopCh，这时就不会发生重复关闭的情况，因为 stopCh 的发送方只有中间人一个）。另外，这里的 N 个 sender 也可以向中间人发送关闭 stopCh 的请求。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	rand.Seed(time.Now().UnixNano())</span><br><span class="line">	<span class="keyword">const</span> Max = <span class="number">100000</span></span><br><span class="line">	<span class="keyword">const</span> NumSenders = <span class="number">1000</span></span><br><span class="line">	<span class="keyword">const</span> NumReceiver = <span class="number">10</span></span><br><span class="line">	dataCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">100</span>)</span><br><span class="line">	stopCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	toStop := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// moderator</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		&lt;-toStop</span><br><span class="line">		<span class="built_in">close</span>(stopCh)</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; NumSenders; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(id <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">			<span class="keyword">for</span> &#123;</span><br><span class="line">				value := rand.Intn(Max)</span><br><span class="line">				<span class="keyword">if</span> value == <span class="number">0</span> &#123;</span><br><span class="line">					<span class="keyword">select</span> &#123;</span><br><span class="line">					<span class="keyword">case</span> toStop &lt;- <span class="string">&quot;sender#&quot;</span> + id:</span><br><span class="line">					<span class="keyword">default</span>:</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">return</span></span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">select</span> &#123;</span><br><span class="line">				<span class="keyword">case</span> &lt;-stopCh:</span><br><span class="line">					<span class="keyword">return</span></span><br><span class="line">				<span class="keyword">case</span> dataCh &lt;- value:</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;(strconv.Itoa(i))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; NumReceiver; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(id <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">			<span class="keyword">for</span> &#123;</span><br><span class="line">				<span class="keyword">select</span> &#123;</span><br><span class="line">				<span class="keyword">case</span> &lt;-stopCh:</span><br><span class="line">					<span class="keyword">return</span></span><br><span class="line">				<span class="keyword">case</span> value := &lt;-dataCh:</span><br><span class="line">					<span class="keyword">if</span> value == Max<span class="number">-1</span> &#123;</span><br><span class="line">						<span class="keyword">select</span> &#123;</span><br><span class="line">						<span class="keyword">case</span> toStop &lt;- <span class="string">&quot;receiver#&quot;</span> + id:</span><br><span class="line">						<span class="keyword">default</span>:</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">return</span></span><br><span class="line">					&#125;</span><br><span class="line">					fmt.Println(value)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;(strconv.Itoa(i))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> &lt;-time.After(time.Hour):</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码中的toStop就是中间人的角色，这里将其声明为一个缓冲型的channel。假设 toStop 声明的是一个非缓冲型的 channel，那么第一个发送的关闭 stopCh 请求可能会丢失。因为无论是 sender 还是 receiver 都是通过 select 语句来发送请求，如果中间人所在的 goroutine 没有准备好，那 select 语句就不会选中，直接走 default 选项，什么也不做。这样，第一个关闭 stopCh 的请求就会丢失。</p>
<h2 id="11、Channel-发送和接收元素的本质是什么？"><a href="#11、Channel-发送和接收元素的本质是什么？" class="headerlink" title="11、Channel 发送和接收元素的本质是什么？"></a>11、Channel 发送和接收元素的本质是什么？</h2><p> channel 的发送和接收操作本质上都是 “值的拷贝”，无论是从 sender goroutine 的栈到 chan buf，还是从 chan buf 到 receiver goroutine，或者是直接从 sender goroutine 到 receiver goroutine。</p>
<p>举个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="type">string</span></span><br><span class="line">	age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> u = user&#123;name: <span class="string">&quot;Ankur&quot;</span>, age: <span class="number">25</span>&#125;</span><br><span class="line"><span class="keyword">var</span> g = &amp;u</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modifyUser</span><span class="params">(pu *user)</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;modifyUser Received Vaule&quot;</span>, pu)</span><br><span class="line">	pu.name = <span class="string">&quot;Anand&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printUser</span><span class="params">(u &lt;-<span class="keyword">chan</span> *user)</span></span> &#123;</span><br><span class="line">	time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">	fmt.Println(<span class="string">&quot;printUser goRoutine called&quot;</span>, &lt;-u)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> *user, <span class="number">5</span>)</span><br><span class="line">	c &lt;- g</span><br><span class="line">	fmt.Println(g)</span><br><span class="line">	<span class="comment">// modify g</span></span><br><span class="line">	g = &amp;user&#123;name: <span class="string">&quot;Ankur Anand&quot;</span>, age: <span class="number">100</span>&#125;</span><br><span class="line">	<span class="keyword">go</span> printUser(c)</span><br><span class="line">	<span class="keyword">go</span> modifyUser(g)</span><br><span class="line">	time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">	fmt.Println(g)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&amp;&#123;Ankur 25&#125;</span><br><span class="line">modifyUser Received Vaule &amp;&#123;Ankur Anand 100&#125;</span><br><span class="line">printUser goRoutine called &amp;&#123;Ankur 25&#125;</span><br><span class="line">&amp;&#123;Anand 100&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/pic/4.png" alt="output"></p>
<p>一开始构造一个结构体 u，地址是 0x56420，图中地址上方就是它的内容。接着把 <code>&amp;u</code> 赋值给指针 <code>g</code>，g 的地址是 0x565bb0，它的内容就是一个地址，指向 u。</p>
<p>main 程序里，先把 g 发送到 c，根据 <code>copy value</code> 的本质，进入到 chan buf 里的就是 <code>0x56420</code>，它是指针 g 的值（不是它指向的内容），所以打印从 channel 接收到的元素时，它就是 <code>&amp;&#123;Ankur 25&#125;</code>。因此，这里并不是将指针 g “发送” 到了 channel 里，只是拷贝它的值而已。</p>
<h2 id="12、channel会在什么情况下引起资源泄露"><a href="#12、channel会在什么情况下引起资源泄露" class="headerlink" title="12、channel会在什么情况下引起资源泄露"></a>12、channel会在什么情况下引起资源泄露</h2><p>channel可能会引起goroutine的泄露，因为有的goroutine会因为channel处于满或者空的状态一直得不到改变。同时垃圾回收器也不会回收此类资源，进而导致goroutine一直处于被挂起的状态，资源得不到释放。</p>
<h2 id="13-channel有哪些应用"><a href="#13-channel有哪些应用" class="headerlink" title="13 channel有哪些应用"></a>13 channel有哪些应用</h2><p><strong>1、停止信号</strong></p>
<p>这个在“如何优雅地关闭 channel”那一节已经讲得很多了</p>
<p><strong>2、任务定时</strong></p>
<p>与timer结合一般有两种方法：实现超时控制，实现定期执行某个任务。</p>
<p>有时候我们想要执行一个任务，但是又不想它浪费太多时间，上一个定时器就可以搞定</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span>&#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;- time.After(<span class="number">100</span> * time.Millisecond):</span><br><span class="line">    <span class="keyword">case</span> &lt;- s.stopc:</span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>等待 100 ms 后，如果 s.stopc 还没有读出数据或者被关闭，就直接结束。这是来自 etcd 源码里的一个例子，这样的写法随处可见。</p>
<p>定时执行某个任务，也比较简单：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ticker := time.Tick(<span class="number">1</span> * time.Second)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;- ticker:</span><br><span class="line">			<span class="comment">// 执行定时任务</span></span><br><span class="line">			fmt.Println(<span class="string">&quot;执行 1s 定时任务&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    ticker := time.Tick(<span class="number">1</span> * time.Second)</span><br><span class="line">	<span class="comment">// 创建一个信号通道</span></span><br><span class="line">	sigs := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal, <span class="number">1</span>)</span><br><span class="line">	<span class="comment">// 监听 SIGINT 和 SIGTERM 信号</span></span><br><span class="line">	signal.Notify(sigs, syscall.SIGINT, syscall.SIGTERM)</span><br><span class="line">	<span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-ticker:</span><br><span class="line">            <span class="comment">// 执行定时任务</span></span><br><span class="line">			fmt.Println(i)</span><br><span class="line">		<span class="keyword">case</span> &lt;-sigs:</span><br><span class="line">            <span class="comment">// 结束定时任务</span></span><br><span class="line">			fmt.Println(<span class="string">&quot;shutdown!!!&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		i++</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每隔 1 秒种，执行一次定时任务。</p>
<p><strong>3、解耦生产方和消费方</strong></p>
<p>服务启动时，启动 n 个 worker，作为工作协程池，这些协程工作在一个 <code>for &#123;&#125;</code> 无限循环里，从某个 channel 消费工作任务并执行：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(taskCh &lt;-<span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">const</span> N = <span class="number">5</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; N; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(id <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">			<span class="keyword">for</span> &#123;</span><br><span class="line">				task := &lt;-taskCh</span><br><span class="line">				fmt.Println(<span class="string">&quot;finish task: %d by worker %d\n&quot;</span>, task, id)</span><br><span class="line">				time.After(<span class="number">1</span> * time.Second)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 创建一个信号通道</span></span><br><span class="line">	sigs := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal, <span class="number">1</span>)</span><br><span class="line">	<span class="comment">// 监听 SIGINT 和 SIGTERM 信号</span></span><br><span class="line">	signal.Notify(sigs, syscall.SIGINT, syscall.SIGTERM)</span><br><span class="line"></span><br><span class="line">	taskCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">100</span>)</span><br><span class="line">	<span class="keyword">go</span> worker(taskCh)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		taskCh &lt;- i</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> &lt;-time.After(time.Hour):</span><br><span class="line">	<span class="keyword">case</span> &lt;-sigs:</span><br><span class="line">		fmt.Println(<span class="string">&quot;shutdown!!!&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5 个工作协程在不断地从工作队列里取任务，生产方只管往 channel 发送任务即可，解耦生产方和消费方。</p>
<p>输出结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">finish task: %d by worker %d</span><br><span class="line"> 0 4</span><br><span class="line">finish task: %d by worker %d</span><br><span class="line"> 5 4</span><br><span class="line">finish task: %d by worker %d</span><br><span class="line"> 6 4</span><br><span class="line">finish task: %d by worker %d</span><br><span class="line"> 7 4</span><br><span class="line">finish task: %d by worker %d</span><br><span class="line"> 8 4</span><br><span class="line">finish task: %d by worker %d</span><br><span class="line"> 9 4</span><br><span class="line">finish task: %d by worker %d</span><br><span class="line"> 2 0</span><br><span class="line">finish task: %d by worker %d</span><br><span class="line"> 3 2</span><br><span class="line">finish task: %d by worker %d</span><br><span class="line"> 4 3</span><br><span class="line">finish task: %d by worker %d</span><br><span class="line"> 1 1</span><br></pre></td></tr></table></figure>



<p><strong>4、控制并发数</strong></p>
<p>有时需要定时执行几百个任务，例如每天定时按城市来执行一些离线计算的任务。但是并发数又不能太高，因为任务执行过程依赖第三方的一些资源，对请求的速率有限制。这时就可以通过 channel 来控制并发数。</p>
<p>下面是一个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> limit = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// …………</span></span><br><span class="line">    <span class="keyword">for</span> _, w := <span class="keyword">range</span> work &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            limit &lt;- <span class="number">1</span></span><br><span class="line">            w()</span><br><span class="line">            &lt;-limit</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// …………</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构建一个缓冲型的 channel，容量为 3。接着遍历任务列表，每个任务启动一个 goroutine 去完成。真正执行任务，访问第三方的动作在 w() 中完成，在执行 w() 之前，先要从 limit 中拿“许可证”，拿到许可证之后，才能执行 w()，并且在执行完任务，要将“许可证”归还。这样就可以控制同时运行的 goroutine 数。</p>
<p>这里，<code>limit &lt;- 1</code> 放在 func 内部而不是外部，原因是：</p>
<blockquote>
<p>如果在外层，就是控制系统 goroutine 的数量，可能会阻塞 for 循环，影响业务逻辑。</p>
</blockquote>
<blockquote>
<p>limit 其实和逻辑无关，只是性能调优，放在内层和外层的语义不太一样。</p>
</blockquote>
<p>还有一点要注意的是，如果 w() 发生 panic，那“许可证”可能就还不回去了，<strong>因此需要使用 defer 来保证。</strong> </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/11/05/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87-%E9%80%9A%E9%81%93/" data-id="clokz5nch000czotra5yu7y6m" data-title="面试准备-通道" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2023/11/05/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87-%E6%A0%87%E5%87%86%E5%BA%93/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          面试准备-标准库
        
      </div>
    </a>
  
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Go%E5%AD%A6%E4%B9%A0/">Go学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Go%E9%9D%A2%E8%AF%95/">Go面试</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B8%B8%E8%A7%81Go%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%9D%E8%80%83/">常见Go面试题思考</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/11/">November 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/11/05/go%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/">单元测试</a>
          </li>
        
          <li>
            <a href="/2023/11/05/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2023/11/05/Etcd%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/">Etcd服务发现与注册、自定义负载均衡</a>
          </li>
        
          <li>
            <a href="/2023/11/05/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87-Go%E6%8E%A5%E5%8F%A3/">面试准备-Go接口</a>
          </li>
        
          <li>
            <a href="/2023/11/05/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B0/">多线程实现交替打印</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>