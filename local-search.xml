<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Vscod拉取项目报错解决</title>
    <link href="/2023/11/06/Vscode%E6%8B%89%E5%8F%96%E9%A1%B9%E7%9B%AE%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3/"/>
    <url>/2023/11/06/Vscode%E6%8B%89%E5%8F%96%E9%A1%B9%E7%9B%AE%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3/</url>
    
    <content type="html"><![CDATA[<p>今天在使用VScode拉取项目的时候报错，“fatal: unable to access ‘<a href="https://github.com/aceld/zinx.git/">https://github.com/aceld/zinx.git/</a>‘: Recv failure: Connection was reset”，试了网上最常用的方法，</p><ul><li><p>try 1</p><p>该方法也是最常见的方法，那就是在终端执行：</p><div class="code-wrapper"><pre><code class="hljs go">git config --global --unset http.proxy git config --global --unset https.proxy</code></pre></div><p>但是依然没有用</p></li><li><p>try 2</p><p>修改代理配置，完美解决</p><p>开启代理配置</p><p><img src="/pic/20.png" alt="image-20231106221518844"></p><p>然后在终端输入下面的命令</p><div class="code-wrapper"><pre><code class="hljs go">git config --global http.proxy http:<span class="hljs-comment">//127.0.0.1:7890</span></code></pre></div><p>然后就可以正常的使用了</p><p><img src="/pic/21.png" alt="image-20231106221650273"></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>错误解决</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>面试准备-标准库</title>
    <link href="/2023/11/05/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87-%E6%A0%87%E5%87%86%E5%BA%93/"/>
    <url>/2023/11/05/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87-%E6%A0%87%E5%87%86%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h1 id="面试准备-标准库"><a href="#面试准备-标准库" class="headerlink" title="面试准备-标准库"></a>面试准备-标准库</h1><h2 id="1、context"><a href="#1、context" class="headerlink" title="1、context"></a>1、context</h2><h3 id="1-1-context有什么作用"><a href="#1-1-context有什么作用" class="headerlink" title="1.1 context有什么作用"></a>1.1 context有什么作用</h3><p>Go常被用来写后台服务，在Go的sever里，通常每来一个请求就会启动若干个goroutine来同时工作：有些去数据库拿数据，有些去下游接口获取相关数据</p><p><img src="/pic/5.png" alt="request"></p><p>但是这些goroutine会共享一些请求的基本数据，例如登录token，处理请求的最大超时时间等等。当请被取消的时候，所有为这个请求工作的那些协程都要快速退出，因为他们的结果已经不需要了。而请求超时也会防止因等待请求返回导致的协程堆积，造成系统资源的浪费，甚至服务宕机的发生。</p><p>总结来说:<strong>context用来解决在goroutine之间<code>退出通知</code>、<code>元数据传递</code>的功能。</strong></p><p>[引申1] 举例说明 context 在实际项目中如何使用。</p><p>context使用起来十分方便，源码里面提供了一个创建<strong>根节点context</strong>的函数：</p><div class="code-wrapper"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Background</span><span class="hljs-params">()</span></span> Context</code></pre></div><p>这会返回一个空的context，不能被取消，没有值，也没有超时时间。有了根节点context，又提供了四个函数创建子节点context：</p><div class="code-wrapper"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithCancel</span><span class="hljs-params">(parent Context)</span></span> (ctx Context, cancel CancelFunc)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithDeadline</span><span class="hljs-params">(parent Context, deadline time.Time)</span></span> (Context, CancelFunc)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithTimeout</span><span class="hljs-params">(parent Context, timeout time.Duration)</span></span> (Context, CancelFunc)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithValue</span><span class="hljs-params">(parent Context, key, val <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> Context</code></pre></div><p>context会在函数传递间传递只需要在适当的时间调用cancel函数向goroutine发出取消信号或者调用Value函数取出context中的值。</p><p>在官方的博客中对context的使用提出了下面几点建议：</p><ol><li><strong>不要将 Context 塞到结构体里。直接将 Context 类型作为函数的第一参数，而且一般都命名为 ctx。</strong></li><li><strong>不要向函数传入一个 nil 的 context，如果你实在不知道传什么，标准库给你准备好了一个 context：todo。</strong></li><li><strong>不要把本应该作为函数参数的类型塞到 context 中，context 存储的应该是一些共同的数据。例如：登陆的 session、cookie 等。</strong></li><li><strong>同一个 context 可能会被传递到多个 goroutine，别担心，context 是并发安全的。</strong></li></ol><p><strong>传递共享的数据</strong></p><p>对于 Web 服务端开发，往往希望将一个请求处理的整个过程串起来，这就非常依赖于 Thread Local（对于 Go 可理解为单个协程所独有） 的变量，而在 Go 语言中并没有这个概念，因此需要在函数调用的时候传递 context。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;context&quot;</span><span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;ctx := context.Background()process(ctx)ctx = context.WithValue(ctx, <span class="hljs-string">&quot;traceId&quot;</span>, <span class="hljs-string">&quot;qcrao-2019&quot;</span>)process(ctx)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">process</span><span class="hljs-params">(ctx context.Context)</span></span> &#123;traceId, ok := ctx.Value(<span class="hljs-string">&quot;traceId&quot;</span>).(<span class="hljs-type">string</span>)<span class="hljs-keyword">if</span> ok &#123;fmt.Printf(<span class="hljs-string">&quot;process over. trace_id=%s\n&quot;</span>, traceId)&#125; <span class="hljs-keyword">else</span> &#123;fmt.Printf(<span class="hljs-string">&quot;process over. no trace_id\n&quot;</span>)&#125;&#125;</code></pre></div><p>运行结果：</p><div class="code-wrapper"><pre><code class="hljs shell">process over. no trace_idprocess over. trace_id=qcrao-2019</code></pre></div><p>第一次调用 process 函数时，ctx 是一个空的 context，自然取不出来 traceId。第二次，通过 <code>WithValue</code> 函数创建了一个 context，并赋上了 <code>traceId</code> 这个 key，自然就能取出来传入的 value 值。</p><p>当然，现实场景中可能是从一个 HTTP 请求中获取到的 Request-ID。所以，下面这个样例可能更适合：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">const</span> requestIDKey <span class="hljs-type">int</span> = <span class="hljs-number">0</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithRequestID</span><span class="hljs-params">(next http.Handler)</span></span> http.Handler &#123;<span class="hljs-keyword">return</span> http.HandlerFunc(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(rw http.ResponseWriter, req *http.Request)</span></span> &#123;<span class="hljs-comment">// 从 header 中提取 request-id</span>reqID := req.Header.Get(<span class="hljs-string">&quot;X-Request-ID&quot;</span>)<span class="hljs-comment">// 创建 valueCtx。使用自定义的类型，不容易冲突</span>ctx := context.WithValue(req.Context(), requestIDKey, reqID)<span class="hljs-comment">// 创建新的请求</span>req = req.WithContext(ctx)<span class="hljs-comment">// 调用 HTTP 处理函数</span>next.ServeHTTP(rw, req)&#125;)&#125;<span class="hljs-comment">// 获取 request-id</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetRequestID</span><span class="hljs-params">(ctx context.Context)</span></span> <span class="hljs-type">string</span> &#123;ctx.Value(requestIDKey).(<span class="hljs-type">string</span>)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Handle</span><span class="hljs-params">(rw http.ResponseWriter, req *http.Request)</span></span> &#123;<span class="hljs-comment">// 拿到 reqId，后面可以记录日志等等</span>reqID := GetRequestID(req.Context())...&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;handler := WithRequestID(http.HandlerFunc(Handle))http.ListenAndServe(<span class="hljs-string">&quot;/&quot;</span>, handler)&#125;</code></pre></div><p><strong>取消goroutine</strong></p><p>我们先来设想一个场景：打开外卖的订单页，地图上显示外卖小哥的位置，而且是每秒更新 1 次。app 端向后台发起 websocket 连接（现实中可能是轮询）请求后，后台启动一个协程，每隔 1 秒计算 1 次小哥的位置，并发送给端。如果用户退出此页面，则后台需要“取消”此过程，退出 goroutine，系统回收资源。</p><p>后端实现可能如下所示：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Perform</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">for</span> &#123;        calculatePos()        sendResult()        time.Sleep(time.Second)    &#125;&#125;</code></pre></div><p>如果要实现取消功能，不使用context的情况下，肯能会这样做：给函数增加一个指针型的 bool 变量，在 for 语句的开始处判断 bool 变量是发由 true 变为 false，如果改变，则退出循环。</p><p>这么做虽然能够实现功能，但是并不优雅，并且一旦协程数量多了之后，并且各种嵌套，就会很麻烦。所以就要使用context。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Perform</span><span class="hljs-params">(ctx context.Context)</span></span> &#123;    <span class="hljs-keyword">for</span> &#123;        calculatePos()        sendResult()        <span class="hljs-keyword">select</span> &#123;        <span class="hljs-keyword">case</span> &lt;-ctx.Done():            <span class="hljs-comment">// 被取消，直接返回</span>            <span class="hljs-keyword">return</span>        <span class="hljs-keyword">case</span> &lt;-time.After(time.Second):            <span class="hljs-comment">// block 1 秒钟 </span>        &#125;    &#125;&#125;</code></pre></div><p>主要流程可能是这样：</p><div class="code-wrapper"><pre><code class="hljs go">ctx, cancel := context.WithTimeout(context.Background(), time.Hour)<span class="hljs-keyword">go</span> Perform(ctx)<span class="hljs-comment">// ……</span><span class="hljs-comment">// app 端返回页面，调用cancel 函数</span>cancel()</code></pre></div><p>注意一个细节，<strong>WithTimeOut 函数返回的 context 和 cancelFun 是分开的。context 本身并没有取消函数</strong>，这样做的原因是取消函数只能由外层函数调用，防止子节点 context 调用取消函数，从而严格控制信息的流向：<strong>由父节点 context 流向子节点 context。</strong></p><p><strong>防止goroutine泄露</strong></p><p>看一下下面这个例子：</p><div class="code-wrapper"><pre><code class="hljs golang"><span class="hljs-comment">// 这个协程可以生成无限个数的整数</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">gen</span><span class="hljs-params">()</span></span> &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span> &#123;ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> n <span class="hljs-type">int</span><span class="hljs-keyword">for</span> &#123;ch &lt;- nn++time.Sleep(time.Second)&#125;&#125;()<span class="hljs-keyword">return</span> ch&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">for</span> n := <span class="hljs-keyword">range</span> gen() &#123;fmt.Println(n)        <span class="hljs-comment">// 生成5个整数之后，就break，但是gen函数的协程会无线循环的执行，永远不会停下。发生协程泄露</span><span class="hljs-keyword">if</span> n == <span class="hljs-number">5</span> &#123;<span class="hljs-keyword">break</span>&#125;&#125;<span class="hljs-comment">// ……</span>&#125;</code></pre></div><p>使用context改进这个例子：</p><div class="code-wrapper"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">gen</span><span class="hljs-params">(ctx context.Context)</span></span> &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span> &#123;ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> n <span class="hljs-type">int</span><span class="hljs-keyword">for</span> &#123;<span class="hljs-keyword">select</span> &#123;<span class="hljs-keyword">case</span> &lt;-ctx.Done():<span class="hljs-keyword">return</span><span class="hljs-keyword">case</span> ch &lt;- n:n++time.Sleep(time.Second)&#125;&#125;&#125;()<span class="hljs-keyword">return</span> ch&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;ctx, cancel := context.WithCancel(context.Background())<span class="hljs-keyword">defer</span> cancel() <span class="hljs-comment">// 避免其他地方忘记 cancel，且重复调用不影响</span><span class="hljs-keyword">for</span> n := <span class="hljs-keyword">range</span> gen(ctx) &#123;fmt.Println(n)<span class="hljs-keyword">if</span> n == <span class="hljs-number">5</span> &#123;cancel()<span class="hljs-keyword">break</span>&#125;&#125;<span class="hljs-comment">// ……</span>&#125;</code></pre></div><p>增加一个 context，在 break 前调用 cancel 函数，取消 goroutine。gen 函数在接收到取消信号后，直接退出，系统回收资源。</p><h3 id="1-2-context-Value的查找过程是怎样的"><a href="#1-2-context-Value的查找过程是怎样的" class="headerlink" title="1.2 context.Value的查找过程是怎样的"></a>1.2 context.Value的查找过程是怎样的</h3><div class="code-wrapper"><pre><code class="hljs golang"><span class="hljs-keyword">type</span> valueCtx <span class="hljs-keyword">struct</span> &#123;Contextkey, val <span class="hljs-keyword">interface</span>&#123;&#125;&#125;</code></pre></div><p>它实现了两个方法：</p><div class="code-wrapper"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *valueCtx)</span></span> String() <span class="hljs-type">string</span> &#123;<span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;%v.WithValue(%#v, %#v)&quot;</span>, c.Context, c.key, c.val)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *valueCtx)</span></span> Value(key <span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-keyword">interface</span>&#123;&#125; &#123;<span class="hljs-keyword">if</span> c.key == key &#123;<span class="hljs-keyword">return</span> c.val&#125;<span class="hljs-keyword">return</span> c.Context.Value(key)&#125;</code></pre></div><p>由于它直接将 Context 作为匿名字段，因此仅管它只实现了 2 个方法，其他方法继承自父 context。但它仍然是一个 Context，这是 Go 语言的一个特点。</p><p>创建 valueCtx 的函数：</p><div class="code-wrapper"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithValue</span><span class="hljs-params">(parent Context, key, val <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> Context &#123;<span class="hljs-keyword">if</span> key == <span class="hljs-literal">nil</span> &#123;<span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;nil key&quot;</span>)&#125;<span class="hljs-keyword">if</span> !reflect.TypeOf(key).Comparable() &#123;<span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;key is not comparable&quot;</span>)&#125;<span class="hljs-keyword">return</span> &amp;valueCtx&#123;parent, key, val&#125;&#125;</code></pre></div><p>key必须是可比较的，因为之后需要通过key去除context中的值，可比较的是必须的。</p><p>通过层层传递 context，最终形成这样一棵树：</p><p>![&#x2F;pic&#x2F;6.png)</p><p>和链表比较相像，但是所有的context都指向它的父节点，通过 WithValue 函数，可以创建层层的 valueCtx，存储 goroutine 间可以共享的变量。</p><p>而取值的过程，实际上就是一个递归查找的过程：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *valueCtx)</span></span> Value(key <span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-keyword">interface</span>&#123;&#125; &#123;<span class="hljs-keyword">if</span> c.key == key &#123;<span class="hljs-keyword">return</span> c.val&#125;<span class="hljs-keyword">return</span> c.Context.Value(key)&#125;</code></pre></div><p>它会顺着链路一直往上查找，比较当前的key和要查找的key是否一样，是的话据返回value。否则就一直顺着context往前，直到最终找到根节点，直接返回一个nil，所以用Value方法的时候要判断结果是否为nil。</p><p>因为查找方向是往上走得，所以父节点是无法查找子节点存储的值，</p><p><code>WithValue</code> 创建 context 节点的过程实际上就是创建链表节点的过程。两个节点的 key 值是可以相等的，但它们是两个不同的 context 节点。查找的时候，会向上查找到最后一个挂载的 context 节点，也就是离得比较近的一个父节点 context。所以，整体上而言，用 <code>WithValue</code> 构造的其实是一个低效率的链表。</p><p>如果你接手过项目，肯定经历过这样的窘境：在一个处理过程中，有若干子函数、子协程。各种不同的地方会向 context 里塞入各种不同的 k-v 对，最后在某个地方使用。</p><p>你根本就不知道什么时候什么地方传了什么值？这些值会不会被“覆盖”（底层是两个不同的 context 节点，查找的时候，只会返回一个结果）？你肯定会崩溃的。</p><p>而这也是 <code>context.Value</code> 最受争议的地方。很多人建议尽量不要通过 context 传值。</p><h2 id="2、reflect"><a href="#2、reflect" class="headerlink" title="2、reflect"></a>2、reflect</h2><h3 id="2-1-什么是反射"><a href="#2-1-什么是反射" class="headerlink" title="2.1 什么是反射"></a>2.1 什么是反射</h3><p>反射是计算机程序在运行时可以访问、检测、修改它本身状态或者行为的一种能力。用比喻来说，反射就是程序在运行的时候能够观察并修改自己的行为。</p><p>实际上使用汇编语言就可以不使用反射直接在运行时和底层打交道获取任何信息。但是当编程迁移到高级语言上来之后只能通过<code>反射</code>来达到此项技能。</p><p>对于反射，《Go语言圣经》对反射的定义是：<strong>Go 语言提供了一种机制在运行时更新变量和检查它们的值、调用它们的方法，但是在编译时并不知道这些变量的具体类型，这称为反射机制。</strong></p><h3 id="2-2-什么情况下需要反射"><a href="#2-2-什么情况下需要反射" class="headerlink" title="2.2 什么情况下需要反射"></a>2.2 什么情况下需要反射</h3><p>使用反射的常见场景有以下两种：</p><ol><li><strong>不能明确接口调用哪个函数，需要根据传入的参数在运行时决定。</strong></li><li><strong>不能明确传入函数的参数类型，需要在运行时处理任意对象。</strong></li></ol><p>但是我们通常不建议使用反射，理由如下：</p><ol><li>与反射相关的代码，经常是难以阅读的。在软件工程中，代码可读性也是一个非常重要的指标。</li><li>Go 语言作为一门静态语言，编码过程中，编译器能提前发现一些类型错误，但是对于反射代码是无能为力的。所以包含反射相关的代码，很可能会运行很久，才会出错，这时候经常是直接 panic，可能会造成严重的后果。</li><li>反射对性能影响还是比较大的，比正常代码运行速度慢一到两个数量级。所以，对于一个项目中处于运行效率关键位置的代码，尽量避免使用反射特性。</li></ol><h3 id="2-3-Go语言如何实现反射"><a href="#2-3-Go语言如何实现反射" class="headerlink" title="2.3 Go语言如何实现反射"></a>2.3 Go语言如何实现反射</h3><p><strong>types 和 interface</strong></p><p>我们先来回顾一下interface底层的数据结构</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> iface <span class="hljs-keyword">struct</span> &#123;tab  *itabdata unsafe.Pointer&#125;<span class="hljs-keyword">type</span> itab <span class="hljs-keyword">struct</span> &#123;inter  *interfacetype_type  *_typelink   *itabhash   <span class="hljs-type">uint32</span>bad    <span class="hljs-type">bool</span>inhash <span class="hljs-type">bool</span>unused [<span class="hljs-number">2</span>]<span class="hljs-type">byte</span>fun    [<span class="hljs-number">1</span>]<span class="hljs-type">uintptr</span>&#125;<span class="hljs-keyword">type</span> eface <span class="hljs-keyword">struct</span> &#123;    _type *_type    data  unsafe.Pointer&#125;</code></pre></div><p>iface数据结构的图示如下图所示“</p><p><img src="/pic/7.png" alt="iface 结构体全景"></p><p>我们看一下接口之间的各种转换和赋值</p><div class="code-wrapper"><pre><code class="hljs golang"><span class="hljs-comment">// io.Reeader是一个接口</span><span class="hljs-keyword">var</span> r io.Readertty, err := os.OpenFile(<span class="hljs-string">&quot;/Users/qcrao/Desktop/test&quot;</span>, os.O_RDWR, <span class="hljs-number">0</span>)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err&#125;r = tty</code></pre></div><p>首先声明 <code>r</code> 的类型是 <code>io.Reader</code>，注意，这是 <code>r</code> 的静态类型，此时它的动态类型为 <code>nil</code>，并且它的动态值也是 <code>nil</code>。之后，<code>r = tty</code> 这一语句，将 <code>r</code> 的动态类型变成 <code>*os.File</code>，动态值则变成非空，表示打开的文件对象。这时，r 可以用<code>&lt;value, type&gt;</code>对来表示为： <code>&lt;tty, *os.File&gt;</code>。</p><p><img src="/pic/8.png" alt="r=tty"></p><p>注意看上图，此时虽然 <code>fun</code> 所指向的函数只有一个 <code>Read</code> 函数，其实 <code>*os.File</code> 还包含 <code>Write</code> 函数，也就是说 <code>*os.File</code> 其实还实现了 <code>io.Writer</code> 接口。因此下面的断言语句可以执行：</p><div class="code-wrapper"><pre><code class="hljs golang"><span class="hljs-keyword">var</span> w io.Writerw = r.(io.Writer)</code></pre></div><p>之所以用断言，而不能直接赋值，是因为 <code>r</code> 的静态类型是 <code>io.Reader</code>，并没有实现 <code>io.Writer</code> 接口。断言能否成功，看 <code>r</code> 的动态类型是否符合要求。</p><p>这样，w 也可以表示成 <code>&lt;tty, *os.File&gt;</code>，仅管它和 <code>r</code> 一样，但是 w 可调用的函数取决于它的静态类型 <code>io.Writer</code>，也就是说它只能有这样的调用形式： <code>w.Write()</code> 。<code>w</code> 的内存形式如下图：<img src="/pic/9.png" alt="w = r.(io.Writer)"></p><p>和 <code>r</code> 相比，仅仅是 <code>fun</code> 对应的函数变了：<code>Read -&gt; Write</code>。</p><p>最后，再来一个赋值：</p><div class="code-wrapper"><pre><code class="hljs golang"><span class="hljs-keyword">var</span> empty <span class="hljs-keyword">interface</span>&#123;&#125;empty = w</code></pre></div><p>由于 <code>empty</code> 是一个空接口，因此所有的类型都实现了它，w 可以直接赋给它，不需要执行断言操作。</p><p><img src="/pic/10.png" alt="empty=w"></p><p>我们展示一个关于接口的技巧</p><p>先参考源码，分别定义一个<code>“伪装”</code>的 iface 和 eface 结构体。然后将接口变量占据的内存解释成上面定义的类型，在打印出来。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (   <span class="hljs-string">&quot;fmt&quot;</span>   <span class="hljs-string">&quot;io&quot;</span>   <span class="hljs-string">&quot;os&quot;</span>   <span class="hljs-string">&quot;unsafe&quot;</span>)<span class="hljs-keyword">type</span> itab <span class="hljs-keyword">struct</span> &#123;   inter <span class="hljs-type">uintptr</span>   _type <span class="hljs-type">uintptr</span>   link  <span class="hljs-type">uintptr</span>   hash  <span class="hljs-type">uint32</span>   _     [<span class="hljs-number">4</span>]<span class="hljs-type">byte</span>   fun   [<span class="hljs-number">1</span>]<span class="hljs-type">uintptr</span>&#125;<span class="hljs-keyword">type</span> iface <span class="hljs-keyword">struct</span> &#123;   tab  *itab   data unsafe.Pointer&#125;<span class="hljs-keyword">type</span> eface <span class="hljs-keyword">struct</span> &#123;   _type <span class="hljs-type">uintptr</span>   data  unsafe.Pointer&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;   <span class="hljs-keyword">var</span> r io.Reader   fmt.Printf(<span class="hljs-string">&quot;initial r: %T, %v\n&quot;</span>, r, r)   tty, _ := os.OpenFile(<span class="hljs-string">&quot;/Users/qcrao/Desktop/test&quot;</span>, os.O_RDWR, <span class="hljs-number">0</span>)   fmt.Printf(<span class="hljs-string">&quot;tty: %T, %v\n&quot;</span>, tty, tty)   <span class="hljs-comment">// 给 r 赋值</span>   r = tty   fmt.Printf(<span class="hljs-string">&quot;r: %T, %v\n&quot;</span>, r, r)   rIface := (*iface)(unsafe.Pointer(&amp;r))   fmt.Printf(<span class="hljs-string">&quot;r: iface.tab._type = %#x, iface.data = %#x\n&quot;</span>, rIface.tab._type, rIface.data)   <span class="hljs-comment">// 给 w 赋值</span>   <span class="hljs-keyword">var</span> w io.Writer   w = r.(io.Writer)   fmt.Printf(<span class="hljs-string">&quot;w: %T, %v\n&quot;</span>, w, w)   wIface := (*iface)(unsafe.Pointer(&amp;w))   fmt.Printf(<span class="hljs-string">&quot;w: iface.tab._type = %#x, iface.data = %#x\n&quot;</span>, wIface.tab._type, wIface.data)   <span class="hljs-comment">// 给 empty 赋值</span>   <span class="hljs-keyword">var</span> empty <span class="hljs-keyword">interface</span>&#123;&#125;   empty = w   fmt.Printf(<span class="hljs-string">&quot;empty: %T, %v\n&quot;</span>, empty, empty)   emptyEface := (*eface)(unsafe.Pointer(&amp;empty))   fmt.Printf(<span class="hljs-string">&quot;empty: eface._type = %#x, eface.data = %#x\n&quot;</span>, emptyEface._type, emptyEface.data)&#125;</code></pre></div><p>运行结果：</p><div class="code-wrapper"><pre><code class="hljs shell">initial r: &lt;nil&gt;, &lt;nil&gt;tty: *os.File, &amp;&#123;0xc4200820f0&#125;r: *os.File, &amp;&#123;0xc4200820f0&#125;r: iface.tab._type = 0x10bfcc0, iface.data = 0xc420080020w: *os.File, &amp;&#123;0xc4200820f0&#125;w: iface.tab._type = 0x10bfcc0, iface.data = 0xc420080020empty: *os.File, &amp;&#123;0xc4200820f0&#125;empty: eface._type = 0x10bfcc0, eface.data = 0xc420080020</code></pre></div><p><code>r，w，empty</code> 的动态类型和动态值都一样</p><p><strong>反射的基础函数</strong></p><p>reflect 包里定义了一个接口和一个结构体，即 <code>reflect.Type</code> 和 <code>reflect.Value</code>，它们提供很多函数来获取存储在接口里的类型信息。</p><p><code>reflect.Type</code> 主要提供关于类型相关的信息，所以它和 <code>_type</code> 关联比较紧密；<code>reflect.Value</code> 则结合 <code>_type</code> 和 <code>data</code> 两者，因此程序员可以获取甚至改变类型的值。</p><p>reflect 包中提供了两个基础的关于反射的函数来获取上述的接口和结构体：</p><div class="code-wrapper"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TypeOf</span><span class="hljs-params">(i <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> Type <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ValueOf</span><span class="hljs-params">(i <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> Value</code></pre></div><p><strong>TypeOf</strong></p><p><code>TypeOf</code> 函数用来提取一个接口中值的类型信息（<strong>返回的是动态类型</strong>）。由于它的输入参数是一个空的 <code>interface&#123;&#125;</code>，调用此函数时，实参会先被转化为 <code>interface&#123;&#125;</code>类型。这样，实参的类型信息、方法集、值信息都存储到 <code>interface&#123;&#125;</code> 变量里了。源码：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TypeOf</span><span class="hljs-params">(i any)</span></span> Type &#123;   eface := *(*emptyInterface)(unsafe.Pointer(&amp;i))    <span class="hljs-comment">// eface.typ是动态类型</span>   <span class="hljs-keyword">return</span> toType(eface.typ)&#125;<span class="hljs-keyword">type</span> emptyInterface <span class="hljs-keyword">struct</span> &#123;typ  *rtypeword unsafe.Pointer&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">toType</span><span class="hljs-params">(t *rtype)</span></span> Type &#123;<span class="hljs-keyword">if</span> t == <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>&#125;<span class="hljs-keyword">return</span> t&#125;</code></pre></div><p><code>Type</code> 实际上是一个接口，定义了很多方法，用来获取类型相关的各种信息，而 <code>*rtype</code> 实现了 <code>Type</code> 接口。</p><div class="code-wrapper"><pre><code class="hljs golang"><span class="hljs-keyword">type</span> Type <span class="hljs-keyword">interface</span> &#123;    <span class="hljs-comment">// 所有的类型都可以调用下面这些函数</span><span class="hljs-comment">// 此类型的变量对齐后所占用的字节数</span>Align() <span class="hljs-type">int</span><span class="hljs-comment">// 如果是 struct 的字段，对齐后占用的字节数</span>FieldAlign() <span class="hljs-type">int</span><span class="hljs-comment">// 返回类型方法集里的第 `i` (传入的参数)个方法</span>Method(<span class="hljs-type">int</span>) Method<span class="hljs-comment">// 通过名称获取方法</span>MethodByName(<span class="hljs-type">string</span>) (Method, <span class="hljs-type">bool</span>)<span class="hljs-comment">// 获取类型方法集里导出的方法个数</span>NumMethod() <span class="hljs-type">int</span><span class="hljs-comment">// 类型名称</span>Name() <span class="hljs-type">string</span><span class="hljs-comment">// 返回类型所在的路径，如：encoding/base64</span>PkgPath() <span class="hljs-type">string</span><span class="hljs-comment">// 返回类型的大小，和 unsafe.Sizeof 功能类似</span>Size() <span class="hljs-type">uintptr</span><span class="hljs-comment">// 返回类型的字符串表示形式</span>String() <span class="hljs-type">string</span><span class="hljs-comment">// 返回类型的类型值</span>Kind() Kind<span class="hljs-comment">// 类型是否实现了接口 u</span>Implements(u Type) <span class="hljs-type">bool</span><span class="hljs-comment">// 是否可以赋值给 u</span>AssignableTo(u Type) <span class="hljs-type">bool</span><span class="hljs-comment">// 是否可以类型转换成 u</span>ConvertibleTo(u Type) <span class="hljs-type">bool</span><span class="hljs-comment">// 类型是否可以比较</span>Comparable() <span class="hljs-type">bool</span><span class="hljs-comment">// 下面这些函数只有特定类型可以调用</span><span class="hljs-comment">// 如：Key, Elem 两个方法就只能是 Map 类型才能调用</span><span class="hljs-comment">// 类型所占据的位数</span>Bits() <span class="hljs-type">int</span><span class="hljs-comment">// 返回通道的方向，只能是 chan 类型调用</span>ChanDir() ChanDir<span class="hljs-comment">// 返回类型是否是可变参数，只能是 func 类型调用</span><span class="hljs-comment">// 比如 t 是类型 func(x int, y ... float64)</span><span class="hljs-comment">// 那么 t.IsVariadic() == true</span>IsVariadic() <span class="hljs-type">bool</span><span class="hljs-comment">// 返回内部子元素类型，只能由类型 Array, Chan, Map, Ptr, or Slice 调用</span>Elem() Type<span class="hljs-comment">// 返回结构体类型的第 i 个字段，只能是结构体类型调用</span><span class="hljs-comment">// 如果 i 超过了总字段数，就会 panic</span>Field(i <span class="hljs-type">int</span>) StructField<span class="hljs-comment">// 返回嵌套的结构体的字段</span>FieldByIndex(index []<span class="hljs-type">int</span>) StructField<span class="hljs-comment">// 通过字段名称获取字段</span>FieldByName(name <span class="hljs-type">string</span>) (StructField, <span class="hljs-type">bool</span>)<span class="hljs-comment">// FieldByNameFunc returns the struct field with a name</span><span class="hljs-comment">// 返回名称符合 func 函数的字段</span>FieldByNameFunc(match <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span>) (StructField, <span class="hljs-type">bool</span>)<span class="hljs-comment">// 获取函数类型的第 i 个参数的类型</span>In(i <span class="hljs-type">int</span>) Type<span class="hljs-comment">// 返回 map 的 key 类型，只能由类型 map 调用</span>Key() Type<span class="hljs-comment">// 返回 Array 的长度，只能由类型 Array 调用</span>Len() <span class="hljs-type">int</span><span class="hljs-comment">// 返回类型字段的数量，只能由类型 Struct 调用</span>NumField() <span class="hljs-type">int</span><span class="hljs-comment">// 返回函数类型的输入参数个数</span>NumIn() <span class="hljs-type">int</span><span class="hljs-comment">// 返回函数类型的返回值个数</span>NumOut() <span class="hljs-type">int</span><span class="hljs-comment">// 返回函数类型的第 i 个值的类型</span>Out(i <span class="hljs-type">int</span>) Type    <span class="hljs-comment">// 返回类型结构体的相同部分</span>common() *rtype<span class="hljs-comment">// 返回类型结构体的不同部分</span>uncommon() *uncommonType&#125;</code></pre></div><p>其中倒数第二个方法 <code>common</code> 返回的 <code>rtype</code>类型和<code>_type</code> 是一回事。都是用来描述类型的一些公共信息，所有的类型结构体里面都包含<code>rtype</code>，不同的类型会包含自己独特的部分。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> rtype <span class="hljs-keyword">struct</span> &#123;size       <span class="hljs-type">uintptr</span>ptrdata    <span class="hljs-type">uintptr</span>hash       <span class="hljs-type">uint32</span>tflag      tflagalign      <span class="hljs-type">uint8</span>fieldAlign <span class="hljs-type">uint8</span>kind       <span class="hljs-type">uint8</span>alg        *typeAlggcdata     *<span class="hljs-type">byte</span>str        nameOffptrToThis  typeOff&#125;</code></pre></div><p>此外，可以看到Type类型实现了String()函数，所以调用<code>fmt.Println</code> 打印的时候，输出的是 <code>String()</code> 的结果。<code>fmt.Printf()</code> 函数，如果使用 <code>%T</code> 来作为格式参数，输出的是 <code>reflect.TypeOf</code> 的结果，也就是动态类型。例如：</p><div class="code-wrapper"><pre><code class="hljs golang">fmt.Printf(<span class="hljs-string">&quot;%T&quot;</span>, <span class="hljs-number">3</span>) <span class="hljs-comment">// int</span></code></pre></div><p><strong>ValueOf函数</strong></p><div class="code-wrapper"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ValueOf</span><span class="hljs-params">(i <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> Value &#123;<span class="hljs-keyword">if</span> i == <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> Value&#123;&#125;&#125;   <span class="hljs-comment">// ……</span><span class="hljs-keyword">return</span> unpackEface(i)&#125;<span class="hljs-comment">// 分解 eface</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">unpackEface</span><span class="hljs-params">(i <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> Value &#123;e := (*emptyInterface)(unsafe.Pointer(&amp;i))t := e.typ<span class="hljs-keyword">if</span> t == <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> Value&#123;&#125;&#125;f := flag(t.Kind())<span class="hljs-keyword">if</span> ifaceIndir(t) &#123;f |= flagIndir&#125;<span class="hljs-keyword">return</span> Value&#123;t, e.word, f&#125;&#125;</code></pre></div><p>将先将 <code>i</code> 转换成 <code>*emptyInterface</code> 类型， 再将它的 <code>typ</code> 字段和 <code>word</code> 字段以及一个标志位字段组装成一个 <code>Value</code> 结构体，而这就是 <code>ValueOf</code> 函数的返回值，它包含类型结构体指针、真实数据的地址、标志位。</p><p>Value 结构体定义了很多方法，通过这些方法可以直接操作 Value 字段 ptr 所指向的实际数据：</p><div class="code-wrapper"><pre><code class="hljs golang"><span class="hljs-comment">// 设置切片的 len 字段，如果类型不是切片，就会panic</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(v Value)</span></span> SetLen(n <span class="hljs-type">int</span>)  <span class="hljs-comment">// 设置切片的 cap 字段</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(v Value)</span></span> SetCap(n <span class="hljs-type">int</span>)  <span class="hljs-comment">// 设置字典的 kv</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(v Value)</span></span> SetMapIndex(key, val Value) <span class="hljs-comment">// 返回切片、字符串、数组的索引 i 处的值</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(v Value)</span></span> Index(i <span class="hljs-type">int</span>) Value  <span class="hljs-comment">// 根据名称获取结构体的内部字段值</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(v Value)</span></span> FieldByName(name <span class="hljs-type">string</span>) Value  <span class="hljs-comment">// ……</span></code></pre></div><p>另外，通过 <code>Type()</code> 方法和 <code>Interface()</code> 方法可以打通 <code>interface</code>、<code>Type</code>、<code>Value</code> 三者。Type() 方法也可以返回变量的类型信息，与 reflect.TypeOf() 函数等价。Interface() 方法可以将 Value 还原成原来的 interface。<img src="/pic/11.png" alt="三者关系"></p><h3 id="2-4-Go语言中反射的应用"><a href="#2-4-Go语言中反射的应用" class="headerlink" title="2.4 Go语言中反射的应用"></a>2.4 Go语言中反射的应用</h3><p>Go 语言中反射的应用非常广：IDE 中的代码自动补全功能、对象序列化（encoding&#x2F;json）、fmt 相关函数的实现、ORM（全称是：Object Relational Mapping，对象关系映射）……</p><h3 id="2-5-如何比较两个对象完全相同"><a href="#2-5-如何比较两个对象完全相同" class="headerlink" title="2.5 如何比较两个对象完全相同"></a>2.5 如何比较两个对象完全相同</h3><p>Go语言提供了一个函数可以完成此项功能：</p><div class="code-wrapper"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">DeepEqual</span><span class="hljs-params">(x, y <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> <span class="hljs-type">bool</span></code></pre></div><p>输入两个interface，输出true 或者 flase 表示输入的两个变量是否是“深度”相等。先明白一点，<strong>如果是不同的类型，即使是底层类型相同，相应的值也相同，那么两者也不是“深度”相等。</strong></p><div class="code-wrapper"><pre><code class="hljs golang"><span class="hljs-keyword">type</span> MyInt <span class="hljs-type">int</span><span class="hljs-keyword">type</span> YourInt <span class="hljs-type">int</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;m := MyInt(<span class="hljs-number">1</span>)y := YourInt(<span class="hljs-number">1</span>)fmt.Println(reflect.DeepEqual(m, y)) <span class="hljs-comment">// false</span>    <span class="hljs-comment">// m, y 底层都是 int，而且值都是 1，但是两者静态类型不同，前者是 MyInt，后者是 YourInt，因此两者不是“深度”相等。</span>&#125;</code></pre></div><p>不同类型下，DeepEqual的比较情形：</p><table><thead><tr><th>类型</th><th>深度相等情形</th></tr></thead><tbody><tr><td>Array</td><td>相同索引处的元素“深度”相等</td></tr><tr><td>Struct</td><td>相应字段，包含导出和不导出，“深度”相等</td></tr><tr><td>Func</td><td>只有两者都是 nil 时</td></tr><tr><td>Interface</td><td>两者存储的具体值“深度”相等</td></tr><tr><td>Map</td><td>1、都为 nil；2、非空、长度相等，指向同一个 map 实体对象，或者相应的 key 指向的 value “深度”相等</td></tr><tr><td>Pointer</td><td>1、使用 &#x3D;&#x3D; 比较的结果相等；2、指向的实体“深度”相等</td></tr><tr><td>Slice</td><td>1、都为 nil；2、非空、长度相等，首元素指向同一个底层数组的相同元素，即 &amp;x[0] &#x3D;&#x3D; &amp;y[0] 或者 相同索引处的元素“深度”相等</td></tr><tr><td>numbers, bools, strings, and channels</td><td>使用 &#x3D;&#x3D; 比较的结果为真</td></tr></tbody></table><p>对于“有环”的类型，比如循环链表，比较两者是否“深度”相等的过程中，需要对已比较的内容作一个标记，一旦发现两个指针之前比较过，立即停止比较，并判定二者是深度相等的。这样做的原因是，及时停止比较，避免陷入无限循环。</p><p>来看源码：</p><div class="code-wrapper"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">DeepEqual</span><span class="hljs-params">(x, y <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> <span class="hljs-type">bool</span> &#123;<span class="hljs-keyword">if</span> x == <span class="hljs-literal">nil</span> || y == <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> x == y&#125;v1 := ValueOf(x)v2 := ValueOf(y)<span class="hljs-keyword">if</span> v1.Type() != v2.Type() &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>&#125;<span class="hljs-keyword">return</span> deepValueEqual(v1, v2, <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[visit]<span class="hljs-type">bool</span>), <span class="hljs-number">0</span>)&#125;</code></pre></div><p>首先查看两者是否有一个是 nil 的情况，这种情况下，只有两者都是 nil，函数才会返回 true</p><p>接着，使用反射，获取x，y 的反射对象，并且立即比较两者的类型，根据前面的内容，这里实际上是动态类型，如果类型不同，直接返回 false。</p><p>最后，最核心的内容在子函数 <code>deepValueEqual</code> 中。</p><p>源码：</p><div class="code-wrapper"><pre><code class="hljs golang"><span class="hljs-comment">// deepValueEqual 函数</span><span class="hljs-comment">// ……</span><span class="hljs-keyword">case</span> Map:<span class="hljs-keyword">if</span> v1.IsNil() != v2.IsNil() &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>&#125;<span class="hljs-keyword">if</span> v1.Len() != v2.Len() &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>&#125;<span class="hljs-keyword">if</span> v1.Pointer() == v2.Pointer() &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;<span class="hljs-keyword">for</span> _, k := <span class="hljs-keyword">range</span> v1.MapKeys() &#123;val1 := v1.MapIndex(k)val2 := v2.MapIndex(k)<span class="hljs-keyword">if</span> !val1.IsValid() || !val2.IsValid() || !deepValueEqual(v1.MapIndex(k), v2.MapIndex(k), visited, depth+<span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><span class="hljs-comment">// ……</span></code></pre></div><p>代码的核心思路是一个 switch 语句，识别输入参数的不同类型，分别递归调用 deepValueEqual 函数，一直递归到最基本的数据类型，比较 int，string 等可以直接得出 true 或者 false，再一层层地返回，最终得到“深度”相等的比较结果。比较的思路和上面表格中的比较思路一致。<code>visited</code> 是一个 map，记录递归过程中，比较过的“对”：</p><div class="code-wrapper"><pre><code class="hljs golang"><span class="hljs-keyword">type</span> visit <span class="hljs-keyword">struct</span> &#123;a1  unsafe.Pointera2  unsafe.Pointertyp Type&#125;<span class="hljs-keyword">map</span>[visit]<span class="hljs-type">bool</span></code></pre></div><p>比较过程中，一旦发现比较的“对”，已经在 map 里出现过的话（防止循环链表一直循环），直接判定“深度”比较结果的是 <code>true</code>。</p><h2 id="3、unsafe"><a href="#3、unsafe" class="headerlink" title="3、unsafe"></a>3、unsafe</h2><h3 id="3-1-Go指针和unsafe-Pointer有什么区别"><a href="#3-1-Go指针和unsafe-Pointer有什么区别" class="headerlink" title="3.1 Go指针和unsafe.Pointer有什么区别"></a>3.1 Go指针和unsafe.Pointer有什么区别</h3><p>Go语言中有指针，但是有许多的限制</p><p>1、Go的指针不能进行数学运算</p><p>2、不同类型的指针不能相互转换</p><p>3、不同类型的指针不能使用&#x3D;&#x3D;或!&#x3D;比较</p><p>4、不同类型的指针变量不能相互赋值</p><p>unsafe.Pointer在unsafe包：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> ArbitraryType <span class="hljs-type">int</span><span class="hljs-keyword">type</span> Pointer *ArbitraryType</code></pre></div><p>从命名来看，<code>Arbitrary</code> 是任意的意思，也就是说 Pointer 可以指向任意类型，实际上它类似于 C 语言里的 <code>void*</code>。</p><p>unsafe 包提供了 2 点重要的能力：</p><ol><li>任何类型的指针和 unsafe.Pointer 可以相互转换。</li><li>uintptr 类型和 unsafe.Pointer 可以相互转换。</li></ol><p>前面说过。go指针不支持数学运算。我们可以将它转换为unintptr，对unintptr类型进行数学运算，在转换为pointer类型。</p><div class="code-wrapper"><pre><code class="hljs golang"><span class="hljs-comment">// uintptr 是一个整数类型，它足够大，可以存储</span><span class="hljs-keyword">type</span> <span class="hljs-type">uintptr</span> <span class="hljs-type">uintptr</span></code></pre></div><p>有一点需要注意的是unintptr没有指针的语义，意思是 uintptr 所指向的对象会被 gc 无情地回收。而 unsafe.Pointer 有指针语义，可以保护它所指向的对象在“有用”的时候不会被垃圾回收。</p><h3 id="3-2-如何利用unsafe获取slice-map的长度"><a href="#3-2-如何利用unsafe获取slice-map的长度" class="headerlink" title="3.2 如何利用unsafe获取slice&amp;map的长度"></a>3.2 如何利用unsafe获取slice&amp;map的长度</h3><p><strong>获取slice长度</strong></p><p>slice结构体如下图所示</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// runtime/slice.go</span><span class="hljs-keyword">type</span> slice <span class="hljs-keyword">struct</span> &#123;    array unsafe.Pointer <span class="hljs-comment">// 元素指针</span>    <span class="hljs-built_in">len</span>   <span class="hljs-type">int</span> <span class="hljs-comment">// 长度 </span>    <span class="hljs-built_in">cap</span>   <span class="hljs-type">int</span> <span class="hljs-comment">// 容量</span>&#125;</code></pre></div><p>调用 make 函数新建一个 slice，底层调用的是 makeslice 函数，返回的是 slice 结构体：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makeslice</span><span class="hljs-params">(et *_type, <span class="hljs-built_in">len</span>, <span class="hljs-built_in">cap</span> <span class="hljs-type">int</span>)</span></span> slice</code></pre></div><p>因此我们可以通过 unsafe.Pointer 和 uintptr 进行转换，得到 slice 的字段值。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;s := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">9</span>, <span class="hljs-number">20</span>)<span class="hljs-keyword">var</span> Len = *(*<span class="hljs-type">int</span>)(unsafe.Pointer(<span class="hljs-type">uintptr</span>(unsafe.Pointer(&amp;s)) + <span class="hljs-type">uintptr</span>(<span class="hljs-number">8</span>)))fmt.Println(Len, <span class="hljs-built_in">len</span>(s)) <span class="hljs-comment">// 9 9</span><span class="hljs-keyword">var</span> Cap = *(*<span class="hljs-type">int</span>)(unsafe.Pointer(<span class="hljs-type">uintptr</span>(unsafe.Pointer(&amp;s)) + <span class="hljs-type">uintptr</span>(<span class="hljs-number">16</span>)))fmt.Println(Cap, <span class="hljs-built_in">cap</span>(s)) <span class="hljs-comment">// 20 20</span>&#125;</code></pre></div><p>Len，cap 的转换流程如下：</p><div class="code-wrapper"><pre><code class="hljs golang">Len: &amp;s =&gt; pointer =&gt; <span class="hljs-type">uintptr</span> =&gt; pointer =&gt; *<span class="hljs-type">int</span> =&gt; <span class="hljs-type">int</span>Cap: &amp;s =&gt; pointer =&gt; <span class="hljs-type">uintptr</span> =&gt; pointer =&gt; *<span class="hljs-type">int</span> =&gt; <span class="hljs-type">int</span></code></pre></div><p><strong>获取map长度</strong></p><p>map底层数据结构</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> hmap <span class="hljs-keyword">struct</span> &#123;count     <span class="hljs-type">int</span>flags     <span class="hljs-type">uint8</span>B         <span class="hljs-type">uint8</span>noverflow <span class="hljs-type">uint16</span>hash0     <span class="hljs-type">uint32</span>buckets    unsafe.Pointeroldbuckets unsafe.Pointernevacuate  <span class="hljs-type">uintptr</span>extra *mapextra&#125;</code></pre></div><p>和 slice 不同的是，makemap 函数返回的是 hmap 的指针，注意是指针：</p><div class="code-wrapper"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makemap</span><span class="hljs-params">(t *maptype, hint <span class="hljs-type">int64</span>, h *hmap, bucket unsafe.Pointer)</span></span> *hmap</code></pre></div><p>我们依然能通过 unsafe.Pointer 和 uintptr 进行转换，得到 hamp 字段的值，只不过，现在 count 变成二级指针了：</p><div class="code-wrapper"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;mp := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>)mp[<span class="hljs-string">&quot;qcrao&quot;</span>] = <span class="hljs-number">100</span>mp[<span class="hljs-string">&quot;stefno&quot;</span>] = <span class="hljs-number">18</span>count := **(**<span class="hljs-type">int</span>)(unsafe.Pointer(&amp;mp))fmt.Println(count, <span class="hljs-built_in">len</span>(mp)) <span class="hljs-comment">// 2 2</span>&#125;</code></pre></div><p>count 的转换过程：</p><div class="code-wrapper"><pre><code class="hljs golang">&amp;mp =&gt; pointer =&gt; **<span class="hljs-type">int</span> =&gt; <span class="hljs-type">int</span></code></pre></div><h3 id="3-3-如何利用unsafe包修改私有成员"><a href="#3-3-如何利用unsafe包修改私有成员" class="headerlink" title="3.3 如何利用unsafe包修改私有成员"></a>3.3 如何利用unsafe包修改私有成员</h3><p>对于一个结构体，通过 offset 函数可以获取结构体成员的偏移量，进而获取成员的地址，读写该地址的内存，就可以达到改变成员值的目的。</p><p>这里有一个内存分配相关的事实：结构体会被分配一块连续的内存，结构体的地址也代表了第一个成员的地址。</p><p>我们来看一个例子：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;unsafe&quot;</span>)<span class="hljs-keyword">type</span> Programmer <span class="hljs-keyword">struct</span> &#123;name <span class="hljs-type">string</span>language <span class="hljs-type">string</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;p := Programmer&#123;<span class="hljs-string">&quot;stefno&quot;</span>, <span class="hljs-string">&quot;go&quot;</span>&#125;fmt.Println(p)name := (*<span class="hljs-type">string</span>)(unsafe.Pointer(&amp;p))*name = <span class="hljs-string">&quot;qcrao&quot;</span>lang := (*<span class="hljs-type">string</span>)(unsafe.Pointer(<span class="hljs-type">uintptr</span>(unsafe.Pointer(&amp;p)) + unsafe.Offsetof(p.language)))*lang = <span class="hljs-string">&quot;Golang&quot;</span>fmt.Println(p)&#125;</code></pre></div><p>代码输出</p><div class="code-wrapper"><pre><code class="hljs go">&#123;stefno <span class="hljs-keyword">go</span>&#125;&#123;qcrao Golang&#125;</code></pre></div><p>我把 Programmer 结构体升级，多加一个字段：</p><div class="code-wrapper"><pre><code class="hljs golang"><span class="hljs-keyword">type</span> Programmer <span class="hljs-keyword">struct</span> &#123;name <span class="hljs-type">string</span>age <span class="hljs-type">int</span>language <span class="hljs-type">string</span>&#125;</code></pre></div><p>并且放在其他包，这样在 main 函数中，它的三个字段都是私有成员变量，不能直接修改。但我通过 unsafe.Sizeof() 函数可以获取成员大小，进而计算出成员的地址，直接修改内存</p><div class="code-wrapper"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;p := Programmer&#123;<span class="hljs-string">&quot;stefno&quot;</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&quot;go&quot;</span>&#125;fmt.Println(p)lang := (*<span class="hljs-type">string</span>)(unsafe.Pointer(<span class="hljs-type">uintptr</span>(unsafe.Pointer(&amp;p)) + unsafe.Sizeof(<span class="hljs-type">int</span>(<span class="hljs-number">0</span>)) + unsafe.Sizeof(<span class="hljs-type">string</span>(<span class="hljs-string">&quot;&quot;</span>))))*lang = <span class="hljs-string">&quot;Golang&quot;</span>fmt.Println(p)&#125;</code></pre></div><p>输出：</p><div class="code-wrapper"><pre><code class="hljs shell">&#123;stefno 18 go&#125;&#123;stefno 18 Golang&#125;</code></pre></div><h3 id="3-4-如何实现字符串和byte切片的零拷贝转换"><a href="#3-4-如何实现字符串和byte切片的零拷贝转换" class="headerlink" title="3.4 如何实现字符串和byte切片的零拷贝转换"></a>3.4 如何实现字符串和byte切片的零拷贝转换</h3><p>这是一个非常精典的例子。实现字符串和 bytes 切片之间的转换，要求是 <code>zero-copy</code>。想一下，一般的做法，都需要遍历字符串或 bytes 切片，再挨个赋值。</p><p>完成这个任务，我们需要了解 slice 和 string 的底层数据结构：</p><div class="code-wrapper"><pre><code class="hljs golang"><span class="hljs-keyword">type</span> StringHeader <span class="hljs-keyword">struct</span> &#123;Data <span class="hljs-type">uintptr</span>Len  <span class="hljs-type">int</span>&#125;<span class="hljs-keyword">type</span> SliceHeader <span class="hljs-keyword">struct</span> &#123;Data <span class="hljs-type">uintptr</span>Len  <span class="hljs-type">int</span>Cap  <span class="hljs-type">int</span>&#125;</code></pre></div><p>上面是反射包下的结构体，路径：src&#x2F;reflect&#x2F;value.go。只需要共享底层 Data 和 Len 就可以实现 <code>zero-copy</code>。</p><div class="code-wrapper"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">string2bytes</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> []<span class="hljs-type">byte</span> &#123;<span class="hljs-keyword">return</span> *(*[]<span class="hljs-type">byte</span>)(unsafe.Pointer(&amp;s))&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">bytes2string</span><span class="hljs-params">(b []<span class="hljs-type">byte</span>)</span></span> <span class="hljs-type">string</span>&#123;<span class="hljs-keyword">return</span> *(*<span class="hljs-type">string</span>)(unsafe.Pointer(&amp;b))&#125;</code></pre></div><p>原理上是利用指针的强转，代码比较简单，不作详细解释。</p>]]></content>
    
    
    <categories>
      
      <category>Go面试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>面试准备-编译</title>
    <link href="/2023/11/05/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87-%E7%BC%96%E8%AF%91/"/>
    <url>/2023/11/05/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87-%E7%BC%96%E8%AF%91/</url>
    
    <content type="html"><![CDATA[<h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h1><h2 id="逃逸分析怎么进行"><a href="#逃逸分析怎么进行" class="headerlink" title="逃逸分析怎么进行"></a>逃逸分析怎么进行</h2><p>逃逸分析是编译器在执行代码分之后，为了对内存分配进行简化和优化，去决定一个变量是分配到栈上还是分配到堆上。</p><p>C和C++中调用malloc和new函数可以在堆上分配一块内存，这块内存的使用和销毁的责任都在程序员。所以很容易发生内存泄露。但是在Go语言中，因为GC的原因，我们基本不用担心内存泄露的问题。虽然也有new函数，但是使用new函数得到的内存不一定就在堆上。</p><p>Go语言逃逸分析最基本的原则是：<strong>如果一个函数返回对一个变量的引用，那么它就会发生逃逸</strong>。简单来说，编译器会分析代码的特征和代码生命周期，Go中的变量只有在编译器可以证明在函数返回后不会再被引用的，才分配到栈上，其他情况下都是分配到堆上。与C和C++不同的是Go语言里没有一个关键字或者函数可以直接让变量被编译器分配到堆上，相反，编译器通过分析代码来决定将变量分配到何处。</p><p>逃逸分析这种“骚操作”把变量合理地分配到它该去的地方。即使你是用new申请到的内存，如果我发现你竟然在退出函数后没有用了，那么就把你丢到栈上，毕竟栈上的内存分配比堆上快很多；反之，即使你表面上只是一个普通的变量，但是经过逃逸分析后发现在退出函数之后还有其他地方在引用，那我就把你分配到堆上。堆不像栈可以自动清理。它会引起Go频繁地进行垃圾回收，而垃圾回收会占用比较大的系统开销（占用CPU容量的25%）。</p><p><strong>通过逃逸分析，可以尽量把那些不需要分配到堆上的变量直接分配到栈上，堆上的变量少了，会减轻分配堆内存的开销，同时也会减少gc的压力，提高程序的运行速度。</strong></p><p>编译器会根据变量是否被外部引用来决定是否逃逸：</p><blockquote><ol><li>如果函数外部没有引用，则优先放到栈中；</li><li>如果函数外部存在引用，则必定放到堆中；</li></ol></blockquote><p><strong>逃逸分析原则</strong></p><ul><li>编译阶段无法确定的参数，会逃逸到堆上；</li><li>变量在函数外部存在引用，会逃逸到堆上；不存在引用，则会继续在栈上；</li><li>变量占用内存较大时，会逃逸到堆上；</li></ul><p><strong>逃逸分析举例</strong></p><p>我们可以使用<code>go build -gcflags &#39;-m -l&#39; go文件名</code>，来查看逃逸分析的结果</p><p>1、<strong>参数为interface类型会逃逸</strong></p><div class="code-wrapper"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;   num := <span class="hljs-number">1</span>   fmt.Println(num)&#125;</code></pre></div><p>运行结果</p><div class="code-wrapper"><pre><code class="hljs shell">PS J:\go-project\test&gt; go build -gcflags &#x27;-m -m -l&#x27; .\tianji.go<span class="hljs-meta prompt_"># </span><span class="language-bash">command-line-arguments</span>.\tianji.go:7:13: num escapes to heap:.\tianji.go:7:13:   flow: &#123;storage for ... argument&#125; = &amp;&#123;storage for num&#125;:.\tianji.go:7:13:     from num (spill) at .\tianji.go:7:13.\tianji.go:7:13:     from ... argument (slice-literal-element) at .\tianji.go:7:13.\tianji.go:7:13:   flow: &#123;heap&#125; = &#123;storage for ... argument&#125;:.\tianji.go:7:13:     from ... argument (spill) at .\tianji.go:7:13.\tianji.go:7:13:     from fmt.Println(... argument...) (call parameter) at .\tianji.go:7:13.\tianji.go:7:13: ... argument does not escape.\tianji.go:7:13: num escapes to heap</code></pre></div><p>原因：<code>func Println(a ...interface&#123;&#125;) (n int, err error)</code>，这个函数的入参是<code>interface类型</code>，编译阶段无法确定其具体的参数类型，所以内存分配到堆上</p><p>2、<strong>变量在函数外部有引用会逃逸</strong></p><div class="code-wrapper"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span> *<span class="hljs-type">int</span> &#123;   num := <span class="hljs-number">1</span>   <span class="hljs-keyword">return</span> &amp;num&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;   _ = test()&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs shell">PS J:\go-project\test&gt; go build -gcflags &#x27;-m -m -l&#x27; .\tianji.go<span class="hljs-meta prompt_"># </span><span class="language-bash">command-line-arguments</span>.\tianji.go:4:2: num escapes to heap:.\tianji.go:4:2:   flow: ~r0 = &amp;num:.\tianji.go:4:2:     from &amp;num (address-of) at .\tianji.go:5:9.\tianji.go:4:2:     from return &amp;num (return) at .\tianji.go:5:2.\tianji.go:4:2: moved to heap: num</code></pre></div><p>原因：变量num在函数外部存在引用，函数退出时栈中的内存（栈帧）已经释放，但引用已经被返回，如果通过引用地址取值，在栈中是取不到值的，所以Go为了避免这个情况，会将内存分配到堆上</p><p>3、<strong>变量占用内存较大时会逃逸</strong></p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;  <span class="hljs-comment">//不会逃逸</span>  s1 := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>)  <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;    s1[i] = i  &#125;  <span class="hljs-comment">//会逃逸</span>  s2 := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">10000</span>)  <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++ &#123;    s2[i] = i  &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs shell">.\tianji.go:11:12: make([]int, 10000, 10000) escapes to heap:.\tianji.go:11:12:   flow: &#123;heap&#125; = &amp;&#123;storage for make([]int, 10000, 10000)&#125;:.\tianji.go:11:12:     from make([]int, 10000, 10000) (too large for stack) at .\tianji.go:11:12.\tianji.go:5:12: make([]int, 10, 10) does not escape.\tianji.go:11:12: make([]int, 10000, 10000) escapes to heap</code></pre></div><p>原因：切片容量过大时，会产生逃逸，内存分配到堆上；容量小时，不会逃逸，内存分配依赖在栈上</p><p>4、<strong>变量大小不确定时会逃逸</strong></p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;num := <span class="hljs-number">10</span>s := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, num, num)<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; num; i++ &#123;s[i] = i&#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs shell">PS J:\go-project\test&gt; go build -gcflags &#x27;-m -m -l&#x27; .\tianji.go<span class="hljs-meta prompt_"># </span><span class="language-bash">command-line-arguments</span>.\tianji.go:5:11: make([]int, num, num) escapes to heap:.\tianji.go:5:11:   flow: &#123;heap&#125; = &amp;&#123;storage for make([]int, num, num)&#125;:.\tianji.go:5:11:     from make([]int, num, num) (non-constant size) at .\tianji.go:5:11.\tianji.go:5:11: make([]int, num, num) escapes to heap</code></pre></div><p>原因：切片的长度和容量，虽然通过声明的变量num来指定了，但在编译阶段是未知的，并不确定num的具体值，所以会逃逸，将内存分配到堆上</p><h2 id="Go编译链接过程"><a href="#Go编译链接过程" class="headerlink" title="Go编译链接过程"></a>Go编译链接过程</h2><p>从源文件到可执行目标文件的转化过程：</p><p><img src="https://golang.design/go-questions/compile/assets/7.png" alt="compile"></p><p>可执行目标文件可以直接在机器上执行。一般而言，先执行一些初始化的工作；找到 main 函数的入口，执行用户写的代码；执行完成后，main 函数退出；再执行一些收尾的工作，整个过程完毕。</p>]]></content>
    
    
    <categories>
      
      <category>Go面试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>面试准备-通道</title>
    <link href="/2023/11/05/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87-%E9%80%9A%E9%81%93/"/>
    <url>/2023/11/05/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87-%E9%80%9A%E9%81%93/</url>
    
    <content type="html"><![CDATA[<h1 id="面试准备-通道"><a href="#面试准备-通道" class="headerlink" title="面试准备-通道"></a>面试准备-通道</h1><h2 id="1、什么是CSP（Communicating-Sequential-Processes）"><a href="#1、什么是CSP（Communicating-Sequential-Processes）" class="headerlink" title="1、什么是CSP（Communicating Sequential Processes）"></a>1、什么是CSP（Communicating Sequential Processes）</h2><p><code>CSP</code>是一种发编程模型，它是一种用于描述并发系统中独立进程之间通信和同步的形式化模型。它描述了两个独立的并发实体<strong>通过共享的通讯 channel(管道)实现并发</strong>的并发模型。Go是第一个将CSP思想引入并融入到语言的核心里。相较于java，python等通过共享内存的同步访问等实现并发编程，Go 的并发编程的模型则用 goroutine 和 channel 来替代。</p><h2 id="2、channel的底层数据结构"><a href="#2、channel的底层数据结构" class="headerlink" title="2、channel的底层数据结构"></a>2、channel的底层数据结构</h2><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> hchan <span class="hljs-keyword">struct</span> &#123;<span class="hljs-comment">// chan 里元素数量</span>qcount   <span class="hljs-type">uint</span><span class="hljs-comment">// chan 底层循环数组的长度</span>dataqsiz <span class="hljs-type">uint</span><span class="hljs-comment">// 指向底层循环数组的指针</span><span class="hljs-comment">// 只针对有缓冲的 channel</span>buf      unsafe.Pointer<span class="hljs-comment">// chan 中元素大小</span>elemsize <span class="hljs-type">uint16</span><span class="hljs-comment">// chan 是否被关闭的标志</span>closed   <span class="hljs-type">uint32</span><span class="hljs-comment">// chan 中元素类型</span>elemtype *_type <span class="hljs-comment">// element type</span><span class="hljs-comment">// 已发送元素在循环数组中的索引</span>sendx    <span class="hljs-type">uint</span>   <span class="hljs-comment">// send index</span><span class="hljs-comment">// 已接收元素在循环数组中的索引</span>recvx    <span class="hljs-type">uint</span>   <span class="hljs-comment">// receive index</span><span class="hljs-comment">// 等待接收的 goroutine 队列</span>recvq    waitq  <span class="hljs-comment">// list of recv waiters</span><span class="hljs-comment">// 等待发送的 goroutine 队列</span>sendq    waitq  <span class="hljs-comment">// list of send waiters</span><span class="hljs-comment">// 保护 hchan 中所有字段</span>lock mutex&#125;</code></pre></div><p>其中有几个比较重要的字段：</p><p><code>buf</code>：指向底层循环数组，只有缓冲型的channel才有。<strong>一个通道相当于一个先进先出（FIFO）的队列。也就是说，通道中的各个元素值都是严格地按照发送的顺序排列的，先被发送通道的元素值一定会先被接收。</strong></p><p><code>sendx</code>,<code>recvx</code>：均指向底层循环数组，表示当前可以发送和接收的元素位置索引值（相对于底层数组）。</p><p><code>sendq</code>,<code>recvq</code>：分别表示被阻塞的 goroutine，这些 goroutine 由于尝试读取 channel 或向 channel 发送数据而被阻塞。</p><p><code>waitq</code> 是 <code>sudog</code> 的一个双向链表，而 <code>sudog</code> 实际上是对 goroutine 的一个封装：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> waitq <span class="hljs-keyword">struct</span> &#123;first *sudoglast  *sudog&#125;</code></pre></div><p><code>lock</code> 用来保证每个读 channel 或写 channel 的操作都是原子的。</p><p>例如，创建一个容量为 6 的，元素为 int 型的 channel 数据结构如下 ：</p><p><img src="/pic/1.png" alt="chan data structure"></p><p>创建</p><p>我们一般使用make创建一个收发通道</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// 无缓冲通道</span>ch1 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<span class="hljs-comment">// 有缓冲通道</span>ch2 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">10</span>)</code></pre></div><p>编译器在编译的时候，会调用<code>makechan</code>来创建一个通道</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makechan</span><span class="hljs-params">(t *chantype, size <span class="hljs-type">int64</span>)</span></span> *hchan</code></pre></div><p>从函数原型来看，创建的chan是一个指针，所以我们能在函数直接传递channel，而不是传递channel的指针。</p><p>具体来看一下代码：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">const</span> hchanSize = unsafe.Sizeof(hchan&#123;&#125;) + <span class="hljs-type">uintptr</span>(-<span class="hljs-type">int</span>(unsafe.Sizeof(hchan&#123;&#125;))&amp;(maxAlign<span class="hljs-number">-1</span>))<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makechan</span><span class="hljs-params">(t *chantype, size <span class="hljs-type">int64</span>)</span></span> *hchan &#123;elem := t.elem<span class="hljs-comment">// 省略了检查 channel size，align 的代码</span><span class="hljs-comment">// ……</span><span class="hljs-keyword">var</span> c *hchan<span class="hljs-comment">// 如果元素类型不含指针 或者 size 大小为 0（无缓冲类型）</span><span class="hljs-comment">// 只进行一次内存分配</span><span class="hljs-keyword">if</span> elem.kind&amp;kindNoPointers != <span class="hljs-number">0</span> || size == <span class="hljs-number">0</span> &#123;<span class="hljs-comment">// 如果 hchan 结构体中不含指针，GC 就不会扫描 chan 中的元素</span><span class="hljs-comment">// 只分配 &quot;hchan 结构体大小 + 元素大小*个数&quot; 的内存</span>c = (*hchan)(mallocgc(hchanSize+<span class="hljs-type">uintptr</span>(size)*elem.size, <span class="hljs-literal">nil</span>, <span class="hljs-literal">true</span>))<span class="hljs-comment">// 如果是缓冲型 channel 且元素大小不等于 0（大小等于 0的元素类型：struct&#123;&#125;）</span><span class="hljs-keyword">if</span> size &gt; <span class="hljs-number">0</span> &amp;&amp; elem.size != <span class="hljs-number">0</span> &#123;c.buf = add(unsafe.Pointer(c), hchanSize)&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// race detector uses this location for synchronization</span><span class="hljs-comment">// Also prevents us from pointing beyond the allocation (see issue 9401).</span><span class="hljs-comment">// 1. 非缓冲型的，buf 没用，直接指向 chan 起始地址处</span><span class="hljs-comment">// 2. 缓冲型的，能进入到这里，说明元素无指针且元素类型为 struct&#123;&#125;，也无影响</span><span class="hljs-comment">// 因为只会用到接收和发送游标，不会真正拷贝东西到 c.buf 处（这会覆盖 chan的内容）</span>c.buf = unsafe.Pointer(c)&#125;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// 进行两次内存分配操作</span>c = <span class="hljs-built_in">new</span>(hchan)c.buf = newarray(elem, <span class="hljs-type">int</span>(size))&#125;c.elemsize = <span class="hljs-type">uint16</span>(elem.size)c.elemtype = elem<span class="hljs-comment">// 循环数组长度</span>c.dataqsiz = <span class="hljs-type">uint</span>(size)<span class="hljs-comment">// 返回 hchan 指针</span><span class="hljs-keyword">return</span> c&#125;</code></pre></div><p><strong>新建一个 chan 后，内存在堆上分配</strong>，大概长这样：</p><p><img src="/pic/2.png" alt="make chan"></p><h2 id="3、有缓冲和无缓冲通道"><a href="#3、有缓冲和无缓冲通道" class="headerlink" title="3、有缓冲和无缓冲通道"></a>3、有缓冲和无缓冲通道</h2><p>无缓冲通道（Unbuffered Channel）：</p><ul><li>无缓冲通道没有内部存储空间，每次发送操作都要等待对应的接收操作，每次接收操作都要等待对应的发送操作。</li><li>发送操作和接收操作是同步的，发送和接收两个goroutine会彼此阻塞，直到另一个goroutine准备好进行匹配的操作。</li><li>无缓冲通道用于强制进行同步，确保数据在发送和接收之间进行直接传递。</li><li>通过 <code>&lt;-</code> 操作符进行发送和接收操作时，会引发发送和接收操作的阻塞，直到另一个goroutine准备好进行匹配的操作。</li></ul><p>缓冲通道（Buffered Channel）：</p><ul><li>缓冲通道具有内部存储空间，可以在通道中存储一定数量的元素。</li><li>发送操作在通道未满时可以立即完成，而接收操作在通道非空时可以立即完成。</li><li>缓冲通道允许发送操作和接收操作以异步方式进行，发送和接收两个goroutine不会彼此直接阻塞等待。</li><li>通过使用带有缓冲区大小的 <code>make</code> 函数来创建缓冲通道，如 <code>ch := make(chan int, bufferSize)</code>。</li></ul><p>缓冲相关的五个属性：</p><ul><li><code>qcount</code> 当前缓冲中元素个数</li><li><code>dataqsize</code> 缓冲最大数量</li><li><code>buf</code> 指向缓冲区内存，这块内存空间可容纳<code>dataqsize</code>个元素</li><li><code>sendx</code> 缓冲区中下一个元素写入时的位置</li><li><code>recvx</code> 缓冲区中下一个被读取的元素的位置</li></ul><p><img src="/pic/3.jpg" alt="img"></p><p>其中通过sendx，recvx可以实现类似于<strong>环形队列</strong>的机制。这样就保证了保证缓冲区有序，并且不需要在每次取出元素时对缓冲区重新排序。</p><h2 id="4、通道的阻塞和非阻塞模式"><a href="#4、通道的阻塞和非阻塞模式" class="headerlink" title="4、通道的阻塞和非阻塞模式"></a>4、通道的阻塞和非阻塞模式</h2><p>在Go语言中，通道可以以阻塞或非阻塞的方式进行操作，这两种模式决定了在通道上发送和接收数据的行为。</p><p>1、阻塞模式</p><ul><li>发送数据：如果通道已满（缓冲区已满），发送操作将被阻塞，直到有空间可用为止。</li><li>接收数据：如果通道为空（缓冲区为空），接收操作将被阻塞，直到有数据可用为止。</li></ul><p>2、非阻塞模式</p><ul><li><p>发送数据：如果通道已满（缓冲区已满），发送操作将立即返回一个错误（通常是<code>false</code>）。</p></li><li><p>接收数据：如果通道为空（缓冲区为空），接收操作将立即返回一个错误（通常是<code>false</code>）。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (    <span class="hljs-string">&quot;fmt&quot;</span>    <span class="hljs-string">&quot;time&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">1</span>) <span class="hljs-comment">// 创建一个带有一个缓冲区的通道</span>    <span class="hljs-comment">// 非阻塞发送</span>    <span class="hljs-keyword">select</span> &#123;    <span class="hljs-keyword">case</span> ch &lt;- <span class="hljs-number">42</span>: <span class="hljs-comment">// 发送数据到通道</span>        fmt.Println(<span class="hljs-string">&quot;数据已发送&quot;</span>)    <span class="hljs-keyword">default</span>:        fmt.Println(<span class="hljs-string">&quot;通道已满，发送失败&quot;</span>)    &#125;    <span class="hljs-comment">// 非阻塞接收</span>    <span class="hljs-keyword">select</span> &#123;    <span class="hljs-keyword">case</span> value := &lt;-ch: <span class="hljs-comment">// 从通道接收数据</span>        fmt.Println(<span class="hljs-string">&quot;接收到数据：&quot;</span>, value)    <span class="hljs-keyword">default</span>:        fmt.Println(<span class="hljs-string">&quot;通道为空，接收失败&quot;</span>)    &#125;    <span class="hljs-comment">// 延时一段时间以便观察输出</span>    time.Sleep(time.Second)&#125;</code></pre></div></li></ul><h2 id="5、向channel发送数据"><a href="#5、向channel发送数据" class="headerlink" title="5、向channel发送数据"></a>5、向channel发送数据</h2><p>要了解向<code>c *hchan</code>中发送数据时需要的一些字段</p><p>​c.qcount通道缓存中的元素个数，无缓冲通道一直为0 </p><p>​c.datasiz通道底层数组中可存储的元素个数</p><p>​c.closed通道状态标志，&#x3D;0表示为关闭，&#x3D;1表示关闭</p><p>​c.sendx下一个要发送进来的元素在循环数组中的下标位置</p><p>​c.recvx下一个要被接受者接收的元素在循环数组中的下标位置</p><p>​c.recvq等待接收消息的协程队列</p><p>​c.sendq等到发送消息的协程队列</p><p>一些状态</p><p>c.qcount&lt;c.datasiz: 只在缓冲型通道中出现，说明缓冲空间没可用。</p><p>c.recvq.first &#x3D;&#x3D; nil: 等待队列中有协程，缓存空间为空</p><p>c.sendq.first &#x3D;&#x3D; nil: 发送队列中有协程，缓存空间满</p><p><strong>不阻塞的发送</strong>：向chan中发送元素时，无需向chan中的buf中拷贝元素值，而是将消息直接拷贝到接收协程的工作栈中，这有两种情况</p><ul><li><p>a、cahnnel是非缓冲型的，这里会检测recvq中是否有等待接收的协程，如果有，直接将数据拷贝到等待协程中，没有的话就挂起发送协程</p></li><li><p>b、channel是缓冲型的：这里如果检测到缓冲空间已经存满元素就直接挂起发送协程，如果检测到recvq中有等待的接收协程，说明通道缓存中没有元素，这时候就可以直接将元素拷贝到等待携程中去。</p></li></ul><p>这种不向缓冲区中写元素，而是直接将元素发送到指定协程的栈空间中的做法的好处是可以减少一次加锁和内存拷贝的次数，性能更高。</p><p><strong>阻塞发送：</strong></p><ul><li><p>如果 <code>c.qcount &lt; c.dataqsiz</code>，说明缓冲区可用（肯定是缓冲型的 channel）。先通过函数取出待发送元素应该去到的位置：</p><div class="code-wrapper"><pre><code class="hljs golang">qp := chanbuf(c, c.sendx)<span class="hljs-comment">// 返回循环队列里第 i 个元素的地址处</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">chanbuf</span><span class="hljs-params">(c *hchan, i <span class="hljs-type">uint</span>)</span></span> unsafe.Pointer &#123;<span class="hljs-keyword">return</span> add(c.buf, <span class="hljs-type">uintptr</span>(i)*<span class="hljs-type">uintptr</span>(c.elemsize))&#125;</code></pre></div></li><li><p>如果没有命中以上条件的，说明 channel 已经满了。不管这个 channel 是缓冲型的还是非缓冲型的，都要将这个 sender “关起来”（goroutine 被阻塞）。如果 block 为 false，直接解锁，返回 false。</p></li></ul><p><strong>拓展</strong></p><p>当有多个goroutine等待一个通道的时候如果没有使用同步机制对协程的调用顺序进行控制的话，无法确哪个goroutine将首先接收到数据。这是由Go调度器决定的，它在运行时负责调度goroutine的执行。</p><h2 id="6、从channel接收数据"><a href="#6、从channel接收数据" class="headerlink" title="6、从channel接收数据"></a>6、从channel接收数据</h2><p>接收操作有两种写法，一种带“OK”，反应channel是够关闭，一种不带 “ok”</p><p>经过编译器的处理后，这两种写法最后对应源码里的这两个函数：</p><div class="code-wrapper"><pre><code class="hljs golang"><span class="hljs-comment">// entry points for &lt;- c from compiled code</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">chanrecv1</span><span class="hljs-params">(c *hchan, elem unsafe.Pointer)</span></span> &#123;chanrecv(c, elem, <span class="hljs-literal">true</span>)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">chanrecv2</span><span class="hljs-params">(c *hchan, elem unsafe.Pointer)</span></span> (received <span class="hljs-type">bool</span>) &#123;_, received = chanrecv(c, elem, <span class="hljs-literal">true</span>)<span class="hljs-keyword">return</span>&#125;</code></pre></div><p>两个函数都指向chanrecv函数：</p><p>chanrecv接收三个参数：c：表示绑定的通道； ep：接收元素的写入地址； block：表示接收是以阻塞模式进行还是以非阻塞的方式进行。</p><ul><li><p>如果channel是一个空值（nil），在非阻塞模式下，会直接返回。在阻塞模式下，会调用gopark函数挂起，而且永远不会被唤醒。因为关闭一个nil的cahnnel会直接引发panic</p></li><li><p>和发送函数一样，接下来搞了一个在非阻塞模式下，不用获取锁，快速检测到失败并且返回的操作。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// 在非阻塞模式下，快速检测到失败，不用获取锁，快速返回 (false, false)</span><span class="hljs-keyword">if</span> !block &amp;&amp; (c.dataqsiz == <span class="hljs-number">0</span> &amp;&amp; c.sendq.first == <span class="hljs-literal">nil</span> ||c.dataqsiz &gt; <span class="hljs-number">0</span> &amp;&amp; atomic.Loaduint(&amp;c.qcount) == <span class="hljs-number">0</span>) &amp;&amp;atomic.Load(&amp;c.closed) == <span class="hljs-number">0</span> &#123;<span class="hljs-keyword">return</span>&#125;</code></pre></div><p>当我们观察到 channel 没准备好接收：</p><ol><li>非缓冲型，等待发送列队里没有 goroutine 在等待</li><li>缓冲型，但 buf 里没有元素</li></ol><p>之后，又观察到 closed &#x3D;&#x3D; 0，即 channel 未关闭。此时并没由被选中，而且也没有取到数据，最后的返回值是 (false, false)。</p></li></ul><h2 id="7、关闭cahnnel"><a href="#7、关闭cahnnel" class="headerlink" title="7、关闭cahnnel"></a>7、关闭cahnnel</h2><p>close 逻辑比较简单，对于一个 channel，recvq 和 sendq 中分别保存了阻塞的发送者和接收者。<strong>关闭 channel 后，对于等待接收者而言，会收到一个相应类型的零值</strong>。对于等待发送者，会直接 panic。所以，在不了解 channel 还有没有接收者的情况下，不能贸然关闭 channel。</p><p>close 函数先上一把大锁，接着把所有挂在这个 channel 上的 sender 和 receiver 全都连成一个 sudog 链表，再解锁。最后，再将所有的 sudog 全都唤醒。</p><p>唤醒之后，该干嘛干嘛。sender 会继续执行 chansend 函数里 goparkunlock 函数之后的代码，很不幸，检测到 channel 已经关闭了，panic。receiver 则比较幸运，进行一些扫尾工作后，返回。这里，selected 返回 true，而返回值 received 则要根据 channel 是否关闭，返回不同的值。如果 channel 关闭，received 为 false，否则为 true。这我们分析的这种情况下，received 返回 false。</p><h2 id="8、从一个关闭的channel仍然能读取出数据吗？"><a href="#8、从一个关闭的channel仍然能读取出数据吗？" class="headerlink" title="8、从一个关闭的channel仍然能读取出数据吗？"></a>8、从一个关闭的channel仍然能读取出数据吗？</h2><p>从一个有缓冲的 channel 里读数据，当 channel 被关闭，依然能读出有效值。只有当返回的 ok 为 false 时，读出的数据才是无效的。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">5</span>)ch &lt;- <span class="hljs-number">18</span><span class="hljs-built_in">close</span>(ch)x, ok := &lt;-ch<span class="hljs-keyword">if</span> ok &#123;fmt.Println(<span class="hljs-string">&quot;received: &quot;</span>, x)&#125;x, ok = &lt;-ch<span class="hljs-keyword">if</span> !ok &#123;fmt.Println(<span class="hljs-string">&quot;channel closed, data invalid.&quot;</span>)&#125;&#125;</code></pre></div><p>运行结果：</p><div class="code-wrapper"><pre><code class="hljs she">received:  18channel closed, data invalid.</code></pre></div><p>先创建了一个有缓冲的 channel，向其发送一个元素，然后关闭此 channel。之后两次尝试从 channel 中读取数据，第一次仍然能正常读出值。第二次返回的 ok 为 false，说明 channel 已关闭，且通道里没有数据。</p><h2 id="9、操作channel的情况总结"><a href="#9、操作channel的情况总结" class="headerlink" title="9、操作channel的情况总结"></a>9、操作channel的情况总结</h2><table><thead><tr><th>操作</th><th>nil channel</th><th>closed channel</th><th>not nil, not closed channel</th></tr></thead><tbody><tr><td>close</td><td>panic</td><td>panic</td><td>正常关闭</td></tr><tr><td>读 &lt;- ch</td><td>阻塞</td><td>读到对应类型的零值</td><td>阻塞或正常读取数据。缓冲型 channel 为空或非缓冲型 channel 没有等待发送者时会阻塞</td></tr><tr><td>写 ch &lt;-</td><td>阻塞</td><td>panic</td><td>阻塞或正常写入数据。非缓冲型 channel 没有等待接收者或缓冲型 channel buf 满时会被阻塞</td></tr></tbody></table><p>总结一下，发生 panic 的情况有三种：向一个关闭的 channel 进行写操作；关闭一个 nil 的 channel；重复关闭一个 channel。</p><p>读、写一个 nil channel 都会被阻塞</p><h2 id="10、优雅的关闭channel"><a href="#10、优雅的关闭channel" class="headerlink" title="10、优雅的关闭channel"></a>10、优雅的关闭channel</h2><p>关于 channel 的使用，有几点不方便的地方：</p><ol><li>在不改变 channel 自身状态的情况下，无法获知一个 channel 是否关闭。</li><li>关闭一个 closed channel 会导致 panic。所以，如果关闭 channel 的一方在不知道 channel 是否处于关闭状态时就去贸然关闭 channel 是很危险的事情。</li><li>向一个 closed channel 发送数据会导致 panic。所以，如果向 channel 发送数据的一方不知道 channel 是否处于关闭状态时就去贸然向 channel 发送数据是很危险的事情。</li></ol><p>一个比较粗糙的检查channel是否关闭的函数</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">IsClosed</span><span class="hljs-params">(ch &lt;-<span class="hljs-keyword">chan</span> T)</span></span> <span class="hljs-type">bool</span> &#123;<span class="hljs-keyword">select</span> &#123;<span class="hljs-keyword">case</span> &lt;-ch:<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><span class="hljs-keyword">default</span>:&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> T)fmt.Println(IsClosed(c)) <span class="hljs-comment">// false</span><span class="hljs-built_in">close</span>(c)fmt.Println(IsClosed(c)) <span class="hljs-comment">// true</span>&#125;</code></pre></div><p>这个函数其实有很多的问题。首先是每调用一次IsClosed函数都会读出channel中的一个元素，改变了channel的状态。</p><p>其次IsClosed函数每次返回的结果仅表示调用的那个瞬间，并不能表示调用之后会不会有其他的goroutine对他进行了操作，改变了它的状态。</p><p>有一条流传比较广泛的channel原则：<strong>不要从一个receiver 侧关闭 channel，也不要在有多个 sender 时，关闭 channel。</strong></p><p>有两个不那么优雅的关闭channel的方法：</p><ol><li><p>使用 defer-recover 机制，放心大胆地关闭 channel 或者向 channel 发送数据。即使发生了 panic，有 defer-recover 在兜底。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SafeCloseChannel</span><span class="hljs-params">(ch <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)</span></span> (justClosed <span class="hljs-type">bool</span>) &#123; <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;  <span class="hljs-keyword">if</span> <span class="hljs-built_in">recover</span>() != <span class="hljs-literal">nil</span> &#123;   justClosed = <span class="hljs-literal">false</span>  &#125; &#125;() <span class="hljs-built_in">close</span>(ch) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;</code></pre></div></li><li><p>使用 sync.Once 来保证只关闭一次。</p></li></ol><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyChannel <span class="hljs-keyword">struct</span>&#123;   C <span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;   once sync.Once&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewMyChannel</span><span class="hljs-params">()</span></span> *MyChannel&#123;   <span class="hljs-keyword">return</span> &amp;MyChannel&#123;C:<span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(mc *MyChannel)</span></span> SafeClose()&#123;   mc.once.Do(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>&#123;      <span class="hljs-built_in">close</span>(mc.C)   &#125;)&#125;</code></pre></div><p>那么如何来优雅的关闭通道呢？我们先总结一下sender 和 receiver 的个数有几种情况：</p><ol><li>一个 sender，一个 receiver</li><li>一个 sender， M 个 receiver</li><li>N 个 sender，一个 reciver</li><li>N 个 sender， M 个 receiver</li></ol><p>对于第1, 2中情况，不必多说，直接在sender中关闭就好了。</p><p>第3中情况下，我们的解决方案是增加一个传递关闭信号的channel，receiver通过信号channel下达关闭数据channel指令。senders监听到关闭信号后，停止发送数据。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;rand.Seed(time.Now().UnixNano())<span class="hljs-keyword">const</span> Max = <span class="hljs-number">100000</span><span class="hljs-keyword">const</span> NumSenders = <span class="hljs-number">1000</span>dataCh := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">100</span>)stopCh := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; NumSenders; i++ &#123;<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">for</span> &#123;<span class="hljs-keyword">select</span> &#123;<span class="hljs-keyword">case</span> &lt;-stopCh:<span class="hljs-keyword">return</span><span class="hljs-keyword">case</span> dataCh &lt;- rand.Intn(Max):&#125;&#125;&#125;()&#125;<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">for</span> value := <span class="hljs-keyword">range</span> dataCh &#123;<span class="hljs-keyword">if</span> value == Max<span class="hljs-number">-1</span> &#123;fmt.Println(<span class="hljs-string">&quot;send stop signal to senders&quot;</span>)                <span class="hljs-comment">// 当我们关闭一个cahnnel的时候，所有的receiver会受到对应类型的零值。</span>                <span class="hljs-comment">// 这时候select分支case &lt;-stopCh被选中，退出函数，不再发送数据。</span><span class="hljs-built_in">close</span>(stopCh)<span class="hljs-keyword">return</span>&#125;fmt.Println(value)&#125;&#125;()<span class="hljs-keyword">select</span> &#123;<span class="hljs-keyword">case</span> &lt;-time.After(time.Hour):&#125;&#125;</code></pre></div><p>第四种情况下，这里有 M 个 receiver，如果直接还是采取第 3 种解决方案，由 receiver 直接关闭 stopCh 的话，就会重复关闭一个 channel，导致 panic。因此需要增加一个中间人goroutine，M 个 receiver 都向它发送关闭 stopCh 的“请求”，中间人收到第一个请求后，就会直接下达关闭 stopCh 的指令（通过关闭 stopCh，这时就不会发生重复关闭的情况，因为 stopCh 的发送方只有中间人一个）。另外，这里的 N 个 sender 也可以向中间人发送关闭 stopCh 的请求。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;rand.Seed(time.Now().UnixNano())<span class="hljs-keyword">const</span> Max = <span class="hljs-number">100000</span><span class="hljs-keyword">const</span> NumSenders = <span class="hljs-number">1000</span><span class="hljs-keyword">const</span> NumReceiver = <span class="hljs-number">10</span>dataCh := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">100</span>)stopCh := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)toStop := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>, <span class="hljs-number">1</span>)<span class="hljs-comment">// moderator</span><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;&lt;-toStop<span class="hljs-built_in">close</span>(stopCh)&#125;()<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; NumSenders; i++ &#123;<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(id <span class="hljs-type">string</span>)</span></span> &#123;<span class="hljs-keyword">for</span> &#123;value := rand.Intn(Max)<span class="hljs-keyword">if</span> value == <span class="hljs-number">0</span> &#123;<span class="hljs-keyword">select</span> &#123;<span class="hljs-keyword">case</span> toStop &lt;- <span class="hljs-string">&quot;sender#&quot;</span> + id:<span class="hljs-keyword">default</span>:&#125;<span class="hljs-keyword">return</span>&#125;<span class="hljs-keyword">select</span> &#123;<span class="hljs-keyword">case</span> &lt;-stopCh:<span class="hljs-keyword">return</span><span class="hljs-keyword">case</span> dataCh &lt;- value:&#125;&#125;&#125;(strconv.Itoa(i))&#125;<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; NumReceiver; i++ &#123;<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(id <span class="hljs-type">string</span>)</span></span> &#123;<span class="hljs-keyword">for</span> &#123;<span class="hljs-keyword">select</span> &#123;<span class="hljs-keyword">case</span> &lt;-stopCh:<span class="hljs-keyword">return</span><span class="hljs-keyword">case</span> value := &lt;-dataCh:<span class="hljs-keyword">if</span> value == Max<span class="hljs-number">-1</span> &#123;<span class="hljs-keyword">select</span> &#123;<span class="hljs-keyword">case</span> toStop &lt;- <span class="hljs-string">&quot;receiver#&quot;</span> + id:<span class="hljs-keyword">default</span>:&#125;<span class="hljs-keyword">return</span>&#125;fmt.Println(value)&#125;&#125;&#125;(strconv.Itoa(i))&#125;<span class="hljs-keyword">select</span> &#123;<span class="hljs-keyword">case</span> &lt;-time.After(time.Hour):&#125;&#125;</code></pre></div><p>代码中的toStop就是中间人的角色，这里将其声明为一个缓冲型的channel。假设 toStop 声明的是一个非缓冲型的 channel，那么第一个发送的关闭 stopCh 请求可能会丢失。因为无论是 sender 还是 receiver 都是通过 select 语句来发送请求，如果中间人所在的 goroutine 没有准备好，那 select 语句就不会选中，直接走 default 选项，什么也不做。这样，第一个关闭 stopCh 的请求就会丢失。</p><h2 id="11、Channel-发送和接收元素的本质是什么？"><a href="#11、Channel-发送和接收元素的本质是什么？" class="headerlink" title="11、Channel 发送和接收元素的本质是什么？"></a>11、Channel 发送和接收元素的本质是什么？</h2><p> channel 的发送和接收操作本质上都是 “值的拷贝”，无论是从 sender goroutine 的栈到 chan buf，还是从 chan buf 到 receiver goroutine，或者是直接从 sender goroutine 到 receiver goroutine。</p><p>举个例子：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> user <span class="hljs-keyword">struct</span> &#123;name <span class="hljs-type">string</span>age  <span class="hljs-type">int</span>&#125;<span class="hljs-keyword">var</span> u = user&#123;name: <span class="hljs-string">&quot;Ankur&quot;</span>, age: <span class="hljs-number">25</span>&#125;<span class="hljs-keyword">var</span> g = &amp;u<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">modifyUser</span><span class="hljs-params">(pu *user)</span></span> &#123;fmt.Println(<span class="hljs-string">&quot;modifyUser Received Vaule&quot;</span>, pu)pu.name = <span class="hljs-string">&quot;Anand&quot;</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printUser</span><span class="hljs-params">(u &lt;-<span class="hljs-keyword">chan</span> *user)</span></span> &#123;time.Sleep(<span class="hljs-number">2</span> * time.Second)fmt.Println(<span class="hljs-string">&quot;printUser goRoutine called&quot;</span>, &lt;-u)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> *user, <span class="hljs-number">5</span>)c &lt;- gfmt.Println(g)<span class="hljs-comment">// modify g</span>g = &amp;user&#123;name: <span class="hljs-string">&quot;Ankur Anand&quot;</span>, age: <span class="hljs-number">100</span>&#125;<span class="hljs-keyword">go</span> printUser(c)<span class="hljs-keyword">go</span> modifyUser(g)time.Sleep(<span class="hljs-number">5</span> * time.Second)fmt.Println(g)&#125;</code></pre></div><p>运行结果：</p><div class="code-wrapper"><pre><code class="hljs shell">&amp;&#123;Ankur 25&#125;modifyUser Received Vaule &amp;&#123;Ankur Anand 100&#125;printUser goRoutine called &amp;&#123;Ankur 25&#125;&amp;&#123;Anand 100&#125;</code></pre></div><p><img src="/pic/4.png" alt="output"></p><p>一开始构造一个结构体 u，地址是 0x56420，图中地址上方就是它的内容。接着把 <code>&amp;u</code> 赋值给指针 <code>g</code>，g 的地址是 0x565bb0，它的内容就是一个地址，指向 u。</p><p>main 程序里，先把 g 发送到 c，根据 <code>copy value</code> 的本质，进入到 chan buf 里的就是 <code>0x56420</code>，它是指针 g 的值（不是它指向的内容），所以打印从 channel 接收到的元素时，它就是 <code>&amp;&#123;Ankur 25&#125;</code>。因此，这里并不是将指针 g “发送” 到了 channel 里，只是拷贝它的值而已。</p><h2 id="12、channel会在什么情况下引起资源泄露"><a href="#12、channel会在什么情况下引起资源泄露" class="headerlink" title="12、channel会在什么情况下引起资源泄露"></a>12、channel会在什么情况下引起资源泄露</h2><p>channel可能会引起goroutine的泄露，因为有的goroutine会因为channel处于满或者空的状态一直得不到改变。同时垃圾回收器也不会回收此类资源，进而导致goroutine一直处于被挂起的状态，资源得不到释放。</p><h2 id="13-channel有哪些应用"><a href="#13-channel有哪些应用" class="headerlink" title="13 channel有哪些应用"></a>13 channel有哪些应用</h2><p><strong>1、停止信号</strong></p><p>这个在“如何优雅地关闭 channel”那一节已经讲得很多了</p><p><strong>2、任务定时</strong></p><p>与timer结合一般有两种方法：实现超时控制，实现定期执行某个任务。</p><p>有时候我们想要执行一个任务，但是又不想它浪费太多时间，上一个定时器就可以搞定</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">select</span>&#123;    <span class="hljs-keyword">case</span> &lt;- time.After(<span class="hljs-number">100</span> * time.Millisecond):    <span class="hljs-keyword">case</span> &lt;- s.stopc:    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>&#125;</code></pre></div><p>等待 100 ms 后，如果 s.stopc 还没有读出数据或者被关闭，就直接结束。这是来自 etcd 源码里的一个例子，这样的写法随处可见。</p><p>定时执行某个任务，也比较简单：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">worker</span><span class="hljs-params">()</span></span> &#123;ticker := time.Tick(<span class="hljs-number">1</span> * time.Second)<span class="hljs-keyword">for</span> &#123;<span class="hljs-keyword">select</span> &#123;<span class="hljs-keyword">case</span> &lt;- ticker:<span class="hljs-comment">// 执行定时任务</span>fmt.Println(<span class="hljs-string">&quot;执行 1s 定时任务&quot;</span>)&#125;&#125;    ticker := time.Tick(<span class="hljs-number">1</span> * time.Second)<span class="hljs-comment">// 创建一个信号通道</span>sigs := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> os.Signal, <span class="hljs-number">1</span>)<span class="hljs-comment">// 监听 SIGINT 和 SIGTERM 信号</span>signal.Notify(sigs, syscall.SIGINT, syscall.SIGTERM)<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span><span class="hljs-keyword">for</span> &#123;<span class="hljs-keyword">select</span> &#123;<span class="hljs-keyword">case</span> &lt;-ticker:            <span class="hljs-comment">// 执行定时任务</span>fmt.Println(i)<span class="hljs-keyword">case</span> &lt;-sigs:            <span class="hljs-comment">// 结束定时任务</span>fmt.Println(<span class="hljs-string">&quot;shutdown!!!&quot;</span>)<span class="hljs-keyword">return</span>&#125;i++&#125;&#125;</code></pre></div><p>每隔 1 秒种，执行一次定时任务。</p><p><strong>3、解耦生产方和消费方</strong></p><p>服务启动时，启动 n 个 worker，作为工作协程池，这些协程工作在一个 <code>for &#123;&#125;</code> 无限循环里，从某个 channel 消费工作任务并执行：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">worker</span><span class="hljs-params">(taskCh &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)</span></span> &#123;<span class="hljs-keyword">const</span> N = <span class="hljs-number">5</span><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; N; i++ &#123;<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(id <span class="hljs-type">int</span>)</span></span> &#123;<span class="hljs-keyword">for</span> &#123;task := &lt;-taskChfmt.Println(<span class="hljs-string">&quot;finish task: %d by worker %d\n&quot;</span>, task, id)time.After(<span class="hljs-number">1</span> * time.Second)&#125;&#125;(i)&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-comment">// 创建一个信号通道</span>sigs := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> os.Signal, <span class="hljs-number">1</span>)<span class="hljs-comment">// 监听 SIGINT 和 SIGTERM 信号</span>signal.Notify(sigs, syscall.SIGINT, syscall.SIGTERM)taskCh := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">100</span>)<span class="hljs-keyword">go</span> worker(taskCh)<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;taskCh &lt;- i&#125;<span class="hljs-keyword">select</span> &#123;<span class="hljs-keyword">case</span> &lt;-time.After(time.Hour):<span class="hljs-keyword">case</span> &lt;-sigs:fmt.Println(<span class="hljs-string">&quot;shutdown!!!&quot;</span>)<span class="hljs-keyword">return</span>&#125;&#125;</code></pre></div><p>5 个工作协程在不断地从工作队列里取任务，生产方只管往 channel 发送任务即可，解耦生产方和消费方。</p><p>输出结果：</p><div class="code-wrapper"><pre><code class="hljs shell">finish task: %d by worker %d 0 4finish task: %d by worker %d 5 4finish task: %d by worker %d 6 4finish task: %d by worker %d 7 4finish task: %d by worker %d 8 4finish task: %d by worker %d 9 4finish task: %d by worker %d 2 0finish task: %d by worker %d 3 2finish task: %d by worker %d 4 3finish task: %d by worker %d 1 1</code></pre></div><p><strong>4、控制并发数</strong></p><p>有时需要定时执行几百个任务，例如每天定时按城市来执行一些离线计算的任务。但是并发数又不能太高，因为任务执行过程依赖第三方的一些资源，对请求的速率有限制。这时就可以通过 channel 来控制并发数。</p><p>下面是一个例子：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> limit = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">3</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-comment">// …………</span>    <span class="hljs-keyword">for</span> _, w := <span class="hljs-keyword">range</span> work &#123;        <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;            limit &lt;- <span class="hljs-number">1</span>            w()            &lt;-limit        &#125;()    &#125;    <span class="hljs-comment">// …………</span>&#125;</code></pre></div><p>构建一个缓冲型的 channel，容量为 3。接着遍历任务列表，每个任务启动一个 goroutine 去完成。真正执行任务，访问第三方的动作在 w() 中完成，在执行 w() 之前，先要从 limit 中拿“许可证”，拿到许可证之后，才能执行 w()，并且在执行完任务，要将“许可证”归还。这样就可以控制同时运行的 goroutine 数。</p><p>这里，<code>limit &lt;- 1</code> 放在 func 内部而不是外部，原因是：</p><blockquote><p>如果在外层，就是控制系统 goroutine 的数量，可能会阻塞 for 循环，影响业务逻辑。</p></blockquote><blockquote><p>limit 其实和逻辑无关，只是性能调优，放在内层和外层的语义不太一样。</p></blockquote><p>还有一点要注意的是，如果 w() 发生 panic，那“许可证”可能就还不回去了，<strong>因此需要使用 defer 来保证。</strong> </p>]]></content>
    
    
    <categories>
      
      <category>Go面试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/11/05/hello-world/"/>
    <url>/2023/11/05/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><div class="code-wrapper"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span></code></pre></div><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><div class="code-wrapper"><pre><code class="hljs bash">$ hexo server</code></pre></div><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><div class="code-wrapper"><pre><code class="hljs bash">$ hexo generate</code></pre></div><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><div class="code-wrapper"><pre><code class="hljs bash">$ hexo deploy</code></pre></div><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>单元测试</title>
    <link href="/2023/11/05/go%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    <url>/2023/11/05/go%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h1 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h1><p>单元测试不允许有任何的外部依赖，我们不会在测试代码中连接数据库，调用api等。这些外部依赖在执行的时候都需要被模拟（mock&#x2F;stub）。</p><p>常见依赖</p><ul><li>网络依赖-函数执行依赖于网络请求，比如第三方http-api，rpc服务，消息队列等等</li><li>数据库依赖</li><li>I&#x2F;o依赖（文件）</li></ul><p><strong>Mock和Stub区别</strong></p><p>​    Mock（模拟）和Stub（桩）是在测试过程中，模拟外部依赖行为的两种常用的技术手段。 通过Mock和Stub我们不仅可以让测试环境没有外部依赖，而且<strong>还可以模拟一些异常行为</strong>，如数据库服务不可用，没有文件的访问权限等等。</p><p>在Go语言中，可以这样描述Mock和Stub：</p><ul><li>Mock：在测试包中创建一个结构体，满足某个外部依赖的接口 <code>interface&#123;&#125;</code>、</li><li>Stub：在测试包中创建一个模拟方法，用于替换生成代码中的方法</li></ul><p>例子</p><p>mock</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// mock</span><span class="hljs-comment">//auth.go</span><span class="hljs-comment">//假设我们有一个依赖http请求的鉴权接口</span><span class="hljs-keyword">type</span> AuthService <span class="hljs-keyword">interface</span>&#123;        Login(username <span class="hljs-type">string</span>,password <span class="hljs-type">string</span>) (token <span class="hljs-type">string</span>,e <span class="hljs-type">error</span>)       Logout(token <span class="hljs-type">string</span>) <span class="hljs-type">error</span>&#125;<span class="hljs-comment">// mock代码：</span><span class="hljs-comment">//auth_test.go</span><span class="hljs-keyword">type</span> authService <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(auth *authService)</span></span> Login (username <span class="hljs-type">string</span>,password <span class="hljs-type">string</span>) (<span class="hljs-type">string</span>,<span class="hljs-type">error</span>)&#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;token&quot;</span>, <span class="hljs-literal">nil</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(auth *authService)</span></span> Logout(token <span class="hljs-type">string</span>) <span class="hljs-type">error</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>&#125;</code></pre></div><p>在这里我们用 <code>authService</code>实现了 <code>AuthService</code>接口，这样测试 <code>Login,Logout</code>就不再需需要依赖网络请求了。而且我们也可以模拟一些错误的情况进行测试：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">//auth_test.go</span><span class="hljs-comment">//模拟登录失败</span><span class="hljs-keyword">type</span> authLoginErr <span class="hljs-keyword">struct</span> &#123;auth AuthService  <span class="hljs-comment">//可以使用组合的特性，Logout方法我们不关心，只用“覆盖”Login方法即可</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(auth *authLoginErr)</span></span> Login (username <span class="hljs-type">string</span>,password <span class="hljs-type">string</span>) (<span class="hljs-type">string</span>,<span class="hljs-type">error</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>, errors.New(<span class="hljs-string">&quot;用户名密码错误&quot;</span>)&#125;<span class="hljs-comment">//模拟api服务器宕机</span><span class="hljs-keyword">type</span> authUnavailableErr <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(auth *authUnavailableErr)</span></span> Login (username <span class="hljs-type">string</span>,password <span class="hljs-type">string</span>) (<span class="hljs-type">string</span>,<span class="hljs-type">error</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>, errors.New(<span class="hljs-string">&quot;api服务不可用&quot;</span>)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(auth *authUnavailableErr)</span></span> Logout(token <span class="hljs-type">string</span>) <span class="hljs-type">error</span>&#123;<span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">&quot;api服务不可用&quot;</span>)&#125;</code></pre></div><h1 id="Go-Mock"><a href="#Go-Mock" class="headerlink" title="Go Mock"></a>Go Mock</h1><p>&emsp;&emsp;mock&#x2F;stub 测试,用于测试函数的依赖比较复杂，并且有的依赖不能直接创建，例如数据库、文件I&#x2F;O等。这种场景可以使用mock对象的模拟依赖项的行为。</p><p><a href="https://github.com/golang/mock">gomock</a> 是官方提供的 mock 框架，同时还提供了 mockgen 工具用来辅助生成测试代码。</p><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">go</span> get -u github.com/golang/mock/gomock<span class="hljs-keyword">go</span> get -u github.com/golang/mock/mockgen</code></pre></div><h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// db.go</span><span class="hljs-keyword">type</span> DB <span class="hljs-keyword">interface</span> &#123;Get(key <span class="hljs-type">string</span>) (<span class="hljs-type">int</span>, <span class="hljs-type">error</span>)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetFromDB</span><span class="hljs-params">(db DB, key <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<span class="hljs-keyword">if</span> value, err := db.Get(key); err == <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> value&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>&#125;</code></pre></div><p>假设<code>DB</code>是代码中负责与数据库交互的部分（在这里用map来模拟），测试用例中不能创建真实的数据库连接。这个时候，如果我们需要测试<code>GetFromDB</code>这个函数内部的逻辑，就需要mock接口<code>DB</code>。</p><p>第一步：使用 <code>mockgen</code> 生成 <code>db_mock.go</code>。一般传递三个参数。包含需要被mock的接口得到源文件<code>source</code>，生成的目标文件<code>destination</code>，包名<code>package</code>。</p><div class="code-wrapper"><pre><code class="hljs go">$ mockgen -source=db.<span class="hljs-keyword">go</span> -destination=db_mock.<span class="hljs-keyword">go</span> -<span class="hljs-keyword">package</span>=main</code></pre></div><p>第二步：新建 <code>db_test.go</code>，写测试用例。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestGetFromDB</span><span class="hljs-params">(t *testing.T)</span></span> &#123;ctrl := gomock.NewController(t)<span class="hljs-keyword">defer</span> ctrl.Finish() <span class="hljs-comment">// 断言 DB.Get() 方法是否被调用</span>m := NewMockDB(ctrl)m.EXPECT().Get(gomock.Eq(<span class="hljs-string">&quot;Tom&quot;</span>)).Return(<span class="hljs-number">100</span>, errors.New(<span class="hljs-string">&quot;not exist&quot;</span>))<span class="hljs-keyword">if</span> v := GetFromDB(m, <span class="hljs-string">&quot;Tom&quot;</span>); v != <span class="hljs-number">-1</span> &#123;t.Fatal(<span class="hljs-string">&quot;expected -1, but got&quot;</span>, v)&#125;&#125;</code></pre></div><ul><li>这个测试用例有2个目的，一是使用 <code>ctrl.Finish()</code> 断言 <code>DB.Get()</code> 被是否被调用，如果没有被调用，后续的 mock 就失去了意义；</li><li>二是测试方法 <code>GetFromDB()</code> 的逻辑是否正确(如果 <code>DB.Get()</code> 返回 error，那么 <code>GetFromDB()</code> 返回 -1)。</li><li><code>NewMockDB()</code> 的定义在 <code>db_mock.go</code> 中，由 mockgen 自动生成。</li></ul><p>最终的代码结构如下：</p><div class="code-wrapper"><pre><code class="hljs coq">project/    |<span class="hljs-type">--db</span>.go    |<span class="hljs-type">--db_mock</span>.go // generated <span class="hljs-built_in">by</span> mockgen    |<span class="hljs-type">--db_test</span>.go</code></pre></div><p>执行测试：</p><div class="code-wrapper"><pre><code class="hljs asciidoc">$ go test . -cover -v<span class="hljs-section">=== RUN   TestGetFromDB</span><span class="hljs-bullet">--- </span>PASS: TestGetFromDB (0.00s)PASScoverage: 81.2% of statementsok      example 0.008s  coverage: 81.2% of statements</code></pre></div><h2 id="打桩"><a href="#打桩" class="headerlink" title="打桩"></a>打桩</h2><p>在上面的例子中，当 <code>Get()</code> 的参数为 Tom，则返回 error，这称之为<code>打桩(stub)</code>，有明确的参数和返回值是最简单打桩方式。除此之外，检测调用次数、调用顺序，动态设置返回值等方式也经常使用。</p><h3 id="参数-Eq-Any-Not-Nil"><a href="#参数-Eq-Any-Not-Nil" class="headerlink" title="参数(Eq, Any, Not, Nil)"></a>参数(Eq, Any, Not, Nil)</h3><div class="code-wrapper"><pre><code class="hljs go">m.EXPECT().Get(gomock.Eq(<span class="hljs-string">&quot;Tom&quot;</span>)).Return(<span class="hljs-number">0</span>, errors.New(<span class="hljs-string">&quot;not exist&quot;</span>))m.EXPECT().Get(gomock.Any()).Return(<span class="hljs-number">630</span>, <span class="hljs-literal">nil</span>)m.EXPECT().Get(gomock.Not(<span class="hljs-string">&quot;Sam&quot;</span>)).Return(<span class="hljs-number">0</span>, <span class="hljs-literal">nil</span>) m.EXPECT().Get(gomock.Nil()).Return(<span class="hljs-number">0</span>, errors.New(<span class="hljs-string">&quot;nil&quot;</span>))</code></pre></div><ul><li><code>Eq(value)</code> 表示与 value 等价的值。</li><li><code>Any()</code> 可以用来表示任意的入参。</li><li><code>Not(value)</code> 用来表示非 value 以外的值。</li><li><code>Nil()</code> 表示 None 值。</li></ul><h3 id="返回值-Return-DoAndReturn"><a href="#返回值-Return-DoAndReturn" class="headerlink" title="返回值(Return, DoAndReturn)"></a>返回值(Return, DoAndReturn)</h3><div class="code-wrapper"><pre><code class="hljs go">m.EXPECT().Get(gomock.Not(<span class="hljs-string">&quot;Sam&quot;</span>)).Return(<span class="hljs-number">0</span>, <span class="hljs-literal">nil</span>)m.EXPECT().Get(gomock.Any()).Do(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(key <span class="hljs-type">string</span>)</span></span> &#123;    t.Log(key)&#125;)m.EXPECT().Get(gomock.Any()).DoAndReturn(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(key <span class="hljs-type">string</span>)</span></span> (<span class="hljs-type">int</span>, <span class="hljs-type">error</span>) &#123;    <span class="hljs-keyword">if</span> key == <span class="hljs-string">&quot;Sam&quot;</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">630</span>, <span class="hljs-literal">nil</span>    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, errors.New(<span class="hljs-string">&quot;not exist&quot;</span>)&#125;)</code></pre></div><ul><li><code>Return</code> 返回确定的值</li><li><code>Do</code> Mock 方法被调用时，要执行的操作吗，忽略返回值。</li><li><code>DoAndReturn</code> 可以动态地控制返回值。</li></ul><h3 id="调用次数-Times"><a href="#调用次数-Times" class="headerlink" title="调用次数(Times)"></a>调用次数(Times)</h3><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestGetFromDB</span><span class="hljs-params">(t *testing.T)</span></span> &#123;ctrl := gomock.NewController(t)<span class="hljs-keyword">defer</span> ctrl.Finish()m := NewMockDB(ctrl)m.EXPECT().Get(gomock.Not(<span class="hljs-string">&quot;Sam&quot;</span>)).Return(<span class="hljs-number">0</span>, <span class="hljs-literal">nil</span>).Times(<span class="hljs-number">2</span>)GetFromDB(m, <span class="hljs-string">&quot;ABC&quot;</span>)GetFromDB(m, <span class="hljs-string">&quot;DEF&quot;</span>)&#125;</code></pre></div><ul><li><code>Times()</code> 断言 Mock 方法被调用的次数。</li><li><code>MaxTimes()</code> 最大次数。</li><li><code>MinTimes()</code> 最小次数。</li><li><code>AnyTimes()</code> 任意次数（包括 0 次）。</li></ul><h3 id="调用顺序-InOrder"><a href="#调用顺序-InOrder" class="headerlink" title="调用顺序(InOrder)"></a>调用顺序(InOrder)</h3><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestGetFromDB</span><span class="hljs-params">(t *testing.T)</span></span> &#123;ctrl := gomock.NewController(t)<span class="hljs-keyword">defer</span> ctrl.Finish() <span class="hljs-comment">// 断言 DB.Get() 方法是否被调用</span>m := NewMockDB(ctrl)o1 := m.EXPECT().Get(gomock.Eq(<span class="hljs-string">&quot;Tom&quot;</span>)).Return(<span class="hljs-number">0</span>, errors.New(<span class="hljs-string">&quot;not exist&quot;</span>))o2 := m.EXPECT().Get(gomock.Eq(<span class="hljs-string">&quot;Sam&quot;</span>)).Return(<span class="hljs-number">630</span>, <span class="hljs-literal">nil</span>)gomock.InOrder(o1, o2)GetFromDB(m, <span class="hljs-string">&quot;Tom&quot;</span>)GetFromDB(m, <span class="hljs-string">&quot;Sam&quot;</span>)&#125;</code></pre></div><h3 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h3><p>在使用mockgen创建的时候报错，</p><div class="code-wrapper"><pre><code class="hljs go">PS J:\<span class="hljs-keyword">go</span>-project\id-maker&gt; mockgen -source=internal/usecase/interfaces.<span class="hljs-keyword">go</span> -destination=internal/usecase/mock_test.<span class="hljs-keyword">go</span><span class="hljs-number">2023</span>/<span class="hljs-number">04</span>/<span class="hljs-number">24</span> <span class="hljs-number">22</span>:<span class="hljs-number">13</span>:<span class="hljs-number">31</span> Loading input failed: failed parsing source file internal/usecase/interfaces: open internal/usecase/interfaces: The system cannot find the file specified.</code></pre></div><p>好像是在source提供的相对路径里面无法识别<code>.go</code>文件，网上找了很多方法都没办法识别，最后使用绝对路径生成了。不知道为什么。。。。。</p><div class="code-wrapper"><pre><code class="hljs go">PS J:\<span class="hljs-keyword">go</span>-project\id-maker\internal\usecase&gt; mockgen -source=J:\<span class="hljs-keyword">go</span>-project\id-maker\internal\usecase\interfaces.<span class="hljs-keyword">go</span> -destination=J:\<span class="hljs-keyword">go</span>-project\id-maker\internal\usecase\mock_test.<span class="hljs-keyword">go</span> -<span class="hljs-keyword">package</span>=usecase_testPS J:\<span class="hljs-keyword">go</span>-project\id-maker\internal\usecase&gt;</code></pre></div><p><img src="/public/img/image-20230424225642591.png" alt="image-20230424225642591"></p><p><a href="https://github.com/golang/mock/issues/665">参考</a></p><h1 id="单元测试-断言"><a href="#单元测试-断言" class="headerlink" title="单元测试-断言"></a>单元测试-断言</h1><p>“Go不提供断言，我们知道这会带来一定的不便，其主要目的是为了防止你们这些程序员在错误处理上偷懒。我们知道这是一个争论点，但是我们觉得这样很coooool~~。”所以，我们引入断言库的原因也很明显了：偷懒，引入断言能为我们提供便利——提高测试效率，增强代码可读性。</p><p>在断言库的选择上，我们似乎没有过多的选择，从start数和活跃度来看，基本上是<a href="https://link.juejin.cn/?target=https://github.com/stretchr/testify">testify</a>一枝独秀。</p><p>没有对比就没有伤害，先来看看使用<code>testify</code>之前的测试方法：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestSomeFun</span><span class="hljs-params">(t *testing.T)</span></span>&#123;...    <span class="hljs-keyword">if</span> v != want &#123;        t.Fatalf(<span class="hljs-string">&quot;v值错误，期望值：%s，实际值：%s&quot;</span>, want, v)    &#125;    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;        t.Fatalf(<span class="hljs-string">&quot;非预期的错误：%s&quot;</span>, err)    &#125;    <span class="hljs-keyword">if</span> objectA != objectB &#123;        <span class="hljs-keyword">if</span> objectA.field1 !=  objectB.field1 &#123;            <span class="hljs-comment">// t.Fatalf() field1值错误...bla bla bla</span>        &#125;         <span class="hljs-keyword">if</span> objectA.field2 !=  objectB.field2 &#123;            <span class="hljs-comment">// t.Fatalf() field2值错误...bla bla bla</span>        &#125;        <span class="hljs-comment">// 遍历object所有值... bla bla bla</span>    &#125;...&#125;</code></pre></div><p>上述代码充斥着大量<code>if...else..</code>判断，大段错误信息拼装（真·体力活…），运气不好碰到结构体判断要得将其遍历一遍——不直观，低效，实在是不fashion。<br>现在，我们使用<code>testify</code>来改造一下上面的测试示例：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestSomeFun</span><span class="hljs-params">(t *testing.T)</span></span>&#123;    a := assert.New(t)...    a.Equal(v, want)    a.Nil(err,<span class="hljs-string">&quot;如果你还是想输出自己拼装的错误信息，可以传第三个参数&quot;</span>)    a.Equal(objectA, objectB)...&#125;</code></pre></div><p>三行搞定，测试含义一目了然——直观，高效，简短，fashion。</p><h1 id="单元测试httptest的使用"><a href="#单元测试httptest的使用" class="headerlink" title="单元测试httptest的使用"></a>单元测试httptest的使用</h1><p>现在有一个需求那就是，我们需要使用Golang的net&#x2F;http包中的http.Get(url)方法去向服务器端请求数据，但是负责服务端的同事并没有将接口实现（可能是同事太忙，把妹，喝酒，扯淡， XO等等）以至于你只知道返回数据的json格式，然而无法请求到真实的数据，但是你的工作进度并不能因为同事而耽误，需要测试你的代码的正确性，那么怎么办？办法就是通过单元测试中的httptest，实现http server，并设置好返回值，那么http.Get(url)的请求就会直接打到单元测试的http server上，同时得到你设置好的返回值，你就可以继续去处理数据，测试你的代码逻辑了。</p><p><a href="https://blog.csdn.net/lavorange/article/details/73369153">参考博客</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Etcd服务发现与注册、自定义负载均衡</title>
    <link href="/2023/11/05/Etcd%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/"/>
    <url>/2023/11/05/Etcd%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Etcd服务发现与注册、自定义负载均衡"><a href="#Etcd服务发现与注册、自定义负载均衡" class="headerlink" title="Etcd服务发现与注册、自定义负载均衡"></a>Etcd服务发现与注册、自定义负载均衡</h1><h2 id="1、什么是服务发现与注册"><a href="#1、什么是服务发现与注册" class="headerlink" title="1、什么是服务发现与注册"></a>1、什么是服务发现与注册</h2><p>服务注册和发现的基本原理如下：<img src="https://pic4.zhimg.com/80/v2-ef494d4338d0bee2719095ed997cc79f_1440w.webp" alt="服务注册和发现"></p><p><strong>服务注册</strong></p><p>指服务实例启动的时候将自身的信息注册到服务注册与发现中心，并在运行的时候通过心跳的方式向服务注册发现中心汇报自身服务状态</p><p><strong>服务发现</strong></p><p>指服务实例向服务注册与发现中心获取的其他服务实例信息，用于进行后续的远程调用。</p><h2 id="2、服务注册和发现的作用"><a href="#2、服务注册和发现的作用" class="headerlink" title="2、服务注册和发现的作用"></a>2、服务注册和发现的作用</h2><p>1、管理实例信息</p><p>管理当前注册到服务注册与发现中心的微服务实例元数据信息，这些信息包括服务实例的服务名，IP地址，端口号，服务状态和服务描述等等信息</p><p>2、健康检查</p><p>服务注册与发现中心会与已经注册 ok 的微服务实例维持心跳，定期检查注册表中的服务是否正常在线，并且会在过程中剔除掉无效的服务实例信息</p><p>3、提供服务发现的作用</p><p>服务发现是指在分布式系统中自动发现和识别服务实例的过程。在一个典型的分布式应用中，服务通常被拆分成多个小的、可伸缩的服务实例，这些实例可能被部署在不同的物理机器或容器中。服务发现可以帮助应用程序识别它所依赖的服务实例的位置和状态，并在需要的时候自动连接到这些服务。</p><p>服务发现通常包括两个主要组件：服务注册和服务发现。服务注册是指服务实例向服务注册中心注册自己的信息，包括服务名称、IP地址、端口号、协议类型等。服务注册中心将这些信息存储下来，供其他服务或客户端查询。服务发现是指服务实例或客户端查询服务注册中心，以获取服务实例的信息。查询可以按服务名称、标签等方式进行，服务发现返回匹配的服务实例列表，客户端根据这些信息与服务实例建立连接。</p><p>如一个服务需要调用服务注册与发现中心中的微服务实例，可以通过<strong>服务注册与发现中心</strong>获取到其具体的服务实例信息</p><h2 id="3、ETCD"><a href="#3、ETCD" class="headerlink" title="3、ETCD"></a>3、ETCD</h2><p>ETCD 一个开源的、高可用的分布式key-value存储系统，可以用于配置共享和服务的注册和发现，它专注于：</p><ul><li>简单：定义清晰、面向用户的API（gRPC）</li><li>安全：可选的客户端TLS证书自动认证</li><li>快速：支持每秒10,000次写入</li><li>可靠：基于Raft算法确保强一致性</li></ul><h5 id="etcd与redis差异"><a href="#etcd与redis差异" class="headerlink" title="etcd与redis差异"></a>etcd与redis差异</h5><p>etcd和redis都支持键值存储，也支持分布式特性，redis支持的数据格式更加丰富，但是他们两个定位和应用场景不一样，关键差异如下：</p><ul><li>redis在分布式环境下不是强一致性的，可能会丢失数据，或者读取不到最新数据</li><li>redis的数据变化监听机制没有etcd完善</li><li>etcd强一致性保证数据可靠性，导致性能上要低于redis</li><li>etcd和ZooKeeper是定位类似的项目，跟redis定位不一样</li></ul><h5 id="为什么用-etcd-而不用ZooKeeper？"><a href="#为什么用-etcd-而不用ZooKeeper？" class="headerlink" title="为什么用 etcd 而不用ZooKeeper？"></a>为什么用 etcd 而不用ZooKeeper？</h5><p>相较之下，ZooKeeper有如下缺点：</p><ul><li><code>复杂</code>：ZooKeeper的部署维护复杂，管理员需要掌握一系列的知识和技能；而 Paxos 强一致性算法也是素来以复杂难懂而闻名于世；另外，ZooKeeper的使用也比较复杂，需要安装客户端，官方只提供了 Java 和 C 两种语言的接口。</li><li><code>难以维护</code>：Java 编写。这里不是对 Java 有偏见，而是 Java 本身就偏向于重型应用，它会引入大量的依赖。而运维人员则普遍希望保持强一致、高可用的机器集群尽可能简单，维护起来也不易出错。</li><li><code>发展缓慢</code>：Apache 基金会项目特有的“Apache Way”在开源界饱受争议，其中一大原因就是由于基金会庞大的结构以及松散的管理导致项目发展缓慢。</li></ul><p><strong>使用etcd进行服务注册与健康检查</strong></p><p>根据etcd的<code>v3 API</code>，当启动一个服务时候，我们把服务的地址写进etcd，注册服务。同时绑定租约（lease），并以续租约（keep leases alive）的方式检测服务是否正常运行，从而实现健康检查。</p><p>我们先定义服务包，用于描述服务信息、定义工具函数-根据服务信息生成前缀等。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> etcd<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;encoding/json&quot;</span><span class="hljs-string">&quot;errors&quot;</span><span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;strings&quot;</span><span class="hljs-string">&quot;google.golang.org/grpc/resolver&quot;</span>)<span class="hljs-keyword">type</span> Server <span class="hljs-keyword">struct</span> &#123;Name    <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;name&quot;`</span>Addr    <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;addr&quot;`</span>    <span class="hljs-comment">//服务地址</span>Version <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;version&quot;`</span> <span class="hljs-comment">//服务版本</span>Weight  <span class="hljs-type">int64</span>  <span class="hljs-string">`json:&quot;weight&quot;`</span>  <span class="hljs-comment">//服务权重</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BuildPrefix</span><span class="hljs-params">(info *Server)</span></span> <span class="hljs-type">string</span> &#123;<span class="hljs-keyword">if</span> info.Version == <span class="hljs-string">&quot;&quot;</span> &#123;<span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;/%s/&quot;</span>, info.Name)&#125;<span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;/%s/%s/&quot;</span>, info.Name, info.Addr)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BuildRegPath</span><span class="hljs-params">(info *Server)</span></span> <span class="hljs-type">string</span> &#123;<span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;%s%s&quot;</span>, BuildPrefix(info), info.Addr)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ParseValue</span><span class="hljs-params">(value []<span class="hljs-type">byte</span>)</span></span> (*Server, <span class="hljs-type">error</span>) &#123;info := &amp;Server&#123;&#125;<span class="hljs-keyword">if</span> err := json.Unmarshal(value, &amp;info); err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> info, err&#125;<span class="hljs-keyword">return</span> info, <span class="hljs-literal">nil</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SplitPath</span><span class="hljs-params">(path <span class="hljs-type">string</span>)</span></span> (*Server, <span class="hljs-type">error</span>) &#123;info := &amp;Server&#123;&#125;strs := strings.Split(path, <span class="hljs-string">&quot;/&quot;</span>)<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(strs) == <span class="hljs-number">0</span> &#123;<span class="hljs-keyword">return</span> info, errors.New(<span class="hljs-string">&quot;invalid path&quot;</span>)&#125;info.Addr = strs[<span class="hljs-built_in">len</span>(strs)<span class="hljs-number">-1</span>]<span class="hljs-keyword">return</span> info, <span class="hljs-literal">nil</span>&#125;<span class="hljs-comment">// Exist helper function</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Exist</span><span class="hljs-params">(l []resolver.Address, addr resolver.Address)</span></span> <span class="hljs-type">bool</span> &#123;<span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> l &#123;<span class="hljs-keyword">if</span> l[i].Addr == addr.Addr &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>&#125;<span class="hljs-comment">// Remove helper function</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Remove</span><span class="hljs-params">(s []resolver.Address, addr resolver.Address)</span></span> ([]resolver.Address, <span class="hljs-type">bool</span>) &#123;<span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> s &#123;<span class="hljs-keyword">if</span> s[i].Addr == addr.Addr &#123;s[i] = s[<span class="hljs-built_in">len</span>(s)<span class="hljs-number">-1</span>]<span class="hljs-keyword">return</span> s[:<span class="hljs-built_in">len</span>(s)<span class="hljs-number">-1</span>], <span class="hljs-literal">true</span>&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">false</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BuildResolverUrl</span><span class="hljs-params">(app <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<span class="hljs-keyword">return</span> schema + <span class="hljs-string">&quot;:///&quot;</span> + app&#125;</code></pre></div><p>服务端的主要步骤如下：</p><ul><li>创建gprc服务端</li><li>将grpc服务端的ip和port等信息作为value，服务名（自己取，如：&#x2F;ns&#x2F;cloud-service-1）作为key，put到etcd中</li></ul><p>由于服务端无法保证自身是一直可用的，可能会宕机，所以etcd的租约是有时间限制的，租约一旦过期，服务端存储在etcd上的服务信息就会消失。</p><p>另一方面，如果服务端是正常运行的，etcd中的地址信息又必须存在，因此发送心跳检测，一旦发现etcd上没有自己的服务地址时，请求重新添加（续租）。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> etcd<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;context&quot;</span><span class="hljs-string">&quot;encoding/json&quot;</span><span class="hljs-string">&quot;errors&quot;</span><span class="hljs-string">&quot;net/http&quot;</span><span class="hljs-string">&quot;strconv&quot;</span><span class="hljs-string">&quot;strings&quot;</span><span class="hljs-string">&quot;time&quot;</span>clientv3 <span class="hljs-string">&quot;go.etcd.io/etcd/client/v3&quot;</span><span class="hljs-string">&quot;go.uber.org/zap&quot;</span>)<span class="hljs-comment">// Register for grpc server</span><span class="hljs-keyword">type</span> Register <span class="hljs-keyword">struct</span> &#123;EtcdAddrs   []<span class="hljs-type">string</span>DialTimeout <span class="hljs-type">int</span>ctx    context.Contextcancel context.CancelFuncleasesID    clientv3.LeaseIDkeepAliveCh &lt;-<span class="hljs-keyword">chan</span> *clientv3.LeaseKeepAliveResponsesrvInfo *ServersrvTTL  <span class="hljs-type">int64</span>cli     *clientv3.Clientlogger  *zap.Logger&#125;<span class="hljs-comment">// NewRegister create a register base on etcd</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewRegister</span><span class="hljs-params">(etcdAddrs []<span class="hljs-type">string</span>, looger *zap.Logger)</span></span> *Register &#123;<span class="hljs-keyword">return</span> &amp;Register&#123;EtcdAddrs:   etcdAddrs,DialTimeout: <span class="hljs-number">3</span>,logger:      looger,&#125;&#125;<span class="hljs-comment">// Register a service</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *Register)</span></span> Register(srvInfo *Server, ttl <span class="hljs-type">int64</span>) (context.CancelFunc, <span class="hljs-type">error</span>) &#123;<span class="hljs-keyword">var</span> err <span class="hljs-type">error</span><span class="hljs-keyword">if</span> strings.Split(srvInfo.Addr, <span class="hljs-string">&quot;:&quot;</span>)[<span class="hljs-number">0</span>] == <span class="hljs-string">&quot;&quot;</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, errors.New(<span class="hljs-string">&quot;invalid ip&quot;</span>)&#125;<span class="hljs-keyword">if</span> r.cli, err = clientv3.New(clientv3.Config&#123;Endpoints:   r.EtcdAddrs,DialTimeout: time.Duration(r.DialTimeout) * time.Second,&#125;); err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err&#125;r.srvInfo = srvInfor.srvTTL = ttl<span class="hljs-keyword">if</span> err = r.register(); err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err&#125;<span class="hljs-keyword">go</span> r.KeepAlive()<span class="hljs-keyword">return</span> r.cancel, <span class="hljs-literal">nil</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *Register)</span></span> register() <span class="hljs-type">error</span> &#123;leaseCtx, cancel := context.WithCancel(context.Background())<span class="hljs-comment">//leaseCtx, cancel := context.WithTimeout(context.Background(), time.Duration(r.DialTimeout)*time.Second)</span>r.ctx = leaseCtxr.cancel = cancelleaseResp, err := r.cli.Grant(leaseCtx, r.srvTTL)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> err&#125;r.leasesID = leaseResp.ID<span class="hljs-keyword">if</span> r.keepAliveCh, err = r.cli.KeepAlive(r.ctx, leaseResp.ID); err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> err&#125;data, err := json.Marshal(r.srvInfo)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> err&#125;_, err = r.cli.Put(r.ctx, BuildRegPath(r.srvInfo), <span class="hljs-type">string</span>(data), clientv3.WithLease(r.leasesID))<span class="hljs-keyword">return</span> err&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *Register)</span></span> unregister() <span class="hljs-type">error</span> &#123;_, err := r.cli.Delete(r.ctx, BuildRegPath(r.srvInfo))<span class="hljs-keyword">return</span> err&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *Register)</span></span> KeepAlive() &#123;ticker := time.NewTicker(time.Duration(r.srvTTL) * time.Second)<span class="hljs-keyword">for</span> &#123;<span class="hljs-keyword">select</span> &#123;<span class="hljs-keyword">case</span> &lt;-r.ctx.Done():<span class="hljs-keyword">if</span> err := r.unregister(); err != <span class="hljs-literal">nil</span> &#123;r.logger.Error(<span class="hljs-string">&quot;unregister failed&quot;</span>, zap.Error(err))&#125;<span class="hljs-keyword">if</span> _, err := r.cli.Revoke(r.ctx, r.leasesID); err != <span class="hljs-literal">nil</span> &#123;r.logger.Error(<span class="hljs-string">&quot;revoke failed&quot;</span>, zap.Error(err))&#125;<span class="hljs-keyword">return</span><span class="hljs-keyword">case</span> res := &lt;-r.keepAliveCh:<span class="hljs-comment">// 发现etcd上没有自己的服务地址,请求重新添加（续租）</span><span class="hljs-keyword">if</span> res == <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">if</span> err := r.register(); err != <span class="hljs-literal">nil</span> &#123;r.logger.Error(<span class="hljs-string">&quot;register failed&quot;</span>, zap.Error(err))&#125;&#125;<span class="hljs-keyword">case</span> &lt;-ticker.C:<span class="hljs-keyword">if</span> r.keepAliveCh == <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">if</span> err := r.register(); err != <span class="hljs-literal">nil</span> &#123;r.logger.Error(<span class="hljs-string">&quot;register failed&quot;</span>, zap.Error(err))&#125;&#125;&#125;&#125;&#125;<span class="hljs-comment">// UpdateHandler return http handler</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *Register)</span></span> UpdateHandler() http.HandlerFunc &#123;<span class="hljs-keyword">return</span> http.HandlerFunc(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;wi := req.URL.Query().Get(<span class="hljs-string">&quot;weight&quot;</span>)weight, err := strconv.Atoi(wi)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;w.WriteHeader(http.StatusBadRequest)w.Write([]<span class="hljs-type">byte</span>(err.Error()))<span class="hljs-keyword">return</span>&#125;<span class="hljs-keyword">var</span> update = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> &#123;r.srvInfo.Weight = <span class="hljs-type">int64</span>(weight)data, err := json.Marshal(r.srvInfo)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> err&#125;_, err = r.cli.Put(r.ctx, BuildRegPath(r.srvInfo), <span class="hljs-type">string</span>(data), clientv3.WithLease(r.leasesID))<span class="hljs-keyword">return</span> err&#125;<span class="hljs-keyword">if</span> err := update(); err != <span class="hljs-literal">nil</span> &#123;w.WriteHeader(http.StatusInternalServerError)w.Write([]<span class="hljs-type">byte</span>(err.Error()))<span class="hljs-keyword">return</span>&#125;w.Write([]<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;update server weight success&quot;</span>))&#125;)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *Register)</span></span> GetServerInfo() (*Server, <span class="hljs-type">error</span>) &#123;resp, err := r.cli.Get(r.ctx, BuildRegPath(r.srvInfo))<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> r.srvInfo, err&#125;info := &amp;Server&#123;&#125;<span class="hljs-keyword">if</span> resp.Count &gt;= <span class="hljs-number">1</span> &#123;<span class="hljs-keyword">if</span> err := json.Unmarshal(resp.Kvs[<span class="hljs-number">0</span>].Value, &amp;info); err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> info, err&#125;&#125;<span class="hljs-keyword">return</span> info, <span class="hljs-literal">nil</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *Register)</span></span> Close() &#123;r.cancel()&#125;</code></pre></div><p>我们封装好注册服务器之后，我们需要在启动grpc服务时调用，下面的代码就是将一个grpc服务注册到etcd中。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;mini_tiktok/etcd&quot;</span><span class="hljs-string">&quot;mini_tiktok/internal/initialize&quot;</span><span class="hljs-string">&quot;mini_tiktok/internal/rpc/client&quot;</span>authService <span class="hljs-string">&quot;mini_tiktok/internal/rpc/rpcGen/auth&quot;</span><span class="hljs-string">&quot;net&quot;</span><span class="hljs-string">&quot;google.golang.org/grpc&quot;</span><span class="hljs-string">&quot;go.uber.org/zap&quot;</span>)<span class="hljs-keyword">const</span> Network = <span class="hljs-string">&quot;tcp&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;serverInfo := &amp;etcd.Server&#123;Name:    <span class="hljs-string">&quot;user-service-1&quot;</span>,Addr:    <span class="hljs-string">&quot;127.0.0.1:8889&quot;</span>,Version: <span class="hljs-string">&quot;v1&quot;</span>,Weight:  <span class="hljs-number">6</span>,&#125;listener, err := net.Listen(Network, serverInfo.Addr)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;initialize.Log.Fatal(<span class="hljs-string">&quot;net.Listen err: %v&quot;</span>, zap.Error(err))&#125;<span class="hljs-comment">// 创建注册器</span>etcdRegister := etcd.NewRegister(initialize.Conf.EtcdConfig.Addrs, initialize.Log)<span class="hljs-keyword">defer</span> etcdRegister.Close()    <span class="hljs-comment">// 注册服务</span>_, err = etcdRegister.Register(serverInfo, <span class="hljs-number">3</span>)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;initialize.Log.Fatal(<span class="hljs-string">&quot;register Server to etcd failed: %v&quot;</span>, zap.Error(err))&#125;<span class="hljs-comment">// 新建gRPC服务器实例</span>grpcServer := grpc.NewServer()<span class="hljs-comment">// 在gRPC服务器注册我们的服务</span>authService.RegisterAuthServiceServer(grpcServer, &amp;client.AuthService&#123;&#125;)<span class="hljs-comment">//用服务器 Serve() 方法以及我们的端口信息区实现阻塞等待，直到进程被杀死或者 Stop() 被调用</span>err = grpcServer.Serve(listener)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;initialize.Log.Fatal(<span class="hljs-string">&quot;grpcServer.Serve err: %v&quot;</span>, zap.Error(err))&#125;&#125;</code></pre></div><p><strong>使用etcd实现服务发现</strong></p><p>首先我们先来了解一下Name Resolution流程</p><p>gRPC resolver 包定义了两个接口  Resolver和 Bulider。我们需要自定义代码实现两个接口。其中Resolver的实现是整个功能最核心的代码，需要将服务名解析为对应的实例。而后者的实现者需要创建并注册一个Bulider实例。这样，当客户端在调用Dial方法对指定的服务拨号时，grpc resolver查找注册的Builder实例调用其build()方法构建自定义的Resolver实例。其中Build()方法的作用就是创建一个Resolver实例。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy81V1hFdUdZWklpYkNkTGdoczF5NzVUaWFsTm9odjFUOFQ1aWEwQ1NuaWJBaWF6S2huMXJlT2RhUWljNUdFQXN5VmtrcEFta05wUnZZQ3NWSHU3TFkxS3RTMjhXdy82NDA?x-oss-process=image/format,png" alt="Resolver流程"></p><p>下面是gprc Resolver的整个详细流程</p><ul><li><p>客户端启动时，引入自定义的 resolver 包（比如本例中我们自定义的 ns 包）</p><ul><li>引入 ns 包，在 init() 阶段，构造自定义的 resolveBuilder，并将其注册到 grpc 内部的 resolveBuilder 表中（其实是一个全局 map，key 为协议名，比如 ns；value 为构造的 resolveBuilder，比如 nsResolverBuilder）。</li></ul></li><li><p>客户端启动时通过自定义 Dail() 方法构造 grpc.ClientConn 单例</p><ul><li>grpc.DialContext() 方法内部解析 URI，分析协议类型，并从 resolveBuilder 表中查找协议对应的 resolverBuilder。比如本例中我们定义的 URI 协议类型为 ns，对应的 resolverBuilder 为 nsResolverBuilder</li><li>找到指定的 resolveBuilder 后，调用 resolveBuilder 的 Build() 方法，构建自定义 resolver，同时开启协程，通过此 resolver 更新被调服务实例列表。</li><li>Dial() 方法接收主调服务名和被调服务名，并根据自定义的协议名，基于这两个参数构造服务的 URI</li><li>Dial() 方法内部使用构造的 URI，调用 grpc.DialContext() 方法对指定服务进行拨号</li></ul></li><li><p>grpc 底层 LB 库对每个实例均创建一个 subConnection，最终根据相应的 LB 策略，选择合适的 subConnection 处理某次 RPC 请求。</p></li></ul><p>grpc客户端为我们提供了实现服务发现和负载均衡的钩子，下面是实现服务发现的源码。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> etcd<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;context&quot;</span><span class="hljs-string">&quot;time&quot;</span><span class="hljs-string">&quot;go.etcd.io/etcd/api/v3/mvccpb&quot;</span>clientv3 <span class="hljs-string">&quot;go.etcd.io/etcd/client/v3&quot;</span><span class="hljs-string">&quot;go.uber.org/zap&quot;</span><span class="hljs-string">&quot;google.golang.org/grpc/resolver&quot;</span>)<span class="hljs-keyword">const</span> (schema = <span class="hljs-string">&quot;etcd&quot;</span>)<span class="hljs-comment">// Resolver for grpc client</span><span class="hljs-keyword">type</span> Resolver <span class="hljs-keyword">struct</span> &#123;schema      <span class="hljs-type">string</span>EtcdAddrs   []<span class="hljs-type">string</span>DialTimeout <span class="hljs-type">int</span>ctx    context.Contextcancel context.CancelFuncwatchCh      clientv3.WatchChancli          *clientv3.ClientkeyPrifix    <span class="hljs-type">string</span>srvAddrsList []resolver.Addresscc     resolver.ClientConnlogger *zap.Logger&#125;<span class="hljs-comment">// NewResolver create a new resolver.Builder base on etcd</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewResolver</span><span class="hljs-params">(etcdAddrs []<span class="hljs-type">string</span>, logger *zap.Logger)</span></span> *Resolver &#123;<span class="hljs-keyword">return</span> &amp;Resolver&#123;schema:      schema,EtcdAddrs:   etcdAddrs,DialTimeout: <span class="hljs-number">3</span>,logger:      logger,&#125;&#125;<span class="hljs-comment">// Scheme returns the scheme supported by this resolver.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *Resolver)</span></span> Scheme() <span class="hljs-type">string</span> &#123;<span class="hljs-keyword">return</span> r.schema&#125;<span class="hljs-comment">// Build creates a new resolver.Resolver for the given target</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *Resolver)</span></span> Build(target resolver.Target, cc resolver.ClientConn, opts resolver.BuildOptions) (resolver.Resolver, <span class="hljs-type">error</span>) &#123;r.cc = ccr.keyPrifix = BuildPrefix(&amp;Server&#123;Name: target.Endpoint, Version: target.Authority&#125;)<span class="hljs-keyword">if</span> _, err := r.start(); err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err&#125;<span class="hljs-keyword">return</span> r, <span class="hljs-literal">nil</span>&#125;<span class="hljs-comment">// ResolveNow resolver.Resolver interface</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *Resolver)</span></span> ResolveNow(o resolver.ResolveNowOptions) &#123;&#125;<span class="hljs-comment">// Close resolver.Resolver interface</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *Resolver)</span></span> Close() &#123;r.cancel()&#125;<span class="hljs-comment">// start</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *Resolver)</span></span> start() (context.CancelFunc, <span class="hljs-type">error</span>) &#123;<span class="hljs-keyword">var</span> err <span class="hljs-type">error</span>r.cli, err = clientv3.New(clientv3.Config&#123;Endpoints:   r.EtcdAddrs,DialTimeout: time.Duration(r.DialTimeout) * time.Second,&#125;)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err&#125;resolver.Register(r)r.ctx, r.cancel = context.WithCancel(context.Background())<span class="hljs-keyword">if</span> err = r.sync(); err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err&#125;<span class="hljs-keyword">go</span> r.watch()<span class="hljs-keyword">return</span> r.cancel, <span class="hljs-literal">nil</span>&#125;<span class="hljs-comment">// watch update events</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *Resolver)</span></span> watch() &#123;ticker := time.NewTicker(time.Minute)r.watchCh = r.cli.Watch(r.ctx, r.keyPrifix, clientv3.WithPrefix())<span class="hljs-keyword">for</span> &#123;<span class="hljs-keyword">select</span> &#123;<span class="hljs-keyword">case</span> &lt;-r.ctx.Done():<span class="hljs-keyword">return</span><span class="hljs-keyword">case</span> res, ok := &lt;-r.watchCh:<span class="hljs-keyword">if</span> ok &#123;r.update(res.Events)&#125;<span class="hljs-keyword">case</span> &lt;-ticker.C:<span class="hljs-keyword">if</span> err := r.sync(); err != <span class="hljs-literal">nil</span> &#123;r.logger.Error(<span class="hljs-string">&quot;sync failed&quot;</span>, zap.Error(err))&#125;&#125;&#125;&#125;<span class="hljs-comment">// update</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *Resolver)</span></span> update(events []*clientv3.Event) &#123;<span class="hljs-keyword">for</span> _, ev := <span class="hljs-keyword">range</span> events &#123;<span class="hljs-keyword">var</span> info *Server<span class="hljs-keyword">var</span> err <span class="hljs-type">error</span><span class="hljs-keyword">switch</span> ev.Type &#123;<span class="hljs-keyword">case</span> mvccpb.PUT:info, err = ParseValue(ev.Kv.Value)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">continue</span>&#125;addr := resolver.Address&#123;Addr: info.Addr, Metadata: info.Weight&#125;<span class="hljs-keyword">if</span> !Exist(r.srvAddrsList, addr) &#123;r.srvAddrsList = <span class="hljs-built_in">append</span>(r.srvAddrsList, addr)r.cc.UpdateState(resolver.State&#123;Addresses: r.srvAddrsList&#125;)&#125;<span class="hljs-keyword">case</span> mvccpb.DELETE:info, err = SplitPath(<span class="hljs-type">string</span>(ev.Kv.Key))<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">continue</span>&#125;addr := resolver.Address&#123;Addr: info.Addr&#125;<span class="hljs-keyword">if</span> s, ok := Remove(r.srvAddrsList, addr); ok &#123;r.srvAddrsList = sr.cc.UpdateState(resolver.State&#123;Addresses: r.srvAddrsList&#125;)&#125;&#125;&#125;&#125;<span class="hljs-comment">// sync 同步获取所有地址信息</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *Resolver)</span></span> sync() <span class="hljs-type">error</span> &#123;ctx, cancel := context.WithTimeout(r.ctx, <span class="hljs-number">3</span>*time.Second)<span class="hljs-keyword">defer</span> cancel()res, err := r.cli.Get(ctx, r.keyPrifix, clientv3.WithPrefix())<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> err&#125;r.srvAddrsList = []resolver.Address&#123;&#125;<span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> res.Kvs &#123;info, err := ParseValue(v.Value)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">continue</span>&#125;addr := resolver.Address&#123;Addr: info.Addr, Metadata: info.Weight&#125;r.srvAddrsList = <span class="hljs-built_in">append</span>(r.srvAddrsList, addr)&#125;r.cc.UpdateState(resolver.State&#123;Addresses: r.srvAddrsList&#125;)<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>&#125;</code></pre></div><p>客户端使用服务注册的代码如下</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> FeedClient feedService.FeedServiceClient<span class="hljs-comment">//const feed_address = &quot;127.0.0.1:8890&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-comment">// 注册自定义的ETCD解析器</span>etcdResolverBuilder := etcd.NewResolver([]<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;127.0.0.1:2379&quot;</span>&#125;, initialize.Log)resolver.Register(etcdResolverBuilder)<span class="hljs-comment">// 连接服务器</span>conn, err := grpc.Dial(etcdResolverBuilder.Scheme()+<span class="hljs-string">&quot;:///feed-service-1&quot;</span>, grpc.WithTransportCredentials(insecure.NewCredentials()))<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;log.Fatalf(<span class="hljs-string">&quot;net.Connect err: %v&quot;</span>, err)&#125;<span class="hljs-keyword">defer</span> conn.Close()<span class="hljs-comment">// 建立gRPC连接</span>FeedClient = feedService.NewFeedServiceClient(conn)        <span class="hljs-comment">// client调用服务</span>    <span class="hljs-comment">// ......</span>&#125;</code></pre></div><h2 id="4、负载均衡"><a href="#4、负载均衡" class="headerlink" title="4、负载均衡"></a>4、负载均衡</h2><p>为了提高系统的负载能力和稳定性，我们的服务端往往具有多台服务器，负载均衡的目的就是希望请求能分散到不同的服务器，从服务器列表中选择一台服务器的算法就是负载均衡的策略，常见的轮循、加权轮询等</p><p>负载均衡器要在多台服务器之间选择，所以通常情况下负载均衡器是具备服务发现的能力的</p><h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><p>根据负载均衡实现所在的位置不同，通常可分为以下三种解决方案：</p><p><strong>1、集中式负载均衡（Proxy Model）</strong></p><p>在客户端和服务端之间有一个独立的LB，通常是专门的硬件设备如 F5，或者基于软件如 LVS，HAproxy，Nginx等实现。LB使用负载均衡策略将请求转发到目标服务</p><p>这种做法的缺点也很明显，所有的服务调用流量都会经过LB，当服务数量和调用量大的时候，LB就会成为瓶颈。一旦LB故障就会影响整个系统。而且在服务端和客户端之间增加一级，有一定的性能开销。</p><p><img src="/pic/16.png" alt="集中式负载均衡"></p><p><strong>2、客户端负载均衡（Balancing-aware Client）</strong></p><p>将LB的功能集中到客户端进程中，然后使用负载均衡策略选择一个目标服务地址，向目标发起请求。LB能力被分散到每一个服务消费者的进程内部，同时服务消费方和服务提供方之间是直接调用，没有额外的开销，性泵较好。</p><p>缺点，但是如果有多种不同的语言栈，就要配合开发不同的客户端，有一定的研发和维护成本；后续如果要对客户库进行升级，势必要求服务调用方修改代码并重新发布，实际比较麻烦。</p><p><img src="/pic/17.png" alt="客户端负载均衡"></p><p><strong>3、独立负载均衡进程（External Load Balancing Service）</strong></p><p>将LB从进程内移出来，变成主机上的一个独立进程。主机上的一个或者多个服务要访问目标服务时，他们都通过同一主机上的独立LB进程做负载均衡</p><p>此方案有两种模式</p><p>第一种是直接由LB进行转发请求，被称为sidecar方案</p><p>第二种是从LB获取到IP后依旧由客户端发起请求，gRPC曾经支持过此方案叫lookaside方案，目前已废弃</p><p>该方案也是一种分布式方案没有单点问题，一个LB进程挂了只影响该主机上的客户端；客户端和LB之间是本地调用调用性能好；同时该方案还简化了客户端，不需要为不同语言开发客户库，LB的升级不需要服务调用方改代码。该方案主要问题：部署较复杂，环节多，出错调试排查问题不方便</p><p><img src="/pic/18.png" alt="独立负载均衡进程"></p><h3 id="gRPC的负载均衡"><a href="#gRPC的负载均衡" class="headerlink" title="gRPC的负载均衡"></a>gRPC的负载均衡</h3><p>gRPC中的负载平衡是以每次调用为基础，而不是以每个连接为基础。换句话说，即使所有的请求都来自一个客户端，它仍能在所有的服务器上实现负载平衡</p><p><strong>gRPC目前内置四种策略</strong></p><p>pick_first：默认策略，选择第一个</p><p>round_robin：轮询</p><p>使用默认的负载均衡器很简单，只需要在建立连接的时候指定负载均衡策略即可。</p><p><strong>但是要注意</strong>：旧版本gRPC使用 <code>grpc.WithBalancerName(&quot;round_robin&quot;)</code>,已经被废弃，需要使用<code>grpc.WithDefaultServiceConfig</code>。<code>grpc.WithDefaultServiceConfig</code>可以被上文服务发现中提到的cc.UpdateState(State) error覆盖配置</p><div class="code-wrapper"><pre><code class="hljs go">conn, err := grpc.Dial(<span class="hljs-string">&quot;example:cluster@callee&quot;</span>,  grpc.WithInsecure(),  grpc.WithDefaultServiceConfig(   <span class="hljs-string">`&#123;&quot;loadBalancingPolicy&quot;:&quot;round_robin&quot;&#125;`</span>,  ), )</code></pre></div><p>grpclb：已废弃不做介绍</p><p>xDS</p><p>xDS 在服务端实现服务发现，配置负载均衡策略等。支持xDS的客户端连接到xDS 服务端并通过xDS api来获取各种需要的数据和配置。</p><p><img src="/pic/19.png" alt="servicemesh的负载均衡"></p><h3 id="自定义负载均衡器"><a href="#自定义负载均衡器" class="headerlink" title="自定义负载均衡器"></a>自定义负载均衡器</h3><p>自定义负载均衡器需要使用google.golang.org&#x2F;grpc&#x2F;balancer.Register提前注册，此函数和服务发现一样接受工厂函数</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// Builder creates a balancer.</span><span class="hljs-keyword">type</span> Builder <span class="hljs-keyword">interface</span> &#123; <span class="hljs-comment">// Build creates a new balancer with the ClientConn.</span> Build(cc ClientConn, opts BuildOptions) Balancer <span class="hljs-comment">// Name returns the name of balancers built by this builder.</span> <span class="hljs-comment">// It will be used to pick balancers (for example in service config).</span> Name() <span class="hljs-type">string</span>&#125;</code></pre></div><p><code>Name()</code>是负载均衡策略的名字</p><p><code>Build(...)</code>需要返回负载均衡器</p><p> <code>cc ClientConn</code>代表客户端与服务端的连接，其拥有一系列函数可以让我们更新链接的状态</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Balancer <span class="hljs-keyword">interface</span> &#123; <span class="hljs-comment">// UpdateClientConnState is called by gRPC when the state of the ClientConn</span> <span class="hljs-comment">// changes.  If the error returned is ErrBadResolverState, the ClientConn</span> <span class="hljs-comment">// will begin calling ResolveNow on the active name resolver with</span> <span class="hljs-comment">// exponential backoff until a subsequent call to UpdateClientConnState</span> <span class="hljs-comment">// returns a nil error.  Any other errors are currently ignored.</span> UpdateClientConnState(ClientConnState) <span class="hljs-type">error</span> <span class="hljs-comment">// ResolverError is called by gRPC when the name resolver reports an error.</span> ResolverError(<span class="hljs-type">error</span>) <span class="hljs-comment">// UpdateSubConnState is called by gRPC when the state of a SubConn</span> <span class="hljs-comment">// changes.</span> UpdateSubConnState(SubConn, SubConnState) <span class="hljs-comment">// Close closes the balancer. The balancer is not required to call</span> <span class="hljs-comment">// ClientConn.RemoveSubConn for its existing SubConns.</span> Close()&#125;</code></pre></div><p><strong>类RR算法负载均衡器</strong></p><p>我们查看round_robin负载均衡的源码的具体实现，</p><p><img src="/pic/12.png" alt="image-20230801223826630"></p><p>roundrobin.go主要实现逻辑总结：</p><ul><li><strong>1. 定义一个负载均衡名称</strong></li></ul><blockquote><p>const Name &#x3D; “round_robin”</p></blockquote><ul><li><strong>2. 定义一个rrPickerBuilder，它只有一个方法：</strong></li></ul><blockquote><p>func (*rrPickerBuilder) Build(info base.PickerBuildInfo) balancer.Picker{…}</p></blockquote><p>rrPickerBuilder实际上是<strong>PikcerBuilder接口的实现：</strong></p><p><strong>下面代码是PickerBuilder 接口</strong></p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// PickerBuilder creates balancer.Picker.</span><span class="hljs-keyword">type</span> PickerBuilder <span class="hljs-keyword">interface</span> &#123;<span class="hljs-comment">// Build returns a picker that will be used by gRPC to pick a SubConn.</span>Build(info PickerBuildInfo) balancer.Picker&#125;</code></pre></div><ul><li><strong>3. 定义一个rrPicker，它也只有一个方法：</strong></li></ul><blockquote><p>func (p *rrPicker) Pick(balancer.PickInfo) (balancer.PickResult, error){…}</p></blockquote><p>rrPicker实际上是<strong>Picker接口的实现：</strong></p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Picker <span class="hljs-keyword">interface</span> &#123;Pick(info PickInfo) (PickResult, <span class="hljs-type">error</span>)&#125;</code></pre></div><ul><li><strong>4. 定义一个newBuild方法用来创建这个策略，定义init方法用来注册创建的策略</strong></li></ul><p><strong>主要方法作用简单说明：</strong></p><ol><li><strong>Build方法：对连接进行使用前的处理，如果本地连接有变化，如调用</strong>UpdateState(State) <strong>会执行一次此方法，如：在Build中我们可以将某个连接复制多份，或者干脆不处理，直接返回</strong></li><li><strong>Pick方法：每次客户端请求服务前会调用Pick方法拿到一个连接，用这个连接去请求</strong></li></ol><p><strong>实现基于权重的的负载均衡策略</strong></p><p>上面我们对roundrobin.go有了一个了解后，就可以开始自定义负载均衡策略：基于权重的负载均衡策略（weight_*load_*balance.go），代码结构预览如下：</p><p><img src="/pic/13.png" alt="image-20230801224602187"></p><p>详细代码如下</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> lb<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;log&quot;</span><span class="hljs-string">&quot;math/rand&quot;</span><span class="hljs-string">&quot;sync&quot;</span><span class="hljs-string">&quot;google.golang.org/grpc/balancer&quot;</span><span class="hljs-string">&quot;google.golang.org/grpc/balancer/base&quot;</span>)<span class="hljs-keyword">const</span> WEIGHT_LOAD_BALANCE = <span class="hljs-string">&quot;weight_lb_picker&quot;</span><span class="hljs-keyword">const</span> MAX_WEIGHT = <span class="hljs-number">10</span> <span class="hljs-comment">// 可设置的最大权重</span><span class="hljs-keyword">const</span> MIN_WEIGHT = <span class="hljs-number">1</span>  <span class="hljs-comment">// 可设置的最小权重</span><span class="hljs-comment">// 注册自定义权重负载均衡器</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newBuilder</span><span class="hljs-params">()</span></span> balancer.Builder &#123;<span class="hljs-keyword">return</span> base.NewBalancerBuilder(WEIGHT_LOAD_BALANCE, &amp;weightPikerBuilder&#123;&#125;, base.Config&#123;HealthCheck: <span class="hljs-literal">true</span>&#125;)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;balancer.Register(newBuilder())&#125;<span class="hljs-keyword">type</span> weightPikerBuilder <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// 根据负载均衡策略 生成重复的连接</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *weightPikerBuilder)</span></span> Build(info base.PickerBuildInfo) balancer.Picker &#123;log.Println(<span class="hljs-string">&quot;weightPikerBuilder build called...&quot;</span>)<span class="hljs-comment">// 没有可用的连接</span><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(info.ReadySCs) == <span class="hljs-number">0</span> &#123;<span class="hljs-keyword">return</span> base.NewErrPicker(balancer.ErrNoSubConnAvailable)&#125;<span class="hljs-comment">// 此处有坑，为什么长度给0,而不是1???</span>scs := <span class="hljs-built_in">make</span>([]balancer.SubConn, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(info.ReadySCs))<span class="hljs-keyword">for</span> subConn, subConnInfo := <span class="hljs-keyword">range</span> info.ReadySCs &#123;<span class="hljs-comment">//v := subConnInfo.Address.BalancerAttributes.Value(WeightAttributeKey&#123;&#125;)</span>w := subConnInfo.Address.Attributes.Value(<span class="hljs-string">&quot;weight&quot;</span>).(<span class="hljs-type">int</span>)<span class="hljs-comment">// 限制可以设置的最大最小权重，防止设置过大创建连接数太多</span><span class="hljs-keyword">if</span> w &lt; MIN_WEIGHT &#123;w = MIN_WEIGHT&#125;<span class="hljs-keyword">if</span> w &gt; MAX_WEIGHT &#123;w = MAX_WEIGHT&#125;<span class="hljs-comment">// 根据权重 创建多个重复的连接 权重越高个数越多</span><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; w; i++ &#123;scs = <span class="hljs-built_in">append</span>(scs, subConn)&#125;&#125;<span class="hljs-keyword">return</span> &amp;weightPiker&#123;scs: scs,&#125;&#125;<span class="hljs-keyword">type</span> weightPiker <span class="hljs-keyword">struct</span> &#123;scs []balancer.SubConnmu  sync.Mutex&#125;<span class="hljs-comment">// 从build方法生成的连接数中选择一个连接返回</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *weightPiker)</span></span> Pick(info balancer.PickInfo) (balancer.PickResult, <span class="hljs-type">error</span>) &#123;<span class="hljs-comment">// 随机选择一个返回，权重越大，生成的连接个数越多，因此，被选中的概率也越大</span>log.Println(<span class="hljs-string">&quot;weightPiker Pick called...&quot;</span>)p.mu.Lock()index := rand.Intn(<span class="hljs-built_in">len</span>(p.scs))sc := p.scs[index]p.mu.Unlock()<span class="hljs-keyword">return</span> balancer.PickResult&#123;SubConn: sc&#125;, <span class="hljs-literal">nil</span>&#125;</code></pre></div><p>既然是基于权重的负载均衡策略，因此，我们在解析IP时需要获取权重值，在获取IP时我们又需要将对应的权重设置到我们的Addr中，通过上一篇将grpc服务注册到etcd中我们知道可以调用discovery包中的updata方法设置地址，因此我们可以在设置地址时增加一些属性，如：权重，下图中的129行代码。</p><p><img src="/pic/14.png" alt="image-20230801231343262"></p><p>使用，在调用Dial函数创建<code>ClientConn</code>连接的时候传入，</p><div class="code-wrapper"><pre><code class="hljs go">grpc.WithDefaultServiceConfig(<span class="hljs-string">`&#123;&quot;loadBalancingPolicy&quot;:&quot;weight_lb_picker&quot;&#125;`</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// 连接服务器</span>conn, err := grpc.Dial(etcdResolverBuilder.Scheme()+<span class="hljs-string">&quot;:///user-service-1/v1&quot;</span>, grpc.WithTransportCredentials(insecure.NewCredentials()), grpc.WithDefaultServiceConfig(   <span class="hljs-string">`&#123;&quot;loadBalancingPolicy&quot;:&quot;weight_lb_picker&quot;&#125;`</span>,))</code></pre></div><p>这样就会使用我们自定义的负载均衡策略来选择服务节点。</p><p>创建多个服务节点的服务端，客户端选择的结果如下图所示，其中80端口的服务权重是8， 81端口的服务权重是2，可以看到80端口更容易被选中。</p><p><img src="/pic/15.png" alt="image-20230801235431462"></p><p>源码获取：[AngryPotato&#x2F;grpc-etcd](<a href="https://github.com/Jack-Ken/grpc-etcd">Jack-Ken&#x2F;grpc-etcd (github.com)</a>)</p>]]></content>
    
    
    <categories>
      
      <category>Go学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>多线程实现交替打印</title>
    <link href="/2023/11/05/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B0/"/>
    <url>/2023/11/05/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="多线程实现交替打印"><a href="#多线程实现交替打印" class="headerlink" title="多线程实现交替打印"></a>多线程实现交替打印</h1><p>首先提出该问题的面试官主要是考察，你对协程之间相互通信和协程的生命周期管理的考察,所以我们首先想到的是用<code>chan</code>进行协程之间通信，用<code>sync.WaitGroup</code>来管理协程的生命周期</p><h2 id="两个协程交替打印"><a href="#两个协程交替打印" class="headerlink" title="两个协程交替打印"></a>两个协程交替打印</h2><p>错误解法：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> ch1 = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<span class="hljs-keyword">var</span> ch2 = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<span class="hljs-keyword">var</span> ch3 = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span>)<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">for</span> a := <span class="hljs-number">0</span>; a &lt; <span class="hljs-number">5</span>; a++ &#123;i := &lt;-ch1fmt.Println(<span class="hljs-string">&quot;goroutine 1: &quot;</span>, i)ch2 &lt;- i + <span class="hljs-number">1</span>&#125;&#125;()<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">for</span> a := <span class="hljs-number">0</span>; a &lt; <span class="hljs-number">5</span>; a++ &#123;i := &lt;-ch2fmt.Println(<span class="hljs-string">&quot;goroutine 2: &quot;</span>, i)ch1 &lt;- i + <span class="hljs-number">1</span>&#125;&#125;()ch1 &lt;- <span class="hljs-number">1</span>&#125;</code></pre></div><p>这种解法无法控制main协程在其他协程工作结束之后才结束，可能打印工作还没结束，主协程就结束了。</p><p>方案一：使用两个<code>chan</code>来控制来控制两个协程的工作顺序，并使用用<code>sync.WaitGroup</code>来管理协程的生命周期</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;sync&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> ch1 = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">1</span>)<span class="hljs-keyword">var</span> ch2 = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">1</span>)<span class="hljs-keyword">var</span> wg sync.WaitGroupwg.Add(<span class="hljs-number">2</span>)<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">defer</span> wg.Done()<span class="hljs-keyword">for</span> a := <span class="hljs-number">0</span>; a &lt; <span class="hljs-number">5</span>; a++ &#123;i := &lt;-ch1fmt.Println(<span class="hljs-string">&quot;goroutine 1: &quot;</span>, i)ch2 &lt;- i + <span class="hljs-number">1</span>&#125;&#125;()<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">defer</span> wg.Done()<span class="hljs-keyword">for</span> a := <span class="hljs-number">0</span>; a &lt; <span class="hljs-number">5</span>; a++ &#123;i := &lt;-ch2fmt.Println(<span class="hljs-string">&quot;goroutine 2: &quot;</span>, i)ch1 &lt;- i + <span class="hljs-number">1</span>&#125;&#125;()ch1 &lt;- <span class="hljs-number">1</span>    <span class="hljs-comment">// 等待协程执行完毕，main必须在其他协程完成工作之后才能结束</span>wg.Wait()&#125;</code></pre></div><p>方案二：使用两个<code>chan</code> 来控制两个工作协程的的打印顺序，另一<code>chan</code>来管理主协程在最后结束生命。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> ch1 = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<span class="hljs-keyword">var</span> ch2 = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<span class="hljs-keyword">var</span> ch3 = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span>)<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">for</span> a := <span class="hljs-number">0</span>; a &lt; <span class="hljs-number">5</span>; a++ &#123;i := &lt;-ch1fmt.Println(<span class="hljs-string">&quot;goroutine 1: &quot;</span>, i)ch2 &lt;- i + <span class="hljs-number">1</span>&#125;ch3 &lt;- <span class="hljs-literal">true</span>&#125;()<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">for</span> a := <span class="hljs-number">0</span>; a &lt; <span class="hljs-number">5</span>; a++ &#123;i := &lt;-ch2fmt.Println(<span class="hljs-string">&quot;goroutine 2: &quot;</span>, i)ch1 &lt;- i + <span class="hljs-number">1</span>&#125;ch3 &lt;- <span class="hljs-literal">true</span>&#125;()ch1 &lt;- <span class="hljs-number">1</span>&lt;-ch3&#125;</code></pre></div><h2 id="扩展-N个协程交替打印"><a href="#扩展-N个协程交替打印" class="headerlink" title="扩展-N个协程交替打印"></a>扩展-N个协程交替打印</h2><p>例子-使用三个协程交替打印</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;sync&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getWorker</span><span class="hljs-params">(wg *sync.WaitGroup, waitCh <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, symbol <span class="hljs-type">int</span>)</span></span> <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span> &#123;notify := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)wg.Add(<span class="hljs-number">1</span>)<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(waitCh <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)</span></span> &#123;<span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;wg.Done()&#125;()fmt.Printf(<span class="hljs-string">&quot;waitCh Address of p=%p ，i:%d \n&quot;</span>, waitCh, symbol)<span class="hljs-keyword">for</span> d := <span class="hljs-keyword">range</span> waitCh &#123;<span class="hljs-keyword">if</span> d &gt;= <span class="hljs-number">30</span> &#123;<span class="hljs-keyword">break</span>&#125;fmt.Println(<span class="hljs-string">&quot;goroutine:&quot;</span>, symbol, <span class="hljs-string">&quot;print&quot;</span>, d)notify &lt;- d + <span class="hljs-number">1</span>&#125;<span class="hljs-built_in">close</span>(notify)fmt.Println(<span class="hljs-string">&quot;goroutine: finish&quot;</span>, symbol)&#125;(waitCh)<span class="hljs-keyword">return</span> notify&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;goruntineNum := <span class="hljs-number">3</span>wg := <span class="hljs-built_in">new</span>(sync.WaitGroup)start := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)        <span class="hljs-comment">// 使用lastCh保存start值用于后续计算，start后面还要用。</span>lastch := startfmt.Printf(<span class="hljs-string">&quot;waitCh Address of start p=%p ，lastch p=%p \n&quot;</span>, start, lastch)<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; goruntineNum; i++ &#123;lastch = getWorker(wg, lastch, i+<span class="hljs-number">1</span>)&#125;    <span class="hljs-comment">// for循环之后lastch就是最后一个协程返回的通道，我们需要将通道内的值发送到第一个协程的通道内，就是下面的for range的操作</span>start &lt;- <span class="hljs-number">1</span>    <span class="hljs-comment">// 当最后一个协程打印之后通知第一个协程的通道，该工作了</span><span class="hljs-keyword">for</span> v := <span class="hljs-keyword">range</span> lastch &#123;start &lt;- v&#125;<span class="hljs-built_in">close</span>(start)wg.Wait()&#125;</code></pre></div><p>流程，第一个for循环是创建工作协程，并且每创建一个协程都会返回一个通道用于启动下一个协程，并且该chan还负责向下一个协程通知需要打印的数字。但是这样的话最后一个协程返回的通道没有协程使用，所以我们将最后返回的通道中的值发送给start，也就是第一个协程使用的通道，这样当一个协程打印数字之后就会通知下一个协程去打印下一个数字，而最后一个协程打印之后就会通知第一个协程继续打印，这样循环打印，直到打印完毕。</p><p>知识点:</p><p>这里的<code>for</code>语句也可以被称为带有<code>range</code>子句的<code>for</code>语句，有如下特征：</p><ul><li>一、这样一条<code>for</code>语句会不断地尝试从<code>intChan2</code>种取出元素值，即使<code>intChan2</code>被关闭，它也会在取出所有剩余的元素值之后再结束执行。</li><li>二、当<code>intChan2</code>中没有元素值时，它会被阻塞在有<code>for</code>关键字的那一行，直到有新的元素值可取。</li><li>三、假设<code>intChan2</code>的值为<code>nil</code>，那么它会被永远阻塞在有<code>for</code>关键字的那一行。</li></ul><p>除此以外，通道还可以和select结合使用：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// 准备好几个通道。</span>intChannels := [<span class="hljs-number">3</span>]<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>&#123;<span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">1</span>),<span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">1</span>),<span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">1</span>),&#125;<span class="hljs-comment">// 随机选择一个通道，并向它发送元素值。</span>index := rand.Intn(<span class="hljs-number">3</span>)fmt.Printf(<span class="hljs-string">&quot;The index: %d\n&quot;</span>, index)intChannels[index] &lt;- index<span class="hljs-comment">// 哪一个通道中有可取的元素值，哪个对应的分支就会被执行。</span><span class="hljs-keyword">select</span> &#123;<span class="hljs-keyword">case</span> &lt;-intChannels[<span class="hljs-number">0</span>]:fmt.Println(<span class="hljs-string">&quot;The first candidate case is selected.&quot;</span>)<span class="hljs-keyword">case</span> &lt;-intChannels[<span class="hljs-number">1</span>]:fmt.Println(<span class="hljs-string">&quot;The second candidate case is selected.&quot;</span>)<span class="hljs-keyword">case</span> elem := &lt;-intChannels[<span class="hljs-number">2</span>]:fmt.Printf(<span class="hljs-string">&quot;The third candidate case is selected, the element is %d.\n&quot;</span>, elem)<span class="hljs-keyword">default</span>:fmt.Println(<span class="hljs-string">&quot;No candidate case is selected!&quot;</span>)&#125;</code></pre></div><p>在使用<code>select</code>语句的时候，我们首先需要注意下面几个事情。</p><ol><li>如果像上述示例那样加入了<strong>默认分支，那么无论涉及通道操作的表达式是否有阻塞，<code>select</code>语句都不会被阻塞</strong>。如果那几个表达式都阻塞了，或者说都没有满足求值的条件，那么默认分支就会被选中并执行。</li><li>如果没有加入默认分支，那么一旦所有的<code>case</code>表达式都没有满足求值条件，那么<code>select</code>语句就会被阻塞。直到至少有一个<code>case</code>表达式满足条件为止。</li><li>还记得吗？我们可能会因为通道关闭了，而直接从通道接收到一个其元素类型的零值。所以，在很多时候，我们需要通过接收表达式的第二个结果值来判断通道是否已经关闭。一旦发现某个通道关闭了，我们就应该及时地屏蔽掉对应的分支或者采取其他措施。这对于程序逻辑和程序性能都是有好处的。</li><li><code>select</code>语句只能对其中的每一个<code>case</code>表达式各求值一次。所以，如果我们想连续或定时地操作其中的通道的话，就往往需要通过在<code>for</code>语句中嵌入<code>select</code>语句的方式实现。但这时要注意，简单地在<code>select</code>语句的分支中使用<code>break</code>语句，只能结束当前的<code>select</code>语句的执行，而并不会对外层的<code>for</code>语句产生作用。这种错误的用法可能会让这个<code>for</code>语句无休止地运行下去。</li></ol>]]></content>
    
    
    <categories>
      
      <category>常见Go面试题思考</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>面试准备-Go接口</title>
    <link href="/2023/11/05/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87-Go%E6%8E%A5%E5%8F%A3/"/>
    <url>/2023/11/05/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87-Go%E6%8E%A5%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="面试准备-Go接口"><a href="#面试准备-Go接口" class="headerlink" title="面试准备-Go接口"></a>面试准备-Go接口</h1><h2 id="1、值接收者与指针接受者的区别以及两者的使用时机"><a href="#1、值接收者与指针接受者的区别以及两者的使用时机" class="headerlink" title="1、值接收者与指针接受者的区别以及两者的使用时机"></a>1、值接收者与指针接受者的区别以及两者的使用时机</h2><p>&emsp; &emsp;我们都知道，如果要实现一个接口，必须实现这个接口提供的所有方法，但是实现方法的时候，我们可以使用指针接收者实现，也可以使用值接收者实现，这两者是有区别的</p><p>下面是一个例子</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-keyword">type</span> coder <span class="hljs-keyword">interface</span> &#123;code()debug()&#125;<span class="hljs-keyword">type</span> Gopher <span class="hljs-keyword">struct</span> &#123;language <span class="hljs-type">string</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p Gopher)</span></span> code() &#123;fmt.Printf(<span class="hljs-string">&quot;I am coding %s language\n&quot;</span>, p.language)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *Gopher)</span></span> debug() &#123;fmt.Printf(<span class="hljs-string">&quot;I am debuging %s language\n&quot;</span>, p.language)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> c coder = &amp;Gopher&#123;<span class="hljs-string">&quot;Go&quot;</span>&#125;c.code()c.debug()&#125;</code></pre></div><p>可以看到上述代码定义了一个接口<code>coder</code>，接口定义可两个函数</p><div class="code-wrapper"><pre><code class="hljs go">code() debug()</code></pre></div><p>接着定义了一个结构体 <code>Gopher</code>，它实现了两个方法，一个值接收者，一个指针接收者。我们使用指针类型的调用者来调用定义的两个函数。结果可以正常运行：</p><div class="code-wrapper"><pre><code class="hljs go">I am coding Go languageI am debuging Go language</code></pre></div><p>但是如果我们把 <code>main</code> 函数的第一条语句换一下：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> c coder = Gopher&#123;<span class="hljs-string">&quot;Go&quot;</span>&#125;c.code()c.debug()&#125;</code></pre></div><p>运行报错</p><div class="code-wrapper"><pre><code class="hljs shell">src/main.go:23:6: cannot use Gopher literal (type Gopher) as type coder in assignment:Gopher does not implement coder (debug method has pointer receiver)</code></pre></div><p>通过这个例子我们可得出结论：</p><ul><li><strong>实体类型以值接收者实现接口的时候，不管是实体类型的值，还是实体类型值的指针，都实现了该接口</strong>。</li><li><strong>实体类型以指针接收者实现接口的时候，只有指向这个类型的指针才被认为实现了该接口</strong></li></ul><h2 id="2、两者分别在什么时候使用"><a href="#2、两者分别在什么时候使用" class="headerlink" title="2、两者分别在什么时候使用"></a>2、两者分别在什么时候使用</h2><p>&emsp; &emsp;如果方法的接收者是值类型，无论调用者是对象还是对象指针，修改的都是对象的副本，不影响调用者；如果方法的接收者是指针类型，则调用者修改的是指针指向的对象本身。</p><p>使用指针作为方法的接收者的理由：</p><ul><li>方法能够修改接收者指向的值。</li><li>避免在每次调用方法时复制该值，在值的类型为大型结构体时，这样做会更加高效。</li></ul><p>是使用值接收者还是指针接收者，不是由该方法是否修改了调用者（也就是接收者）来决定，而是应该基于该类型的<code>本质</code>。</p><h2 id="3、iface和eface"><a href="#3、iface和eface" class="headerlink" title="3、iface和eface"></a>3、iface和eface</h2><p><code>iface</code> 和 <code>eface</code> 都是 Go 中描述接口的底层结构体，区别在于 <strong><code>iface</code> 描述的接口包含方法，而 <code>eface</code> 则是不包含任何方法的空接口：<code>interface&#123;&#125;</code>。</strong></p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> iface <span class="hljs-keyword">struct</span> &#123;tab  *itabdata unsafe.Pointer&#125;<span class="hljs-keyword">type</span> itab <span class="hljs-keyword">struct</span> &#123;inter  *interfacetype  <span class="hljs-comment">// 接口类型</span>_type  *_type  <span class="hljs-comment">// 实体类型</span>link   *itabhash   <span class="hljs-type">uint32</span> <span class="hljs-comment">// copy of _type.hash. Used for type switches.</span>bad    <span class="hljs-type">bool</span>   <span class="hljs-comment">// type does not implement interface</span>inhash <span class="hljs-type">bool</span>   <span class="hljs-comment">// has this itab been added to hash?</span>unused [<span class="hljs-number">2</span>]<span class="hljs-type">byte</span>fun    [<span class="hljs-number">1</span>]<span class="hljs-type">uintptr</span> <span class="hljs-comment">// 放置和接口方法对应的具体数据类型的方法地址</span>&#125;</code></pre></div><p><code>iface</code> 内部维护两个指针，<code>tab</code> 指向一个 <code>itab</code> 实体， 它表示接口的类型以及赋给这个接口的实体类型。<code>data</code> 则指向接口具体的值，一般而言是一个指向堆内存的指针。</p><p>再来仔细看一下 <code>itab</code> 结构体：<code>_type</code> 字段描述了实体的类型，包括内存对齐方式，大小等；<code>inter</code> 字段则描述了接口的类型。<code>fun</code> 字段放置和接口方法对应的具体数据类型的方法地址，实现接口调用方法的动态分派，一般在每次给接口赋值发生转换时会更新此表，或者直接拿缓存的 itab。</p><p>这里只会列出实体类型和接口相关的方法，实体类型的其他方法并不会出现在这里。</p><p>再看一下 <code>interfacetype</code> 类型，它描述的是接口的类型：</p><div class="code-wrapper"><pre><code class="hljs golang"><span class="hljs-keyword">type</span> interfacetype <span class="hljs-keyword">struct</span> &#123;typ     _typepkgpath namemhdr    []imethod&#125;</code></pre></div><p>可以看到，它包装了 <code>_type</code> 类型，<code>_type</code> 实际上是描述 Go 语言中各种数据类型的结构体。我们注意到，这里还包含一个 <code>mhdr</code> 字段，表示接口所定义的函数列表， <code>pkgpath</code> 记录定义了接口的包名。</p><p>这里通过一张图来看下 <code>iface</code> 结构体的全貌：</p><p><img src="/pic/0.png" alt="iface 结构体全景"></p><p>接着来看一下 <code>eface</code> 的源码：</p><div class="code-wrapper"><pre><code class="hljs golang"><span class="hljs-keyword">type</span> eface <span class="hljs-keyword">struct</span> &#123;    _type *_type    data  unsafe.Pointer&#125;</code></pre></div><h2 id="4、接口的动态类型和动态值"><a href="#4、接口的动态类型和动态值" class="headerlink" title="4、接口的动态类型和动态值"></a>4、接口的动态类型和动态值</h2><p>&emsp;&emsp;从源码里可以看到：<code>iface</code>包含两个字段：<code>tab</code> 是接口表指针，指向类型信息；<code>data</code> 是数据指针，则指向具体的数据。它们分别被称为<code>动态类型</code>和<code>动态值</code>。而接口值包括<code>动态类型</code>和<code>动态值</code>。简单来说，动态类型就是实现接口的类型，动态值就是实现接口的类型的值。除此以外，接口的静态类型就是接口本身。</p><ul><li>引申1、接口类型和<code>nil</code>作比较</li></ul><p>接口值的零值是指<code>动态类型</code>和<code>动态值</code>都为 <code>nil</code>。当仅且当这两部分的值都为 <code>nil</code> 的情况下，这个接口值就才会被认为 <code>接口值 == nil</code>。</p><div class="code-wrapper"><pre><code class="hljs golang"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-keyword">type</span> Coder <span class="hljs-keyword">interface</span> &#123;code()&#125;<span class="hljs-keyword">type</span> Gopher <span class="hljs-keyword">struct</span> &#123;name <span class="hljs-type">string</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g Gopher)</span></span> code() &#123;fmt.Printf(<span class="hljs-string">&quot;%s is coding\n&quot;</span>, g.name)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> c Coderfmt.Println(c == <span class="hljs-literal">nil</span>)fmt.Printf(<span class="hljs-string">&quot;c: %T, %v\n&quot;</span>, c, c)<span class="hljs-keyword">var</span> g *Gopherfmt.Println(g == <span class="hljs-literal">nil</span>)c = gfmt.Println(c == <span class="hljs-literal">nil</span>)fmt.Printf(<span class="hljs-string">&quot;c: %T, %v\n&quot;</span>, c, c)&#125;</code></pre></div><p>输出：</p><div class="code-wrapper"><pre><code class="hljs shell">truec: &lt;nil&gt;, &lt;nil&gt;truefalsec: *main.Gopher, &lt;nil&gt;</code></pre></div><p>一开始，<code>c</code> 的 动态类型和动态值都为 <code>nil</code>，<code>g</code> 也为 <code>nil</code>，当把 <code>g</code> 赋值给 <code>c</code> 后，<code>c</code> 的动态类型变成了 <code>*main.Gopher</code>，仅管 <code>c</code> 的动态值仍为 <code>nil</code>，但是当 <code>c</code> 和 <code>nil</code> 作比较的时候，结果就是 <code>false</code> 了。</p><ul><li><p>引申2、来看一个例子，看一下它的输出：</p><div class="code-wrapper"><pre><code class="hljs golang"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-keyword">type</span> MyError <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(i MyError)</span></span> Error() <span class="hljs-type">string</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;MyError&quot;</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;err := Process()fmt.Println(err)fmt.Println(err == <span class="hljs-literal">nil</span>)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Process</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> &#123;<span class="hljs-keyword">var</span> err *MyError = <span class="hljs-literal">nil</span><span class="hljs-keyword">return</span> err&#125;</code></pre></div><p>函数运行结果：</p><div class="code-wrapper"><pre><code class="hljs shell">&lt;nil&gt;false</code></pre></div><p>这里先定义了一个 <code>MyError</code> 结构体，实现了 <code>Error</code> 函数，也就实现了 <code>error</code> 接口。<code>Process</code> 函数返回了一个 <code>error</code> 接口，这块隐含了类型转换。所以，虽然它的值是 <code>nil</code>，其实它的类型是 <code>*MyError</code>，最后和 <code>nil</code> 比较的时候，结果为 <code>false</code>。</p></li><li><p>引申3、如何打印出接口的动态类型和值？</p><div class="code-wrapper"><pre><code class="hljs golang"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;unsafe&quot;</span><span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-keyword">type</span> iface <span class="hljs-keyword">struct</span> &#123;itab, data <span class="hljs-type">uintptr</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> a <span class="hljs-keyword">interface</span>&#123;&#125; = <span class="hljs-literal">nil</span><span class="hljs-keyword">var</span> b <span class="hljs-keyword">interface</span>&#123;&#125; = (*<span class="hljs-type">int</span>)(<span class="hljs-literal">nil</span>)x := <span class="hljs-number">5</span><span class="hljs-keyword">var</span> c <span class="hljs-keyword">interface</span>&#123;&#125; = (*<span class="hljs-type">int</span>)(&amp;x)ia := *(*iface)(unsafe.Pointer(&amp;a))ib := *(*iface)(unsafe.Pointer(&amp;b))ic := *(*iface)(unsafe.Pointer(&amp;c))fmt.Println(ia, ib, ic)fmt.Println(*(*<span class="hljs-type">int</span>)(unsafe.Pointer(ic.data)))&#125;</code></pre></div><p>代码里直接定义了一个 <code>iface</code> 结构体，用两个指针来描述 <code>itab</code> 和 <code>data</code>，之后将 a, b, c 在内存中的内容强制解释成我们自定义的 <code>iface</code>。最后就可以打印出动态类型和动态值的地址。</p><p>运行结果如下：</p><div class="code-wrapper"><pre><code class="hljs shell">&#123;0 0&#125; &#123;17426912 0&#125; &#123;17426912 842350714568&#125;5</code></pre></div><p>a 的动态类型和动态值的地址均为 0，也就是 nil；b 的动态类型和 c 的动态类型一致，都是 <code>*int</code>；最后，c 的动态值为 5。</p></li></ul><h2 id="5、编译器自动检测类型是否实现接口"><a href="#5、编译器自动检测类型是否实现接口" class="headerlink" title="5、编译器自动检测类型是否实现接口"></a>5、编译器自动检测类型是否实现接口</h2><p>我们在一些开源库中看到下面这中奇怪的用法</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> _ io.Writer = (*myWriter)(<span class="hljs-literal">nil</span>)</code></pre></div><p>此时，编译器会由此检查<code>*myWriter</code>是否实现了<code>io.Writer</code>接口。</p><p>来看一个例子：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;io&quot;</span><span class="hljs-keyword">type</span> myWriter <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">/*func (w myWriter) Write(p []byte) (n int, err error) &#123;</span><span class="hljs-comment">return</span><span class="hljs-comment">&#125;*/</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-comment">// 检查 *myWriter 类型是否实现了 io.Writer 接口</span>    <span class="hljs-keyword">var</span> _ io.Writer = (*myWriter)(<span class="hljs-literal">nil</span>)    <span class="hljs-comment">// 检查 myWriter 类型是否实现了 io.Writer 接口</span>    <span class="hljs-keyword">var</span> _ io.Writer = myWriter&#123;&#125;&#125;</code></pre></div><p>注释掉为 myWriter 定义的 Write 函数后，运行程序：</p><div class="code-wrapper"><pre><code class="hljs golang">src/main.<span class="hljs-keyword">go</span>:<span class="hljs-number">14</span>:<span class="hljs-number">6</span>: cannot use (*myWriter)(<span class="hljs-literal">nil</span>) (<span class="hljs-keyword">type</span> *myWriter) as <span class="hljs-keyword">type</span> io.Writer in assignment:*myWriter does not implement io.Writer (missing Write method)src/main.<span class="hljs-keyword">go</span>:<span class="hljs-number">15</span>:<span class="hljs-number">6</span>: cannot use myWriter literal (<span class="hljs-keyword">type</span> myWriter) as <span class="hljs-keyword">type</span> io.Writer in assignment:myWriter does not implement io.Writer (missing Write method)</code></pre></div><p>当我们删除注释之后，运行程序就不会报错。</p><p>实际上，上述赋值语句会发生隐式地类型转换，在转换的过程中，编译器会检测等号右边的类型是否实现了等号左边接口所规定的函数。</p><p>所以我们可以在代码中添加类似的代码，用来检查类型是否实现了接口：</p><div class="code-wrapper"><pre><code class="hljs golang"><span class="hljs-keyword">var</span> _ io.Writer = (*myWriter)(<span class="hljs-literal">nil</span>)<span class="hljs-keyword">var</span> _ io.Writer = myWriter&#123;&#125;</code></pre></div><ul><li><p>引申 如何打印出接口类型的Hash值？</p><div class="code-wrapper"><pre><code class="hljs golang"><span class="hljs-keyword">type</span> iface <span class="hljs-keyword">struct</span> &#123;tab  *itabdata unsafe.Pointer&#125;<span class="hljs-keyword">type</span> itab <span class="hljs-keyword">struct</span> &#123;inter <span class="hljs-type">uintptr</span>_type <span class="hljs-type">uintptr</span>link <span class="hljs-type">uintptr</span>hash  <span class="hljs-type">uint32</span>_     [<span class="hljs-number">4</span>]<span class="hljs-type">byte</span>fun   [<span class="hljs-number">1</span>]<span class="hljs-type">uintptr</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> qcrao = Person(Student&#123;age: <span class="hljs-number">18</span>&#125;)iface := (*iface)(unsafe.Pointer(&amp;qcrao))fmt.Printf(<span class="hljs-string">&quot;iface.tab.hash = %#x\n&quot;</span>, iface.tab.hash)&#125;</code></pre></div><p>定义了一个<code>山寨版</code>的 <code>iface</code> 和 <code>itab</code>，说它<code>山寨</code>是因为 <code>itab</code> 里的一些关键数据结构都不具体展开了，比如 <code>_type</code>，对比一下正宗的定义就可以发现，但是<code>山寨版</code>依然能工作，因为 <code>_type</code> 就是一个指针而已嘛。</p><p>在 <code>main</code> 函数里，先构造出一个接口对象 <code>qcrao</code>，然后强制类型转换，最后读取出 <code>hash</code> 值，非常妙！你也可以自己动手试一下。</p><p>运行结果：</p><div class="code-wrapper"><pre><code class="hljs shell">iface.tab.hash = 0xd4209fda</code></pre></div><p>值得一提的是，构造接口 <code>qcrao</code> 的时候，即使我把 <code>age</code> 写成其他值，得到的 <code>hash</code> 值依然不变的，这应该是可以预料的，<code>hash</code> 值只和他的字段、方法相关。</p></li></ul><h2 id="6、类型转换和断言的区别"><a href="#6、类型转换和断言的区别" class="headerlink" title="6、类型转换和断言的区别"></a>6、类型转换和断言的区别</h2><p>对于<code>类型转换</code>而言，转换前后的两个类型要相互兼容才行。类型转换的语法为：</p><blockquote><p>&lt;结果类型&gt; :&#x3D; &lt;目标类型&gt; ( &lt;表达式&gt; )</p></blockquote><p>前面说过，因为空接口 <code>interface&#123;&#125;</code> 没有定义任何函数，因此 Go 中所有类型都实现了空接口。当一个函数的形参是 <code>interface&#123;&#125;</code>，那么在函数中，需要对形参进行断言，从而得到它的真实类型。</p><p>断言的语法为：</p><blockquote><p>&lt;目标类型的值&gt;，&lt;布尔参数&gt; :&#x3D; &lt;表达式&gt;.( 目标类型 ) &#x2F;&#x2F; 安全类型断言 &lt;目标类型的值&gt; :&#x3D; &lt;表达式&gt;.( 目标类型 )　　&#x2F;&#x2F;非安全类型断言</p></blockquote><p><strong>类型转换和类型断言有些相似，不同之处，在于类型断言是对接口进行的操作。</strong></p><p>来看一个简单的例子：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-keyword">type</span> Student <span class="hljs-keyword">struct</span> &#123;Name <span class="hljs-type">string</span>Age <span class="hljs-type">int</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> i <span class="hljs-keyword">interface</span>&#123;&#125; = <span class="hljs-built_in">new</span>(Student)s := i.(Student)fmt.Println(s)&#125;</code></pre></div><p>运行一下：</p><div class="code-wrapper"><pre><code class="hljs shell">panic: interface conversion: interface &#123;&#125; is *main.Student, not main.Student</code></pre></div><p>直接 <code>panic</code> 了，这是因为 <code>i</code> 是 <code>*Student</code> 类型，并非 <code>Student</code> 类型，断言失败。这里直接发生了 <code>panic</code>，线上代码可能并不适合这样做，可以采用“安全断言”的语法：</p><div class="code-wrapper"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> i <span class="hljs-keyword">interface</span>&#123;&#125; = <span class="hljs-built_in">new</span>(Student)s, ok := i.(Student)<span class="hljs-keyword">if</span> ok &#123;fmt.Println(s)&#125;&#125;</code></pre></div><p>这样，即使断言失败也不会 <code>panic</code>。</p><p>断言其实还有另一种形式，就是用在利用 <code>switch</code> 语句判断接口的类型。每一个 <code>case</code> 会被顺序地考虑。当命中一个 <code>case</code> 时，就会执行 <code>case</code> 中的语句，因此 <code>case</code> 语句的顺序是很重要的，因为很有可能会有多个 <code>case</code> 匹配的情况。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-comment">//var i interface&#123;&#125; = new(Student)</span><span class="hljs-comment">//var i interface&#123;&#125; = (*Student)(nil)</span><span class="hljs-keyword">var</span> i <span class="hljs-keyword">interface</span>&#123;&#125;fmt.Printf(<span class="hljs-string">&quot;%p %v\n&quot;</span>, &amp;i, i)judge(i)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">judge</span><span class="hljs-params">(v <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;fmt.Printf(<span class="hljs-string">&quot;%p %v\n&quot;</span>, &amp;v, v)<span class="hljs-keyword">switch</span> v := v.(<span class="hljs-keyword">type</span>) &#123;<span class="hljs-keyword">case</span> <span class="hljs-literal">nil</span>:fmt.Printf(<span class="hljs-string">&quot;%p %v\n&quot;</span>, &amp;v, v)fmt.Printf(<span class="hljs-string">&quot;nil type[%T] %v\n&quot;</span>, v, v)<span class="hljs-keyword">case</span> Student:fmt.Printf(<span class="hljs-string">&quot;%p %v\n&quot;</span>, &amp;v, v)fmt.Printf(<span class="hljs-string">&quot;Student type[%T] %v\n&quot;</span>, v, v)<span class="hljs-keyword">case</span> *Student:fmt.Printf(<span class="hljs-string">&quot;%p %v\n&quot;</span>, &amp;v, v)fmt.Printf(<span class="hljs-string">&quot;*Student type[%T] %v\n&quot;</span>, v, v)<span class="hljs-keyword">default</span>:fmt.Printf(<span class="hljs-string">&quot;%p %v\n&quot;</span>, &amp;v, v)fmt.Printf(<span class="hljs-string">&quot;unknow\n&quot;</span>)&#125;&#125;<span class="hljs-keyword">type</span> Student <span class="hljs-keyword">struct</span> &#123;Name <span class="hljs-type">string</span>Age <span class="hljs-type">int</span>&#125;</code></pre></div><p><code>main</code> 函数里有三行不同的声明，每次运行一行，注释另外两行，得到三组运行结果：</p><div class="code-wrapper"><pre><code class="hljs shell">// --- var i interface&#123;&#125; = new(Student)0xc4200701b0 [Name: ], [Age: 0]0xc4200701d0 [Name: ], [Age: 0]0xc420080020 [Name: ], [Age: 0]*Student type[*main.Student] [Name: ], [Age: 0]// --- var i interface&#123;&#125; = (*Student)(nil)0xc42000e1d0 &lt;nil&gt;0xc42000e1f0 &lt;nil&gt;0xc42000c030 &lt;nil&gt;*Student type[*main.Student] &lt;nil&gt;// --- var i interface&#123;&#125;0xc42000e1d0 &lt;nil&gt;0xc42000e1e0 &lt;nil&gt;0xc42000e1f0 &lt;nil&gt;nil type[&lt;nil&gt;] &lt;nil&gt;</code></pre></div><p>对于第一行语句：</p><div class="code-wrapper"><pre><code class="hljs golang"><span class="hljs-keyword">var</span> i <span class="hljs-keyword">interface</span>&#123;&#125; = <span class="hljs-built_in">new</span>(Student)</code></pre></div><p><code>i</code> 是一个 <code>*Student</code> 类型，匹配上第三个 case，从打印的三个地址来看，这三处的变量实际上都是不一样的。在 <code>main</code> 函数里有一个局部变量 <code>i</code>；调用函数时，实际上是复制了一份参数，因此函数里又有一个变量 <code>v</code>，它是 <code>i</code> 的拷贝；断言之后，又生成了一份新的拷贝。所以最终打印的三个变量的地址都不一样。</p><p>对于第二行语句：</p><div class="code-wrapper"><pre><code class="hljs golang"><span class="hljs-keyword">var</span> i <span class="hljs-keyword">interface</span>&#123;&#125; = (*Student)(<span class="hljs-literal">nil</span>)</code></pre></div><p>这里想说明的其实是 <code>i</code> 在这里动态类型是 <code>(*Student)</code>, 数据为 <code>nil</code>，它的类型并不是 <code>nil</code>，它与 <code>nil</code> 作比较的时候，得到的结果也是 <code>false</code>。</p><p>最后一行语句：</p><div class="code-wrapper"><pre><code class="hljs golang"><span class="hljs-keyword">var</span> i <span class="hljs-keyword">interface</span>&#123;&#125;</code></pre></div><p>这回 <code>i</code> 才是 <code>nil</code> 类型。</p><p><strong>【引申1】</strong> <code>fmt.Println</code> 函数的参数是 <code>interface</code>。对于内置类型，函数内部会用穷举法，得出它的真实类型，然后转换为字符串打印。而对于自定义类型，首先确定该类型是否实现了 <code>String()</code> 方法，如果实现了，则直接打印输出 <code>String()</code> 方法的结果；否则，会通过反射来遍历对象的成员进行打印。</p><p>再来看一个简短的例子，比较简单，不要紧张：</p><div class="code-wrapper"><pre><code class="hljs golang"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-keyword">type</span> Student <span class="hljs-keyword">struct</span> &#123;Name <span class="hljs-type">string</span>Age <span class="hljs-type">int</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> s = Student&#123;Name: <span class="hljs-string">&quot;qcrao&quot;</span>,Age: <span class="hljs-number">18</span>,&#125;fmt.Println(s)&#125;</code></pre></div><p>因为 <code>Student</code> 结构体没有实现 <code>String()</code> 方法，所以 <code>fmt.Println</code> 会利用反射挨个打印成员变量：</p><div class="code-wrapper"><pre><code class="hljs shell">&#123;qcrao 18&#125;</code></pre></div><p>增加一个 <code>String()</code> 方法的实现：</p><div class="code-wrapper"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s Student)</span></span> String() <span class="hljs-type">string</span> &#123;<span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;[Name: %s], [Age: %d]&quot;</span>, s.Name, s.Age)&#125;</code></pre></div><p>打印结果：</p><div class="code-wrapper"><pre><code class="hljs shell">[Name: qcrao], [Age: 18]</code></pre></div><p><strong>【引申2】</strong>针对上面的例子，如果改一下：</p><div class="code-wrapper"><pre><code class="hljs goalng">func (s *Student) String() string &#123;return fmt.Sprintf(&quot;[Name: %s], [Age: %d]&quot;, s.Name, s.Age)&#125;</code></pre></div><p>注意看两个函数的接受者类型不同，现在 <code>Student</code> 结构体只有一个接受者类型为 <code>指针类型</code> 的 <code>String()</code> 函数，打印结果：</p><div class="code-wrapper"><pre><code class="hljs shell">&#123;qcrao 18&#125;</code></pre></div><p>因为String函数的接受者是指针，所以只有调用类型的指针类型才可以调用。</p><p>所以， <code>Student</code> 结构体定义了接受者类型是值类型的 <code>String()</code> 方法时，通过</p><div class="code-wrapper"><pre><code class="hljs golang">fmt.Println(s)fmt.Println(&amp;s)</code></pre></div><p>均可以按照自定义的格式来打印。</p><p>如果 <code>Student</code> 结构体定义了接受者类型是指针类型的 <code>String()</code> 方法时，只有通过</p><div class="code-wrapper"><pre><code class="hljs golang">fmt.Println(&amp;s)</code></pre></div><p>才能按照自定义的格式打印。</p><h2 id="7、接口的类型转换"><a href="#7、接口的类型转换" class="headerlink" title="7、接口的类型转换"></a>7、接口的类型转换</h2><p>&emsp;&emsp;前面我们了解了iface通过itab结构体描述非空接口的细节，包括接口方法定义，接口方法实现地址等。iface是非空接口的实现，而不是类型定义，iface的真正类型为interfacetype，interfacetype是描述接口类型定义的数据结构。</p><p>&emsp;&emsp;为了提高查找效率，runtime中实现了（interfacetype，concrete_type） -&gt; itab（包含具体实现地址信息）的hash表，其中interfacetype表示接口类型，concrete_type是实体类型。</p><p>&emsp;&emsp;当判定某一类型是否满足某个接口的时候，Go 使用实体类型的方法集和接口所需要的方法集进行匹配，如果类型的方法集完全包含接口的方法集，则可认为该类型实现了该接口。例如某类型有m个方法，某接口有n个方法，则很容易知道这种判定的时间复杂度为 <code>O(mn)</code>，**Go 会对方法集的函数按照函数名的字典序进行排序，所以实际的时间复杂度为 <code>O(m+n)</code>**。</p><p>下面是一个接口转换为接口的例子</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-keyword">type</span> coder <span class="hljs-keyword">interface</span> &#123;code()run()&#125;<span class="hljs-keyword">type</span> runner <span class="hljs-keyword">interface</span> &#123;run()&#125;<span class="hljs-keyword">type</span> Gopher <span class="hljs-keyword">struct</span> &#123;language <span class="hljs-type">string</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g Gopher)</span></span> code() &#123;<span class="hljs-keyword">return</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g Gopher)</span></span> run() &#123;<span class="hljs-keyword">return</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> c coder = Gopher&#123;&#125;<span class="hljs-keyword">var</span> r runnerr = cfmt.Println(c, r)&#125;</code></pre></div><p>执行命令 go tool compile -S .&#x2F;src&#x2F;main.go 后的编译结果如下：</p><div class="code-wrapper"><pre><code class="hljs shell">0x0000 00000 (.\I2I.go:26)      TEXT    &quot;&quot;.main(SB), ABIInternal, $104-0        0x0000 00000 (.\I2I.go:26)      CMPQ    SP, 16(R14)        0x0004 00004 (.\I2I.go:26)      PCDATA  $0, $-2        0x0004 00004 (.\I2I.go:26)      JLS     164        0x000a 00010 (.\I2I.go:26)      PCDATA  $0, $-1        0x000a 00010 (.\I2I.go:26)      SUBQ    $104, SP        0x000e 00014 (.\I2I.go:26)      MOVQ    BP, 96(SP)        0x0013 00019 (.\I2I.go:26)      LEAQ    96(SP), BP        0x0018 00024 (.\I2I.go:26)      FUNCDATA        $0, gclocals·69c1753bd5f81501d95132d08af04464(SB)        0x0018 00024 (.\I2I.go:26)      FUNCDATA        $1, gclocals·232077072e4d4c4b841d7a2024b5b669(SB)        0x0018 00024 (.\I2I.go:26)      FUNCDATA        $2, &quot;&quot;.main.stkobj(SB)        0x0018 00024 (.\I2I.go:27)      MOVUPS  X15, &quot;&quot;..autotmp_10+48(SP)        0x001e 00030 (.\I2I.go:27)      MOVQ    &quot;&quot;..autotmp_10+48(SP), AX        0x0023 00035 (.\I2I.go:27)      XORL    BX, BX        0x0025 00037 (.\I2I.go:27)      PCDATA  $1, $0        0x0025 00037 (.\I2I.go:27)      CALL    runtime.convTstring(SB)        0x002a 00042 (.\I2I.go:27)      MOVQ    AX, &quot;&quot;..autotmp_27+40(SP)        0x002f 00047 (.\I2I.go:30)      LEAQ    go.itab.&quot;&quot;.Gopher,&quot;&quot;.coder(SB), BX        0x0036 00054 (.\I2I.go:30)      LEAQ    type.&quot;&quot;.runner(SB), AX        0x003d 00061 (.\I2I.go:30)      PCDATA  $1, $1        0x003d 00061 (.\I2I.go:30)      NOP        0x0040 00064 (.\I2I.go:30)      CALL    runtime.convI2I(SB)        0x0045 00069 (.\I2I.go:31)      MOVUPS  X15, &quot;&quot;..autotmp_15+64(SP)        ......</code></pre></div><p>&emsp;&emsp;从编译结果可以看到在 r&#x3D;c 这一行主要调用的是<code>runtime.convI2I(SB)</code>,这是将一个 <code>interface</code> 转换成另外一个 <code>interface</code>，看一下源码：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">convI2I</span><span class="hljs-params">(inter *interfacetype, i iface)</span></span> (r iface) &#123;tab := i.tab<span class="hljs-keyword">if</span> tab == <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span>&#125;<span class="hljs-keyword">if</span> tab.inter == inter &#123;r.tab = tabr.data = i.data<span class="hljs-keyword">return</span>&#125;r.tab = getitab(inter, tab._type, <span class="hljs-literal">false</span>)r.data = i.data<span class="hljs-keyword">return</span>&#125;</code></pre></div><p>&emsp;&emsp;我们知道， <code>iface</code> 是由 <code>tab</code> 和 <code>data</code> 两个字段组成。所以，实际上 <code>convI2I</code> 函数真正要做的事，找到新 <code>interface</code> 的 <code>tab</code> 和 <code>data</code>，就大功告成了。我们还知道，<code>tab</code> 是由接口类型 <code>interfacetype</code> 和 实体类型 <code>_type</code>。所以最关键的语句是 <code>r.tab = getitab(inter, tab._type, false)</code>。</p><p>我们重点看一下 <code>getitab</code> 函数的源码：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// runtime/iface.go</span><span class="hljs-keyword">const</span> (   hashSize = <span class="hljs-number">1009</span>)<span class="hljs-keyword">var</span> (   ifaceLock mutex <span class="hljs-comment">// lock for accessing hash</span>   hash      [hashSize]*itab)<span class="hljs-comment">// 简单的Hash算法</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">itabhash</span><span class="hljs-params">(inter *interfacetype, typ *_type)</span></span> <span class="hljs-type">uint32</span> &#123;   h := inter.typ.hash   h += <span class="hljs-number">17</span> * typ.hash   <span class="hljs-keyword">return</span> h % hashSize&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getitab</span><span class="hljs-params">(inter *interfacetype, typ *_type, canfail <span class="hljs-type">bool</span>)</span></span> *itab &#123;<span class="hljs-comment">// ……</span>    <span class="hljs-comment">// 根据 inter, typ 计算出 hash 值</span>h := itabhash(inter, typ)<span class="hljs-comment">// look twice - once without lock, once with.</span><span class="hljs-comment">// common case will be no lock contention.</span><span class="hljs-keyword">var</span> m *itab<span class="hljs-keyword">var</span> locked <span class="hljs-type">int</span><span class="hljs-keyword">for</span> locked = <span class="hljs-number">0</span>; locked &lt; <span class="hljs-number">2</span>; locked++ &#123;<span class="hljs-keyword">if</span> locked != <span class="hljs-number">0</span> &#123;lock(&amp;ifaceLock)        &#125;                <span class="hljs-comment">// 遍历哈希表的一个 slot</span><span class="hljs-keyword">for</span> m = (*itab)(atomic.Loadp(unsafe.Pointer(&amp;hash[h]))); m != <span class="hljs-literal">nil</span>; m = m.link &#123;            <span class="hljs-comment">// 如果在 hash 表中已经找到了 itab（inter 和 typ 指针都相同）</span><span class="hljs-keyword">if</span> m.inter == inter &amp;&amp; m._type == typ &#123;                <span class="hljs-comment">// ……</span>                <span class="hljs-keyword">if</span> locked != <span class="hljs-number">0</span> &#123;unlock(&amp;ifaceLock)&#125;<span class="hljs-keyword">return</span> m&#125;&#125;&#125;    <span class="hljs-comment">// 在 hash 表中没有找到 itab，那么新生成一个 itab</span>m = (*itab)(persistentalloc(unsafe.Sizeof(itab&#123;&#125;)+<span class="hljs-type">uintptr</span>(<span class="hljs-built_in">len</span>(inter.mhdr)<span class="hljs-number">-1</span>)*sys.PtrSize, <span class="hljs-number">0</span>, &amp;memstats.other_sys))m.inter = inter    m._type = typ        <span class="hljs-comment">// 添加到全局的 hash 表中</span>additab(m, <span class="hljs-literal">true</span>, canfail)unlock(&amp;ifaceLock)<span class="hljs-keyword">if</span> m.bad &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>&#125;<span class="hljs-keyword">return</span> m&#125;</code></pre></div><p>&emsp;&emsp;简单总结一下：getitab 函数会根据 <code>interfacetype</code> 和 <code>_type</code> 去全局的 itab 哈希表中查找，如果能找到，则直接返回；否则，会根据给定的 <code>interfacetype</code> 和 <code>_type</code> 新生成一个 <code>itab</code>，并插入到 itab 哈希表，这样下一次就可以直接拿到 <code>itab</code>。</p><p>&emsp;&emsp;这里查找了两次，并且第二次上锁了，这是因为如果第一次没找到，在第二次仍然没有找到相应的 <code>itab</code> 的情况下，需要新生成一个，并且写入哈希表，因此需要加锁。这样，其他协程在查找相同的 <code>itab</code> 并且也没有找到时，第二次查找时，会被挂住，之后，就会查到第一个协程写入哈希表的 <code>itab</code>。</p><p>再来看一下<code>additab</code> 函数的代码：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// 检查 _type 是否符合 interface_type 并且创建对应的 itab 结构体 将其放到 hash 表中</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">additab</span><span class="hljs-params">(m *itab, locked, canfail <span class="hljs-type">bool</span>)</span></span> &#123;inter := m.intertyp := m._typex := typ.uncommon()<span class="hljs-comment">// both inter and typ have method sorted by name,</span><span class="hljs-comment">// and interface names are unique,</span><span class="hljs-comment">// so can iterate over both in lock step;</span>    <span class="hljs-comment">// the loop is O(ni+nt) not O(ni*nt).</span>    <span class="hljs-comment">// </span>    <span class="hljs-comment">// inter 和 typ 的方法都按方法名称进行了排序</span>    <span class="hljs-comment">// 并且方法名都是唯一的。所以循环的次数是固定的</span>    <span class="hljs-comment">// 只用循环 O(ni+nt)，而非 O(ni*nt)</span>ni := <span class="hljs-built_in">len</span>(inter.mhdr)nt := <span class="hljs-type">int</span>(x.mcount)xmhdr := (*[<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">16</span>]method)(add(unsafe.Pointer(x), <span class="hljs-type">uintptr</span>(x.moff)))[:nt:nt]j := <span class="hljs-number">0</span><span class="hljs-keyword">for</span> k := <span class="hljs-number">0</span>; k &lt; ni; k++ &#123;i := &amp;inter.mhdr[k]itype := inter.typ.typeOff(i.ityp)name := inter.typ.nameOff(i.name)iname := name.name()ipkg := name.pkgPath()<span class="hljs-keyword">if</span> ipkg == <span class="hljs-string">&quot;&quot;</span> &#123;ipkg = inter.pkgpath.name()&#125;<span class="hljs-keyword">for</span> ; j &lt; nt; j++ &#123;t := &amp;xmhdr[j]            tname := typ.nameOff(t.name)            <span class="hljs-comment">// 检查方法名字是否一致</span><span class="hljs-keyword">if</span> typ.typeOff(t.mtyp) == itype &amp;&amp; tname.name() == iname &#123;pkgPath := tname.pkgPath()<span class="hljs-keyword">if</span> pkgPath == <span class="hljs-string">&quot;&quot;</span> &#123;pkgPath = typ.nameOff(x.pkgpath).name()&#125;<span class="hljs-keyword">if</span> tname.isExported() || pkgPath == ipkg &#123;<span class="hljs-keyword">if</span> m != <span class="hljs-literal">nil</span> &#123;                        <span class="hljs-comment">// 获取函数地址，并加入到itab.fun数组中</span>ifn := typ.textOff(t.ifn)*(*unsafe.Pointer)(add(unsafe.Pointer(&amp;m.fun[<span class="hljs-number">0</span>]), <span class="hljs-type">uintptr</span>(k)*sys.PtrSize)) = ifn&#125;<span class="hljs-keyword">goto</span> nextimethod&#125;&#125;&#125;        <span class="hljs-comment">// ……</span>        m.bad = <span class="hljs-literal">true</span><span class="hljs-keyword">break</span>nextimethod:&#125;<span class="hljs-keyword">if</span> !locked &#123;throw(<span class="hljs-string">&quot;invalid itab locking&quot;</span>)    &#125;    <span class="hljs-comment">// 计算 hash 值</span>    h := itabhash(inter, typ)    <span class="hljs-comment">// 加到Hash Slot链表中</span>m.link = hash[h]m.inhash = <span class="hljs-literal">true</span>atomicstorep(unsafe.Pointer(&amp;hash[h]), unsafe.Pointer(m))&#125;</code></pre></div><p>&emsp;&emsp;<code>additab</code> 会检查 <code>itab</code> 持有的 <code>interfacetype</code> 和 <code>_type</code> 是否符合，就是看 <code>_type</code> 是否完全实现了 <code>interfacetype</code> 的方法，也就是看两者的方法列表重叠的部分就是 <code>interfacetype</code> 所持有的方法列表。注意到其中有一个双层循环，乍一看，循环次数是 <code>ni * nt</code>，但由于两者的函数列表都按照函数名称进行了排序，因此最终只执行了 <code>ni + nt</code> 次，代码里通过一个小技巧来实现：第二层循环并没有从 0 开始计数，而是从上一次遍历到的位置开始。</p><p>&amp;e<strong>msp;&emsp;并不是每次接口赋值都要去检查一次对象是否符合接口要求，而是只在第一次生成itab信息，之后通过hash表即可找到itab信息。</strong></p><p><strong>总结：</strong></p><ul><li>具体类型转空接口时，_type 字段直接复制源类型的 _type；调用 mallocgc 获得一块新内存，把值复制进去，data 再指向这块新内存。</li><li>具体类型转非空接口时，入参 tab 是编译器在编译阶段预先生成好的，新接口 tab 字段直接指向入参 tab 指向的 itab；调用 mallocgc 获得一块新内存，把值复制进去，data 再指向这块新内存。</li><li>而对于接口转接口，itab 调用 getitab 函数获取。只用生成一次，之后直接从 hash 表中获取。</li></ul><h2 id="8、interface实现多态"><a href="#8、interface实现多态" class="headerlink" title="8、interface实现多态"></a>8、interface实现多态</h2><p>多态是一种运行期的行为，它有以下几个特点：</p><blockquote><ol><li>一种类型具有多种类型的能力</li><li>允许不同的对象对同一消息做出灵活的反应</li><li>以一种通用的方式对待个使用的对象</li><li>非动态语言必须通过继承和接口的方式来实现</li></ol></blockquote><p>多态实现：</p><p>&emsp;&emsp;当我们调用接口类型的函数时，根据前面iface分析，我们会直接调用itab中的fun里保存的函数，类似于：<code>s.tab-&gt;fun[0]</code>，而因为fun里面保存的是实体类型实现的函数，所以当函数传入实现同一接口的不同实体类型的时候，调用的实际上是不同的函数实现，从而实现多态。</p><h2 id="9、Go接口与C-接口有何异同"><a href="#9、Go接口与C-接口有何异同" class="headerlink" title="9、Go接口与C++接口有何异同"></a>9、Go接口与C++接口有何异同</h2><p>接口定义了一种规范，描述了类的行为和功能，而不做具体实现。</p><p>C++ 的接口是使用抽象类来实现的，如果类中至少有一个函数被声明为纯虚函数，则这个类就是抽象类。纯虚函数是通过在声明中使用 “&#x3D; 0” 来指定的。例如：</p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span>&#123;   <span class="hljs-keyword">public</span>:      <span class="hljs-comment">// 纯虚函数</span>      <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">double</span> <span class="hljs-title">getArea</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;   <span class="hljs-keyword">private</span>:      string name;      <span class="hljs-comment">// 名称</span>&#125;;</code></pre></div><p>设计抽象类的目的，是为了给其他类提供一个可以继承的适当的基类。抽象类不能被用于实例化对象，它只能作为接口使用。</p><p><strong>派生类需要明确地声明它继承自基类，并且需要实现基类中所有的纯虚函数。</strong></p><p>C++ 定义接口的方式称为“侵入式”，而 Go 采用的是 “非侵入式”，不需要显式声明，只需要实现接口定义的函数，编译器自动会识别。</p><p>C++ 和 Go 在定义接口方式上的不同，也导致了底层实现上的不同。C++ 通过虚函数表来实现基类调用派生类的函数；而 Go 通过 <code>itab</code> 中的 <code>fun</code> 字段来实现接口变量调用实体类型的函数。C++ 中的虚函数表是在编译期生成的；而 Go 的 <code>itab</code> 中的 <code>fun</code> 字段是在运行期间动态生成的。原因在于，Go 中实体类型可能会无意中实现 N 多接口，很多接口并不是本来需要的，所以不能为类型实现的所有接口都生成一个 <code>itab</code>， 这也是“非侵入式”带来的影响；这在 C++ 中是不存在的，因为派生需要显示声明它继承自哪个基类。</p>]]></content>
    
    
    <categories>
      
      <category>Go面试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
